[
  {
    "question": "I accidentally committed the wrong files to Git but haven't pushed the commit to the server yet. How do I undo those commits from the local repository?",
    "answer": "Undo a commit & redo $ git commit -m \"Something terribly misguided\" # (0: Your Accident) $ git reset HEAD~ # (1) # === If you just want to undo the commit, stop here! === [ edit files as necessary ] # (2) $ git add . # (3) $ git commit -c ORIG_HEAD # (4) git reset is the command responsible for the undo . It will undo your last commit while leaving your working tree (the state of your files on disk) untouched. You'll need to add them again before you can commit them again. Make corrections to working tree files. git add anything that you want to include in your new commit. Commit the changes, reusing the old commit message. reset copied the old head to .git/ORIG_HEAD ; commit with -c ORIG_HEAD will open an editor, which initially contains the log message from the old commit and allows you to edit it. If you do not need to edit the message, you could use the -C option. Alternatively, to edit the previous commit (or just its commit message) , commit --amend will add changes within the current index to the previous commit. To remove (not revert) a commit that has been pushed to the server , rewriting history with git push origin main --force[-with-lease] is necessary. It's almost always a bad idea to use --force ; prefer --force-with-lease instead, and as noted in the git manual : You should understand the implications of rewriting history if you amend a commit that has already been published. Further Reading You can use git reflog to determine the SHA-1 for the commit to which you wish to revert. Once you have this value, use the sequence of commands as explained above. HEAD~ is the same as HEAD~1 . The article What is the HEAD in git? is helpful if you want to uncommit multiple commits."
  },
  {
    "question": "Failed Attempts to Delete a Remote Branch: $ git branch -d remotes/origin/bugfix error: branch 'remotes/origin/bugfix' not found. $ git branch -d origin/bugfix error: branch 'origin/bugfix' not found. $ git branch -rd origin/bugfix Deleted remote branch origin/bugfix (was 2a14ef7). $ git push Everything up-to-date $ git pull From github.com:gituser/gitproject * [new branch] bugfix -> origin/bugfix Already up-to-date. How do I properly delete the remotes/origin/bugfix branch both locally and remotely?",
    "answer": "Executive Summary git push -d <remote_name> <branchname> # Delete remote git branch -d <branchname> # Delete local Note: In most cases, <remote_name> will be origin . Delete Local Branch To delete the local branch, use one of the following: git branch -d <branch_name> git branch -D <branch_name> The -d option is an alias for --delete , which only deletes the branch if it has already been fully merged in its upstream branch. The -D option is an alias for --delete --force , which deletes the branch \"irrespective of its merged status.\" [Source: man git-branch ] As of Git v2.3 , git branch -d (delete) learned to honor the -f (force) flag. You will receive an error if you try to delete the currently selected branch. Delete Remote Branch As of Git v1.7.0 , you can delete a remote branch using $ git push <remote_name> --delete <branch_name> which might be easier to remember than $ git push <remote_name> :<branch_name> which was added in Git v1.5.0 \"to delete a remote branch or a tag.\" Starting with Git v2.8.0 , you can also use git push with the -d option as an alias for --delete . Therefore, the version of Git you have installed will dictate whether you need to use the easier or harder syntax. Delete Remote Branch [Original Answer from 5-Jan-2010] From Chapter 3 of Pro Git by Scott Chacon: Deleting Remote Branches Suppose you’re done with a remote branch — say, you and your collaborators are finished with a feature and have merged it into your remote’s main branch (or whatever branch your stable code-line is in). You can delete a remote branch using the rather obtuse syntax git push [remotename] :[branch] . If you want to delete your serverfix branch from the server, you run the following: $ git push origin :serverfix To git@github.com:schacon/simplegit.git - [deleted] serverfix Boom. No more branches on your server. You may want to dog-ear this page, because you’ll need that command, and you’ll likely forget the syntax. A way to remember this command is by recalling the git push [remotename] [localbranch]:[remotebranch] syntax that we went over a bit earlier. If you leave off the [localbranch] portion, then you’re basically saying, “Take nothing on my side and make it be [remotebranch] .” I ran git push origin :bugfix , and it worked beautifully. Scott Chacon was right—I will want to dog-ear that page (or virtually dog ear-by answering this on Stack Overflow). Fetch changes Finally, execute the following on other machines to propagate changes: # Fetch changes from all remotes and locally delete # remote deleted branches/tags etc # --prune will do the job :-; git fetch --all --prune"
  },
  {
    "question": "What are the differences between git pull and git fetch ?",
    "answer": "In the simplest terms, git pull does a git fetch followed by a git merge . git fetch updates your remote-tracking branches under refs/remotes/<remote>/ . This operation is safe to run at any time since it never changes any of your local branches under refs/heads . git pull brings a local branch up-to-date with its remote version, while also updating your other remote-tracking branches. From the Git documentation for git pull : git pull runs git fetch with the given parameters and then depending on configuration options or command line flags, will call either git rebase or git merge to reconcile diverging branches."
  },
  {
    "question": "How can I rename a local branch which has not yet been pushed to a remote repository? Related: Rename master branch for both local and remote Git repositories How do I rename both a Git local and remote branch name?",
    "answer": "To rename the current branch: git branch -m <newname> To rename a branch while pointed to any branch: git branch -m <oldname> <newname> -m is short for --move . To push the local branch and reset the upstream branch: git push origin -u <newname> To delete the remote branch: git push origin --delete <oldname> To create a git rename alias: git config --global alias.rename 'branch -m' On Windows or another case-insensitive filesystem, use -M if there are only capitalization changes in the name. Otherwise, Git will throw a \"branch already exists\" error. git branch -M <newname>"
  },
  {
    "question": "I mistakenly added files to Git using the command: git add myfile.txt I have not yet run git commit . How do I undo this so that these changes will not be included in the commit?",
    "answer": "To unstage a specific file git reset <file> That will remove the file from the current index (the \"about to be committed\" list) without changing anything else. To unstage all files from the current change set: git reset In old versions of Git, the above commands are equivalent to git reset HEAD <file> and git reset HEAD respectively, and will fail if HEAD is undefined (because you haven't yet made any commits in your repository) or ambiguous (because you created a branch called HEAD , which is a stupid thing that you shouldn't do). This was changed in Git 1.8.2 , though, so in modern versions of Git you can use the commands above even prior to making your first commit: \"git reset\" (without options or parameters) used to error out when you do not have any commits in your history, but it now gives you an empty index (to match non-existent commit you are not even on). Documentation: git reset"
  },
  {
    "question": "How do I force an overwrite of local files on a git pull ? My local repository contains a file of the same filename as on the server. error: Untracked working tree file 'example.txt' would be overwritten by merge",
    "answer": "⚠ Warning: Any uncommitted local change to tracked files will be lost, even if staged . But any local file that's not tracked by Git will not be affected. First, update all origin/<branch> refs to latest: git fetch --all Backup your current branch (e.g. main ): git branch backup-main Jump to the latest commit on origin/main and checkout those files: git reset --hard origin/main Explanation: git fetch downloads the latest from remote without trying to merge or rebase anything. git reset resets the master branch to what you just fetched. The --hard option changes all the files in your working tree to match the files in origin/main . Maintain current local commits [*] : It's worth noting that it is possible to maintain current local commits by creating a branch from main before resetting: git checkout main git branch new-branch-to-save-current-commits git fetch --all git reset --hard origin/main After this, all of the old commits will be kept in new-branch-to-save-current-commits . Uncommitted changes Uncommitted changes, even if staged (with git add ), will be lost. Make sure to stash or commit anything you need. For example, run the following: git stash And later (after git reset ), reapply these uncommitted changes: git stash pop Which may create merge conflicts."
  },
  {
    "question": "How do I check out the remote test branch? I can see it with git branch -r . I tried: git checkout test , which does nothing git checkout origin/test gives * (no branch)",
    "answer": "The answer has been split depending on whether there is one remote repository configured or multiple. The reason for this is that for the single remote case, some of the commands can be simplified as there is less ambiguity. Updated for Git 2.23: For older versions, see the section at the end. With One Remote In both cases, start by fetching from the remote repository to make sure you have all the latest changes downloaded. $ git fetch This will fetch all of the remote branches for you. You can see the branches available for checkout with: $ git branch -v -a ... remotes/origin/test The branches that start with remotes/* can be thought of as read only copies of the remote branches. To work on a branch you need to create a local branch from it. This is done with the Git command switch (since Git 2.23) by giving it the name of the remote branch (minus the remote name): $ git switch test In this case Git is guessing (can be disabled with --no-guess ) that you are trying to checkout and track the remote branch with the same name. With Multiple Remotes In the case where multiple remote repositories exist, the remote repository needs to be explicitly named. As before, start by fetching the latest remote changes: $ git fetch origin This will fetch all of the remote branches for you. You can see the branches available for checkout with: $ git branch -v -a With the remote branches in hand, you now need to check out the branch you are interested in with -c to create a new local branch: $ git switch -c test origin/test For more information about using git switch : $ man git-switch Prior to Git 2.23 git switch was added in Git 2.23, prior to this git checkout was used to switch branches. To checkout out with only a single remote repository: git checkout test if there are multiple remote repositories configured then it becomes a bit longer git checkout -b test <name of remote>/test"
  },
  {
    "question": "I put a file that was previously being tracked by Git onto the .gitignore list. However, the file still shows up in git status after it is edited. How do I force Git to completely forget the file?",
    "answer": ".gitignore will prevent untracked files from being added (without an add -f ) to the set of files tracked by Git. However, Git will continue to track any files that are already being tracked. Updated Answer in 2024 Do NOT use git rm --cached <file> if you ever want to see that file again. It will remove it from git, and also your local machine. If you want to keep the file locally, but remove it from git tracking, use the answer by Konstantin. In short, use the following instead of git rm : git update-index --skip-worktree <file> However, according to the official git documentation : Users often try to use the assume-unchanged and skip-worktree bits to tell Git to ignore changes to files that are tracked. This does not work as expected, since Git may still check working tree files against the index when performing certain operations. In general, Git does not provide a way to ignore changes to tracked files, so alternate solutions are recommended. Therefore, you should still consider using the original answer below. Original Answer WARNING: This will remove the physical file from your local machine and other developers' machines on your or their next git pull . To stop tracking a file, we must remove it from the index: git rm --cached <file> To remove a folder and all files in the folder recursively: git rm -r --cached <folder> The removal of the file from the head revision will happen on the next commit."
  },
  {
    "question": "How do I delete untracked local files from the current working tree?",
    "answer": "git-clean - Remove untracked files from the working tree Synopsis git clean [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] <path>…​ Description Cleans the working tree by recursively removing files that are not under version control, starting from the current directory . Normally, only files unknown to Git are removed, but if the -x option is specified, ignored files are also removed. This can, for example, be useful to remove all build products. If any optional <path>... arguments are given, only those paths are affected. Step 1 is to show what will be deleted by using the -n option: # Print out the list of files and directories which will be removed (dry run) git clean -n -d Clean Step - beware: this will delete files : # Delete the files from the repository git clean -f To remove directories, run git clean -f -d or git clean -fd To remove ignored files, run git clean -f -X or git clean -fX To remove ignored and non-ignored files, run git clean -f -x or git clean -fx Note the case difference on the X for the two latter commands. If clean.requireForce is set to \"true\" (the default) in your configuration, one needs to specify -f otherwise nothing will actually happen. Again see the git-clean docs for more information. Options -f , --force If the Git configuration variable clean.requireForce is not set to false, git clean will refuse to run unless given -f , -n or -i . -x Don’t use the standard ignore rules read from .gitignore (per directory) and $GIT_DIR/info/exclude , but do still use the ignore rules given with -e options. This allows removing all untracked files, including build products. This can be used (possibly in conjunction with git reset) to create a pristine working directory to test a clean build. -X Remove only files ignored by Git. This may be useful to rebuild everything from scratch, but keep manually created files. -n , --dry-run Don’t actually remove anything, just show what would be done. -d Remove untracked directories in addition to untracked files. If an untracked directory is managed by a different Git repository, it is not removed by default. Use -f option twice if you really want to remove such a directory."
  },
  {
    "question": "How do I find all files containing a specific string of text within their file contents? The following doesn't work. It seems to display every single file in the system. find / -type f -exec grep -H 'text-to-find-here' {} \\;",
    "answer": "Do the following: grep -rnw '/path/to/somewhere/' -e 'pattern' -r or -R is recursive, -n is line number, and -w stands for match the whole word. -l (lower-case L) can be added to just give the file name of matching files. -e is the pattern used during the search Along with these, --exclude , --include , --exclude-dir flags could be used for efficient searching: This will only search through those files which have .c or .h extensions: grep --include=\\*.{c,h} -rnw '/path/to/somewhere/' -e \"pattern\" This will exclude searching all the files ending with .o extension: grep --exclude=\\*.o -rnw '/path/to/somewhere/' -e \"pattern\" For directories it's possible to exclude one or more directories using the --exclude-dir parameter. For example, this will exclude the dirs dir1/ , dir2/ and all of them matching *.dst/ : grep --exclude-dir={dir1,dir2,*.dst} -rnw '/path/to/search/' -e \"pattern\" This works very well for me, to achieve almost the same purpose like yours. For more options, see man grep ."
  },
  {
    "question": "I wrote the wrong thing in a commit message. How can I change the message? The commit has not been pushed yet.",
    "answer": "Amending the most recent commit message git commit --amend will open your editor, allowing you to change the commit message of the most recent commit. Additionally, you can set the commit message directly in the command line with: git commit --amend -m \"New commit message\" …however, this can make multi-line commit messages or small corrections more cumbersome to enter. Make sure you don't have any working copy changes staged before doing this or they will get committed too. ( Unstaged changes will not get committed.) Changing the message of a commit that you've already pushed to your remote branch If you've already pushed your commit up to your remote branch, then - after amending your commit locally (as described above) - you'll also need to force push the commit with: git push <remote> <branch> --force # Or git push <remote> <branch> -f Warning: force-pushing will overwrite the remote branch with the state of your local one . If there are commits on the remote branch that you don't have in your local branch, you will lose those commits. Warning: be cautious about amending commits that you have already shared with other people. Amending commits essentially rewrites them to have different SHA IDs, which poses a problem if other people have copies of the old commit that you've rewritten. Anyone who has a copy of the old commit will need to synchronize their work with your newly re-written commit, which can sometimes be difficult, so make sure you coordinate with others when attempting to rewrite shared commit history, or just avoid rewriting shared commits altogether. Perform an interactive rebase Another option is to use interactive rebase. This allows you to edit any message you want to update even if it's not the latest message. In order to do a Git squash, follow these steps: // n is the number of commits up to the last commit you want to be able to edit git rebase -i HEAD~n Once you squash your commits - choose the e/r for editing the message: Important note about interactive rebase When you use git rebase -i HEAD~n there can be more than n commits. Git will \"collect\" all the commits in the last n commits, and if there was a merge somewhere in between that range you will see all the commits as well, so the outcome will be n + . Good tip: If you have to do it for more than a single branch and you might face conflicts when amending the content, set up git rerere and let Git resolve those conflicts automatically for you. Documentation git-commit(1) Manual Page git-rebase(1) Manual Page git-push(1) Manual Page"
  },
  {
    "question": "How do I revert from my current state to a snapshot made on a certain commit? If I do git log , then I get the following output: $ git log commit a867b4af366350be2e7c21b8de9cc6504678a61b` Author: Me <me@me.com> Date: Thu Nov 4 18:59:41 2010 -0400 blah blah blah... commit 25eee4caef46ae64aa08e8ab3f988bc917ee1ce4 Author: Me <me@me.com> Date: Thu Nov 4 05:13:39 2010 -0400 more blah blah blah... commit 0766c053c0ea2035e90f504928f8df3c9363b8bd Author: Me <me@me.com> Date: Thu Nov 4 00:55:06 2010 -0400 And yet more blah blah... commit 0d1d7fc32e5a947fbd92ee598033d85bfc445a50 Author: Me <me@me.com> Date: Wed Nov 3 23:56:08 2010 -0400 Yep, more blah blah. How do I revert to the commit from November 3, i.e. commit 0d1d7fc ?",
    "answer": "This depends a lot on what you mean by \"revert\". Temporarily switch to a different commit If you want to temporarily go back to it, fool around, then come back to where you are, all you have to do is check out the desired commit: # This will detach your HEAD, that is, leave you with no branch checked out: git checkout 0d1d7fc32 Or if you want to make commits while you're there, go ahead and make a new branch while you're at it: git checkout -b old-state 0d1d7fc32 To go back to where you were, just check out the branch you were on again. (If you've made changes, as always when switching branches, you'll have to deal with them as appropriate. You could reset to throw them away; you could stash, checkout, stash pop to take them with you; you could commit them to a branch there if you want a branch there.) Hard delete unpublished commits If, on the other hand, you want to really get rid of everything you've done since then, there are two possibilities. One, if you haven't published any of these commits, simply reset: # This will destroy any local modifications. # Don't do it if you have uncommitted work you want to keep. git reset --hard 0d1d7fc32 # Alternatively, if there's work to keep: git stash git reset --hard 0d1d7fc32 git stash pop # This saves the modifications, then reapplies that patch after resetting. # You could get merge conflicts, if you've modified things which were # changed since the commit you reset to. If you mess up, you've already thrown away your local changes, but you can at least get back to where you were before by resetting again. Undo published commits with new commits On the other hand, if you've published the work, you probably don't want to reset the branch, since that's effectively rewriting history. In that case, you could indeed revert the commits. In many enterprise organisations, the concept of \"protected\" branches will even prevent history from being rewritten on some major branches. In this case, reverting is your only option. With Git, revert has a very specific meaning: create a commit with the reverse patch to cancel it out. This way you don't rewrite any history. First figure out what commits to revert. Depending on the technique chosen below, you want to either revert only the merge commits, or only the non-merge commits. # This lists all merge commits between 0d1d7fc and HEAD: git log --merges --pretty=format:\"%h\" 0d1d7fc..HEAD | tr '\\n' ' ' # This lists all non merge commits between 0d1d7fc and HEAD: git log --no-merges --pretty=format:\"%h\" 0d1d7fc..HEAD | tr '\\n' ' ' Note: if you revert multiple commits, the order matters. Start with the most recent commit. # This will create three separate revert commits, use non merge commits only: git revert a867b4af 25eee4ca 0766c053 # It also takes ranges. This will revert the last two commits: git revert HEAD~2..HEAD # Similarly, you can revert a range of commits using commit hashes (non inclusive of first hash): git revert 0d1d7fc..a867b4a # Reverting a merge commit. You can also use a range of merge commits here. git revert -m 1 <merge_commit_sha> # To get just one, you could use `rebase -i` to squash them afterwards # Or, you could do it manually (be sure to do this at top level of the repo) # get your index and work tree into the desired state, without changing HEAD: git checkout 0d1d7fc32 . # Then commit. Be sure and write a good message describing what you just did git commit The git-revert manpage actually covers a lot of this in its description. Another useful link is this git-scm.com section discussing git-revert . If you decide you didn't want to revert after all, you can revert the revert (as described here) or reset back to before the revert (see the previous section). You may also find this answer helpful in this case: How can I move HEAD back to a previous location? (Detached head) & Undo commits"
  },
  {
    "question": "I have a repo (origin) on a USB key that I cloned on my hard drive (local). I moved \"origin\" to a NAS and successfully tested cloning it from here. I would like to know if I can change the URI of \"origin\" in the settings of \"local\" so it will now pull from the NAS, and not from the USB key. For now, I can see two solutions: push everything to the USB origin, and copy it to the NAS again (implies a lot of work due to new commits to NAS origin); add a new remote to \"local\" and delete the old one (I fear I'll break my history).",
    "answer": "First, view the existing remotes to verify which URL is currently set: git remote -v Then, you can set it with: git remote set-url origin <NEW_GIT_URL_HERE> See git help remote . You also can edit .git/config and change the URLs there. You're not in any danger of losing history unless you do something very silly (and if you're worried, just make a copy of your repo, since your repo is your history.)"
  },
  {
    "question": "How do I move my recent commits on master to a new branch, and reset master to before those commits were made? e.g. From this: master A - B - C - D - E To this: newbranch C - D - E / master A - B",
    "answer": "WARNING: You need to store uncommitted edits to your stash before doing this, using git stash . Once complete, you can retrieve the stashed uncommitted edits with git stash pop . git reset hard command will remove all changes! Moving to an existing branch If you want to move your commits to an existing branch , it will look like this: git checkout existingbranch git merge branchToMoveCommitFrom git checkout branchToMoveCommitFrom git reset --hard HEAD~3 # Go back 3 commits. You *will* lose uncommitted work. git checkout existingbranch Moving to a new branch WARNING: This method works because you are creating a new branch with the first command: git branch newbranch . If you want to move commits to an existing branch you need to merge your changes into the existing branch before executing git reset --hard HEAD~3 (see Moving to an existing branch above). If you don't merge your changes first, they will be lost. Unless there are other circumstances involved, this can be easily done by branching and rolling back. # Note: Any changes not committed will be lost. git branch newbranch # Create a new branch, saving the desired commits git checkout master # checkout master, this is the place you want to go back git reset --hard HEAD~3 # Move master back by 3 commits (Make sure you know how many commits you need to go back) git checkout newbranch # Go to the new branch that still has the desired commits But do make sure how many commits to go back. Alternatively, you can instead of HEAD~3 , simply provide the hash of the commit (or the reference like origin/master ) you want to \"revert back to\" on the master (/current) branch, e.g: git reset --hard a1b2c3d4 Note: You will only be \"losing\" commits from the master branch, but don't worry, you'll have those commits in newbranch! An easy way to check that, after completing the 4 step sequence of commands above, is by looking at git log -n4 which will show the history of newbranch actually retained the 3 commits (and the reason is that newbranch was created at the time those changes were already commited on master!). They have only been removed from master, as git reset only affected the branch that was checked out at the time of its execution, i.e. master (see git reset description: Reset current HEAD to the specified state ). git status however will not show any checkouts on the newbranch, which might be surprising at first but that is actually expected. Lastly, you may need to force push your latest changes to main repo: git push origin master --force WARNING: With Git version 2.0 and later, if you later git rebase the new branch upon the original ( master ) branch, you may need an explicit --no-fork-point option during the rebase to avoid losing the carried-over commits. Having branch.autosetuprebase always set makes this more likely. See John Mellor's answer for details."
  },
  {
    "question": "How do I discard changes in my working copy that are not in the index?",
    "answer": "Another quicker way is: git stash save --keep-index --include-untracked You don't need to include --include-untracked if you don't want to be thorough about it. After that, you can drop that stash with a git stash drop command if you like."
  },
  {
    "question": "How do I get the path of the directory in which a Bash script is located, inside that script? I want to use a Bash script as a launcher for another application. I want to change the working directory to the one where the Bash script is located, so I can operate on the files in that directory, like so: $ ./application",
    "answer": "#!/usr/bin/env bash SCRIPT_DIR=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd ) is a useful one-liner which will give you the full directory name of the script no matter where it is being called from. It will work as long as the last component of the path used to find the script is not a symlink (directory links are OK). If you also want to resolve any links to the script itself, you need a multi-line solution: #!/usr/bin/env bash get_script_dir() { local SOURCE_PATH=\"${BASH_SOURCE[0]}\" local SYMLINK_DIR local SCRIPT_DIR # Resolve symlinks recursively while [ -L \"$SOURCE_PATH\" ]; do # Get symlink directory SYMLINK_DIR=\"$( cd -P \"$( dirname \"$SOURCE_PATH\" )\" >/dev/null 2>&1 && pwd )\" # Resolve symlink target (relative or absolute) SOURCE_PATH=\"$(readlink \"$SOURCE_PATH\")\" # Check if candidate path is relative or absolute if [[ $SOURCE_PATH != /* ]]; then # Candidate path is relative, resolve to full path SOURCE_PATH=$SYMLINK_DIR/$SOURCE_PATH fi done # Get final script directory path from fully resolved source path SCRIPT_DIR=\"$(cd -P \"$( dirname \"$SOURCE_PATH\" )\" >/dev/null 2>&1 && pwd)\" echo \"$SCRIPT_DIR\" } echo \"get_script_dir: $(get_script_dir)\" This last one will work with any combination of aliases, source , bash -c , symlinks, etc. Beware: if you cd to a different directory before running this snippet, the result may be incorrect! Also, watch out for $CDPATH gotchas , and stderr output side effects if the user has smartly overridden cd to redirect output to stderr instead (including escape sequences, such as when calling update_terminal_cwd >&2 on Mac). Adding >/dev/null 2>&1 at the end of your cd command will take care of both possibilities. To understand how it works, try running this more verbose form: #!/usr/bin/env bash SOURCE=${BASH_SOURCE[0]} while [ -L \"$SOURCE\" ]; do # resolve $SOURCE until the file is no longer a symlink TARGET=$(readlink \"$SOURCE\") if [[ $TARGET == /* ]]; then echo \"SOURCE '$SOURCE' is an absolute symlink to '$TARGET'\" SOURCE=$TARGET else DIR=$( dirname \"$SOURCE\" ) echo \"SOURCE '$SOURCE' is a relative symlink to '$TARGET' (relative to '$DIR')\" SOURCE=$DIR/$TARGET # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located fi done echo \"SOURCE is '$SOURCE'\" RDIR=$( dirname \"$SOURCE\" ) DIR=$( cd -P \"$( dirname \"$SOURCE\" )\" >/dev/null 2>&1 && pwd ) if [ \"$DIR\" != \"$RDIR\" ]; then echo \"DIR '$RDIR' resolves to '$DIR'\" fi echo \"DIR is '$DIR'\" And it will print something like: SOURCE './scriptdir.sh' is a relative symlink to 'sym2/scriptdir.sh' (relative to '.') SOURCE is './sym2/scriptdir.sh' DIR './sym2' resolves to '/home/ubuntu/dotfiles/fo fo/real/real1/real2' DIR is '/home/ubuntu/dotfiles/fo fo/real/real1/real2'"
  },
  {
    "question": "How do I reset my local branch to be just like the branch on the remote repository? I tried: git reset --hard HEAD But git status claims I have modified files: On branch master Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) modified: java/com/mycompany/TestContacts.java modified: java/com/mycompany/TestParser.java",
    "answer": "Setting your branch to exactly match the remote branch can be done in two steps: git fetch origin git reset --hard origin/master If your default branch is main (GitHub changed the default branch name from master to main starting October 1, 2020 ): git reset --hard origin/main If you want to save your current branch's state before doing this (just in case), you can do: git commit -a -m \"Saving my work, just in case\" git branch my-saved-work Now your work is saved on the branch \"my-saved-work\" in case you decide you want it back (or want to look at it later or diff it against your updated branch). Note that the first example assumes that the remote repo's name is \"origin\" and that the branch named \"master\" in the remote repo matches the currently checked-out branch in your local repo. BTW, this situation that you're in looks an awful lot like a common case where a push has been done into the currently checked out branch of a non-bare repository. Did you recently push into your local repo? If not, then no worries -- something else must have caused these files to unexpectedly end up modified. Otherwise, you should be aware that it's not recommended to push into a non-bare repository (and not into the currently checked-out branch, in particular)."
  },
  {
    "question": "How can I revert a modified file to its previous revision at a specific commit hash (which I determined via git log and git diff )?",
    "answer": "Assuming the hash of the commit you want is c5f567 : git checkout c5f567 -- file1/to/restore file2/to/restore The git checkout man page gives more information. If you want to revert to the commit before c5f567 , append ~1 (where 1 is the number of commits you want to go back, it can be anything): git checkout c5f567~1 -- file1/to/restore file2/to/restore As a side note, I've always been uncomfortable with this command because it's used for both ordinary things (changing between branches) and unusual, destructive things (discarding changes in the working directory). For the meaning of -- in the command, refer to In Git, what does -- (dash dash) mean? There is also a new git restore command that is specifically designed for restoring working copy files that have been modified. If your git is new enough you can use this command, but the documentation comes with a warning: THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE. Because git restore is experimental, it should not yet be promoted as the primary answer to this question. When the command is no longer marked as \"experimental\", then this answer can be amended to promote the use of git restore . [At the time of writing, the git restore command has been marked as \"experimental\" for at least four years.]"
  },
  {
    "question": "How do I: Create a local branch from another branch (via git branch or git checkout -b ). Push the local branch to the remote repository (i.e. publish), but make it trackable so that git pull and git push will work.",
    "answer": "In Git 1.7.0 and later, you can checkout a new branch: git checkout -b <branch> Edit files, add and commit. Then push with the -u (short for --set-upstream ) option: git push -u origin <branch> Git will set up the tracking information during the push."
  },
  {
    "question": "How do I squash my last N commits together into one commit?",
    "answer": "Use git rebase -i <after-this-commit> and replace \"pick\" on the second and subsequent commits with \"squash\" or \"fixup\", as described in the manual . In this example, <after-this-commit> is either the SHA1 hash or the relative location from the HEAD of the current branch from which commits are analyzed for the rebase command. For example, if the user wishes to view 5 commits from the current HEAD in the past, the command is git rebase -i HEAD~5 ."
  },
  {
    "question": "I pulled a project with several forks on GitHub, but forgot which fork it was. How do I determine which fork I pulled?",
    "answer": "To obtain only the remote URL: git config --get remote.origin.url If you require full output, and you are on a network that can reach the remote repo where the origin resides: git remote show origin When using git clone (from GitHub, or any source repository for that matter) the default name for the source of the clone is \"origin\". Using git remote show will display the information about this remote name. The first few lines should show: C:\\Users\\jaredpar\\VsVim> git remote show origin * remote origin Fetch URL: git@github.com:jaredpar/VsVim.git Push URL: git@github.com:jaredpar/VsVim.git HEAD branch: master Remote branches: If you want to use the value in a script, you would use the first command listed in this answer."
  },
  {
    "question": "How do I add an empty directory (that contains no files) to a Git repository?",
    "answer": "Another way to make a directory stay (almost) empty (in the repository) is to create a .gitignore file inside that directory that contains these four lines: # Ignore everything in this directory * # Except this file !.gitignore Then you don't have to get the order right the way that you have to do in m104's solution . This also gives the benefit that files in that directory won't show up as \"untracked\" when you do a git status. Making @GreenAsJade 's comment persistent: I think it's worth noting that this solution does precisely what the question asked for, but is not perhaps what many people looking at this question will have been looking for. This solution guarantees that the directory remains empty. It says \"I truly never want files checked in here\". As opposed to \"I don't have any files to check in here, yet, but I need the directory here, files may be coming later\"."
  },
  {
    "question": "How do I resolve merge conflicts in my Git repository?",
    "answer": "Try: git mergetool It opens a GUI that steps you through each conflict, and you get to choose how to merge. Sometimes it requires a bit of hand editing afterwards, but usually it's enough by itself. It is much better than doing the whole thing by hand certainly. As per Josh Glover's comment : [This command] doesn't necessarily open a GUI unless you install one. Running git mergetool for me resulted in vimdiff being used. You can install one of the following tools to use it instead: meld , opendiff , kdiff3 , tkdiff , xxdiff , tortoisemerge , gvimdiff , diffuse , ecmerge , p4merge , araxis , vimdiff , emerge . Below is a sample procedure using vimdiff to resolve merge conflicts, based on this link . Run the following commands in your terminal git config merge.tool vimdiff git config merge.conflictstyle diff3 git config mergetool.prompt false This will set vimdiff as the default merge tool. Run the following command in your terminal git mergetool You will see a vimdiff display in the following format: ╔═══════╦══════╦════════╗ ║ ║ ║ ║ ║ LOCAL ║ BASE ║ REMOTE ║ ║ ║ ║ ║ ╠═══════╩══════╩════════╣ ║ ║ ║ MERGED ║ ║ ║ ╚═══════════════════════╝ These 4 views are LOCAL: this is the file from the current branch BASE: the common ancestor, how this file looked before both changes REMOTE: the file you are merging into your branch MERGED: the merge result; this is what gets saved in the merge commit and used in the future You can navigate among these views using ctrl + w . You can directly reach the MERGED view using ctrl + w followed by j . More information about vimdiff navigation is here and here . You can edit the MERGED view like this: If you want to get changes from REMOTE :diffg RE If you want to get changes from BASE :diffg BA If you want to get changes from LOCAL :diffg LO Save, Exit, Commit, and Clean up :wqa save and exit from vi git commit -m \"message\" git clean Remove extra files (e.g. *.orig ). Warning: It will remove all untracked files, if you won't pass any arguments."
  },
  {
    "question": "How can I delete a Git tag that has already been pushed?",
    "answer": "You can push an 'empty' reference to the remote tag name: git push origin :tagname Or, more expressively, use the --delete option (or -d if your git version is older than 1.8.0): git push --delete origin tagname Note that git has tag namespace and branch namespace so you may use the same name for a branch and for a tag. If you want to make sure that you cannot accidentally remove the branch instead of the tag, you can specify full ref which will never delete a branch: git push origin :refs/tags/tagname If you also need to delete the local tag, use: git tag --delete tagname or git tag -d tagname Background Pushing a branch, tag, or other ref to a remote repository involves specifying \"which repo, what source, what destination?\" git push remote-repo source-ref:destination-ref A real world example where you push your master branch to the origin's master branch is: git push origin refs/heads/master:refs/heads/master Which because of default paths, can be shortened to: git push origin master:master Tags work the same way: git push origin refs/tags/release-1.0:refs/tags/release-1.0 Which can also be shortened to: git push origin release-1.0:release-1.0 By omitting the source ref (the part before the colon), you push 'nothing' to the destination, deleting the ref on the remote end."
  },
  {
    "question": "I accidentally ran git merge some_other_branch on my local master branch. I haven't pushed the changes to origin master. How do I undo the merge? After merging, git status says: # On branch master # Your branch is ahead of 'origin/master' by 5 commits. How do I undo all these commits?",
    "answer": "With git reflog check which commit is one prior the merge ( git reflog will be a better option than git log ). Then you can reset it using: git reset --hard commit_sha There's also another way: git reset --hard HEAD~1 It will get you back 1 commit. Be aware that any modified and uncommitted/unstashed files will be reset to their unmodified state . To keep them either stash changes away or see --merge option below. As @Velmont suggested below in his answer, in this direct case using: git reset --hard ORIG_HEAD might yield better results, as it should preserve your changes. ORIG_HEAD will point to a commit directly before merge has occurred, so you don't have to hunt for it yourself. A further tip is to use the --merge switch instead of --hard since it doesn't reset files unnecessarily: git reset --merge ORIG_HEAD --merge Resets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added)."
  },
  {
    "question": "My master and development branches are tracked remotely on GitHub . How do I clone both these branches?",
    "answer": "First, clone a remote Git repository and cd into it: $ git clone git://example.com/myproject $ cd myproject Next, look at the local branches in your repository: $ git branch * master But there are other branches hiding in your repository! See these using the -a flag: $ git branch -a * master remotes/origin/HEAD remotes/origin/master remotes/origin/v1.0-stable remotes/origin/experimental To take a quick peek at an upstream branch, check it out directly: $ git checkout origin/experimental To work on that branch, create a local tracking branch, which is done automatically by: $ git checkout experimental Branch experimental set up to track remote branch experimental from origin. Switched to a new branch 'experimental' Here, \"new branch\" simply means that the branch is taken from the index and created locally for you. As the previous line tells you, the branch is being set up to track the remote branch, which usually means the origin/branch_name branch. Your local branches should now show: $ git branch * experimental master You can track more than one remote repository using git remote : $ git remote add win32 git://example.com/users/joe/myproject-win32-port $ git branch -a * master remotes/origin/HEAD remotes/origin/master remotes/origin/v1.0-stable remotes/origin/experimental remotes/win32/master remotes/win32/new-widgets At this point, things are getting pretty crazy, so run gitk to see what's going on: $ gitk --all &"
  },
  {
    "question": "I forked a project, made changes, and created a pull request which was accepted. New commits were later added to the repository. How do I get those commits into my fork?",
    "answer": "In your local clone of your forked repository, you can add the original GitHub repository as a \"remote\". (\"Remotes\" are like nicknames for the URLs of repositories - origin is one, for example.) Then you can fetch all the branches from that upstream repository, and rebase your work to continue working on the upstream version. In terms of commands that might look like: # Add the remote, call it \"upstream\": git remote add upstream https://github.com/whoever/whatever.git # Fetch all the branches of that remote into remote-tracking branches git fetch upstream # Make sure that you're on your main branch: git checkout main # Rewrite your main branch so that any commits of yours that # aren't already in upstream/main are replayed on top of that # other branch: git rebase upstream/main If you don't want to rewrite the history of your main branch, (for example because other people may have cloned it) then you should replace the last command with git merge upstream/main . However, for making further pull requests that are as clean as possible, it's probably better to rebase. If you've rebased your branch onto upstream/main you may need to force the push in order to push it to your own forked repository on GitHub. You'd do that with: git push -f origin main You only need to use the -f the first time after you've rebased."
  },
  {
    "question": "How do I remove a Git submodule? Why can't I do git submodule rm module_name ?",
    "answer": "Since git1.8.3 (April 22d, 2013) : There was no Porcelain way to say \"I no longer am interested in this submodule\", once you express your interest in a submodule with \" git submodule init \". \" git submodule deinit \" is the way to do so. The deletion process also uses git rm (since git1.8.5 October 2013). Summary The 3-steps removal process would then be: 0. mv a/submodule a/submodule_tmp 1. git submodule deinit -f -- a/submodule 2. rm -rf .git/modules/a/submodule 3. git rm -f a/submodule # Note: a/submodule (no trailing slash) # or, if you want to leave it in your working tree and have done step 0 3. git rm --cached a/submodule 3bis mv a/submodule_tmp a/submodule Explanation rm -rf : This is mentioned in Daniel Schroeder 's answer , and summarized by Eonil in the comments : This leaves .git/modules/<path-to-submodule>/ unchanged. So if you once delete a submodule with this method and re-add them again, it will not be possible because repository already been corrupted. git rm : See commit 95c16418 : Currently using \" git rm \" on a submodule removes the submodule's work tree from that of the superproject and the gitlink from the index. But the submodule's section in .gitmodules is left untouched, which is a leftover of the now removed submodule and might irritate users (as opposed to the setting in .git/config , this must stay as a reminder that the user showed interest in this submodule so it will be repopulated later when an older commit is checked out). Let \" git rm \" help the user by not only removing the submodule from the work tree but by also removing the \" submodule.<submodule name> \" section from the .gitmodules file and stage both. git submodule deinit : It stems from this patch : With \" git submodule init \" the user is able to tell git they care about one or more submodules and wants to have it populated on the next call to \" git submodule update \". But currently there is no easy way they can tell git they do not care about a submodule anymore and wants to get rid of the local work tree (unless the user knows a lot about submodule internals and removes the \" submodule.$name.url \" setting from .git/config together with the work tree himself). Help those users by providing a ' deinit ' command. This removes the whole submodule.<name> section from .git/config either for the given submodule(s) (or for all those which have been initialized if ' . ' is given). Fail if the current work tree contains modifications unless forced. Complain when for a submodule given on the command line the url setting can't be found in .git/config , but nonetheless don't fail. This takes care if the (de)initialization steps ( .git/config and .git/modules/xxx ) Since git1.8.5, the git rm takes also care of the: ' add ' step which records the url of a submodule in the .gitmodules file: it is need to removed for you. the submodule special entry (as illustrated by this question ): the git rm removes it from the index: git rm --cached path_to_submodule (no trailing slash) That will remove that directory stored in the index with a special mode \"160000\", marking it as a submodule root directory. If you forget that last step, and try to add what was a submodule as a regular directory, you would get error message like: git add mysubmodule/file.txt Path 'mysubmodule/file.txt' is in submodule 'mysubmodule' Note: since Git 2.17 (Q2 2018), git submodule deinit is no longer a shell script. It is a call to a C function. See commit 2e61273 , commit 1342476 (14 Jan 2018) by Prathamesh Chavan ( pratham-pc ) . (Merged by Junio C Hamano -- gitster -- in commit ead8dbe , 13 Feb 2018) git ${wt_prefix:+-C \"$wt_prefix\"} submodule--helper deinit \\ ${GIT_QUIET:+--quiet} \\ ${prefix:+--prefix \"$prefix\"} \\ ${force:+--force} \\ ${deinit_all:+--all} \"$@\""
  },
  {
    "question": "What command checks if a directory exists or not within a Bash shell script?",
    "answer": "To check if a directory exists: if [ -d \"$DIRECTORY\" ]; then echo \"$DIRECTORY does exist.\" fi To check if a directory does not exist: if [ ! -d \"$DIRECTORY\" ]; then echo \"$DIRECTORY does not exist.\" fi However, as Jon Ericson points out, subsequent commands may not work as intended if you do not take into account that a symbolic link to a directory will also pass this check. E.g. running this: ln -s \"$ACTUAL_DIR\" \"$SYMLINK\" if [ -d \"$SYMLINK\" ]; then rmdir \"$SYMLINK\" fi Will produce the error message: rmdir: failed to remove `symlink': Not a directory So symbolic links may have to be treated differently, if subsequent commands expect directories: if [ -d \"$LINK_OR_DIR\" ]; then if [ -L \"$LINK_OR_DIR\" ]; then # It is a symlink! # Symbolic link specific commands go here. rm \"$LINK_OR_DIR\" else # It's a directory! # Directory command goes here. rmdir \"$LINK_OR_DIR\" fi fi Take particular note of the double-quotes used to wrap the variables. The reason for this is explained by 8jean in another answer . If the variables contain spaces or other unusual characters it will probably cause the script to fail."
  },
  {
    "question": "How do I delete a commit from my branch history? Should I use git reset --hard HEAD ?",
    "answer": "Careful: git reset --hard WILL DELETE YOUR WORKING DIRECTORY CHANGES . Be sure to stash any local changes you want to keep before running this command. Assuming you are sitting on that commit, then this command will wack it... git reset --hard HEAD~1 The HEAD~1 means the commit before head. Or, you could look at the output of git log , find the commit id of the commit you want to back up to, and then do this: git reset --hard <sha1-commit-id> If you already pushed it, you will need to do a force push to get rid of it... git push origin HEAD --force However , if others may have pulled it, then you would be better off starting a new branch. Because when they pull, it will just merge it into their work, and you will get it pushed back up again. If you already pushed, it may be better to use git revert , to create a \"mirror image\" commit that will undo the changes. However, both commits will be in the log. FYI: git reset --hard HEAD is great if you want to get rid of WORK IN PROGRESS.It will reset you back to the most recent commit, and erase all the changes in your working tree and index. git stash does the same except you can restore it later if you need , versus permanently delete with reset hard mode. Check your stashes by using git stash list and git stash show 'stash@123' Lastly, if you need to find a commit that you \"deleted\", it is typically present in git reflog unless you have garbage collected your repository."
  },
  {
    "question": "How do I easily undo a git rebase? A lengthy manual method is: checkout the commit parent to both of the branches create and checkout a temporary branch cherry-pick all commits by hand reset the faulty rebased branch to point to the temporary branch In my current situation, this works because I can easily spot commits from both branches (one was my stuff, the other was my colleague's stuff). However, my approach strikes me as suboptimal and error-prone (let's say I had just rebased with two of my own branches). Clarification: I am talking about a rebase during which multiple commits were replayed, not only one.",
    "answer": "The easiest way would be to find the head commit of the branch as it was immediately before the rebase started in the reflog ... git reflog and to reset the current branch to it. Suppose the old commit was HEAD@{2} in the ref log: git reset --soft \"HEAD@{2}\" (If you do not want to retain the working copy changes, you can use --hard instead of --soft ) You can check the history of the candidate old head by just doing a git log \"HEAD@{2}\" . If you've not disabled per branch reflogs you should be able to simply do git reflog \"branchname@{1}\" as a rebase detaches the branch head before reattaching to the final head. I would double-check this behavior, though, as I haven't verified it recently. Per default, all reflogs are activated for non-bare repositories: [core] logAllRefUpdates = true"
  },
  {
    "question": "How do I get the name of the current branch in Git?",
    "answer": "git branch should show all the local branches of your repo. The starred branch is your current branch. To retrieve only the name of the branch you are on: git rev-parse --abbrev-ref HEAD Version 2.22 adds the --show-current option to ”print the name of the current branch” . The combination also works for freshly initialized repositories before the first commit: git branch --show-current"
  },
  {
    "question": "Git clone will clone remote branch into local. Is there any way to clone a specific branch by myself without switching branches on the remote repository?",
    "answer": "git clone --single-branch --branch <branchname> <remote-repo> The --single-branch option is valid from version 1.7.10 and later. Please see also the other answer which many people prefer. You may also want to make sure you understand the difference. And the difference is: by invoking git clone --branch <branchname> url you're fetching all the branches and checking out one. That may, for instance, mean that your repository has a 5kB documentation or wiki branch and 5GB data branch. And whenever you want to edit your frontpage, you may end up cloning 5GB of data. Again, that is not to say git clone --branch is not the way to accomplish that, it's just that it's not always what you want to accomplish, when you're asking about cloning a specific branch."
  },
  {
    "question": "This checks if a file exists: #!/bin/bash FILE=$1 if [ -f $FILE ]; then echo \"File $FILE exists.\" else echo \"File $FILE does not exist.\" fi How do I only check if the file does not exist?",
    "answer": "The test command (written as [ here) has a \"not\" logical operator, ! (exclamation mark): if [ ! -f /tmp/foo.txt ]; then echo \"File not found!\" fi"
  },
  {
    "question": "How do I grep and show the preceding and following 5 lines surrounding each matched line?",
    "answer": "For BSD or GNU grep you can use -B num to set how many lines before the match and -A num for the number of lines after the match. grep -B 3 -A 2 foo README.txt If you want the same number of lines before and after you can use -C num . grep -C 3 foo README.txt This will show 3 lines before and 3 lines after."
  },
  {
    "question": "I know how to make a new branch that tracks remote branches, but how do I make an existing branch track a remote branch? I know I can just edit the .git/config file, but it seems there should be an easier way.",
    "answer": "Given a branch foo and a remote upstream : As of Git 1.8.0: git branch -u upstream/foo Or, if local branch foo is not the current branch: git branch -u upstream/foo foo Or, if you like to type longer commands, these are equivalent to the above two: git branch --set-upstream-to=upstream/foo git branch --set-upstream-to=upstream/foo foo As of Git 1.7.0 (before 1.8.0): git branch --set-upstream foo upstream/foo Notes: All of the above commands will cause local branch foo to track remote branch foo from remote upstream . The old (1.7.x) syntax is deprecated in favor of the new (1.8+) syntax. The new syntax is intended to be more intuitive and easier to remember. Defining an upstream branch will fail when run against newly-created remotes that have not already been fetched. In that case, run git fetch upstream beforehand. See also: Why do I need to do `--set-upstream` all the time?"
  },
  {
    "question": "I want to remove a file from my repository. git rm file_to_remove.txt will remove the file from the repository, but it will also remove the file from the local file system. How do I remove this file from the repo without deleting my local copy of the file?",
    "answer": "The git rm documentation states: When --cached is given, the staged content has to match either the tip of the branch or the file on disk, allowing the file to be removed from just the index. So, for a single file: git rm --cached file_to_remove.txt and for a single directory: git rm --cached -r directory_to_remove"
  },
  {
    "question": "I started some work on a new feature and after coding for a bit, I decided this feature should be on its own branch. How do I move the existing uncommitted changes to a new branch and reset my current one? I want to reset my current branch while preserving existing work on the new feature.",
    "answer": "Update 2020 / Git 2.23 Git 2.23 adds the new switch subcommand in an attempt to clear some of the confusion that comes from the overloaded usage of checkout (switching branches, restoring files, detaching HEAD, etc.) Starting with this version of Git, replace the checkout command with: git switch -c <new-branch> The behavior is identical and remains unchanged. Before Update 2020 / Git 2.23 Use the following: git checkout -b <new-branch> This will leave your current branch as it is, create and checkout a new branch and keep all your changes. You can then stage changes in files to commit with: git add <files> and commit to your new branch with: git commit -m \"<Brief description of this commit>\" The changes in the working directory and changes staged in index do not belong to any branch yet. This changes the branch where those modifications would end in. You don't reset your original branch, it stays as it is. The last commit on <old-branch> will still be the same. Therefore you checkout -b and then commit."
  },
  {
    "question": "How do I view the history of an individual file with complete details of what has changed? git log -- [filename] shows me the commit history of a file, but how do I see the file content that changed?",
    "answer": "For a graphical view, use gitk : gitk [filename] To follow the file across file renames: gitk --follow [filename]"
  },
  {
    "question": "How do I stash only one of the multiple changed files on my branch?",
    "answer": "git stash push -p -m \"my commit message\" -p let's you select the hunks that should be stashed; whole files can be selected as well. You'll be prompted with a few actions for each hunk: y - stash this hunk n - do not stash this hunk q - quit; do not stash this hunk or any of the remaining ones a - stash this hunk and all later hunks in the file d - do not stash this hunk or any of the later hunks in the file g - select a hunk to go to / - search for a hunk matching the given regex j - leave this hunk undecided, see next undecided hunk J - leave this hunk undecided, see next hunk k - leave this hunk undecided, see previous undecided hunk K - leave this hunk undecided, see previous hunk s - split the current hunk into smaller hunks e - manually edit the current hunk ? - print help"
  },
  {
    "question": "I created a local branch. How do I push it to the remote server? UPDATE: I have written a simpler answer for Git 2.0 here .",
    "answer": "Simple Git 2.0+ solution: As of Git 2.0, the behavior has become simpler : You can configure git with push.default = current to make life easier: I added this so now I can just push a new branch upstream with $ git push -u -u will track remote branch of the same name. Now with this configuration, you will auto-guess the remote reference to git push. From git.config documentation : push.default Defines the action git push should take if no refspec is explicitly given. push.default = current - push the current branch to update a branch with the same name on the receiving end. Works in both central and non-central workflows. For me, this is a good simplification of my day-to-day Git workflow. The configuration setting takes care of the 'usual' use case where you add a branch locally and want to create it remotely. Also, I can just as easily create local branches from remotes by just doing git co remote_branch_name (as opposed to using --set-upstream-to flag). I know this question and the accepted answers are rather old, but the behavior has changed so that now configuration options exist to make your workflow simpler. To add to your global Git configuration, run this on the command line: $ git config --global push.default current"
  },
  {
    "question": "When I make changes to a file in Git, how can I commit only some of the changes? For example, how could I commit only 15 lines out of 30 lines that have been changed in a file?",
    "answer": "You can use: git add --patch <filename> or for short: git add -p <filename> Git will break down your file into what it thinks are sensible \"hunks\" (portions of the file). It will then prompt you with this question: Stage this hunk [y,n,q,a,d,/,j,J,g,s,e,?]? Here is a description of each option: y stage this hunk for the next commit n do not stage this hunk for the next commit q quit; do not stage this hunk or any of the remaining hunks a stage this hunk and all later hunks in the file d do not stage this hunk or any of the later hunks in the file g select a hunk to go to / search for a hunk matching the given regex j leave this hunk undecided, see next undecided hunk J leave this hunk undecided, see next hunk k leave this hunk undecided, see previous undecided hunk K leave this hunk undecided, see previous hunk s split the current hunk into smaller hunks e manually edit the current hunk You can then edit the hunk manually by replacing + / - by # (thanks veksen ) ? print hunk help If the file is not in the repository yet, you can first do git add -N <filename> . Afterwards you can go on with git add -p <filename> . Afterwards, you can use: git diff --staged to check that you staged the correct changes git reset -p to unstage mistakenly added hunks git commit -v to view your commit while you edit the commit message. Note this is far different than the git format-patch command, whose purpose is to parse commit data into a .patch files. Reference for future: Git Tools - Interactive Staging"
  },
  {
    "question": "How can I print a plain list of all files that were part of a given commit? Although the following lists the files, it also includes unwanted diff information for each: git show a303aa90779efdd2f6b9d90693e2cbbbe4613c1d",
    "answer": "Preferred Way (because it's a plumbing command; meant to be programmatic): $ git diff-tree --no-commit-id --name-only bd61ad98 -r index.html javascript/application.js javascript/ie6.js Another Way (less preferred for scripts, because it's a porcelain command; meant to be user-facing) $ git show --pretty=\"\" --name-only bd61ad98 index.html javascript/application.js javascript/ie6.js The --no-commit-id suppresses the commit ID output. The --pretty argument specifies an empty format string to avoid the cruft at the beginning. The --name-only argument shows only the file names that were affected (Thanks Hank). Use --name-status instead, if you want to see what happened to each file ( D eleted, M odified, A dded) The -r argument is to recurse into sub-trees"
  },
  {
    "question": "How do I print a newline? This merely prints \\n : echo -e \"Hello,\\nWorld!\" Output: Hello,\\nWorld!",
    "answer": "Use printf instead: printf \"hello\\nworld\\n\" printf behaves more consistently across different environments than echo ."
  },
  {
    "question": "I have a string in Bash: string=\"My string\" How can I test if it contains another string? if [ $string ?? 'foo' ]; then echo \"It's there!\" fi Where ?? is my unknown operator. Do I use echo and grep ? if echo \"$string\" | grep 'foo'; then echo \"It's there!\" fi That looks a bit clumsy.",
    "answer": "You can use Marcus's answer (* wildcards) outside a case statement, too, if you use double brackets: string='My long string' if [[ $string == *\"My long\"* ]]; then echo \"It's there!\" fi Note that spaces in the needle string need to be placed between double quotes, and the * wildcards should be outside. Also note that a simple comparison operator is used (i.e. == ), not the regex operator =~ ."
  },
  {
    "question": "I added a tag to the master branch on my machine: git tag mytag master How do I push this to the remote repository? Running git push gives the message: Everything up-to-date However, the remote repository does not contain my tag.",
    "answer": "To push specific, one tag do following git push origin tag_name"
  },
  {
    "question": "In PHP, strings are concatenated together as follows: $foo = \"Hello\"; $foo .= \" World\"; Here, $foo becomes \"Hello World\" . How is this accomplished in Bash?",
    "answer": "foo=\"Hello\" foo=\"${foo} World\" echo \"${foo}\" > Hello World In general to concatenate two variables you can just write them one after another: a='Hello' b='World' c=\"${a} ${b}\" echo \"${c}\" > Hello World"
  },
  {
    "question": "I updated to the latest OS, and/or restarted my computer (this happens on every major update, but this time all I did was restart my computer on 2022-09-13). This morning I navigated to my work's codebase in the command line on my MacBook Pro , typed in \"git status\" in the repository and received an error: (In 9/2022, this error was much different, but I didn't capture it) xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun Git will not work! How do I fix Git, and the command-line tools?",
    "answer": "The problem is that Xcode Command-line Tools needs to be updated due to a MacOs update. Did not run into this on Sonoma. Maybe Apple fixed the process? Updated for Ventura After opening the terminal after restarting, I tried to go to my code, and do a git status , and I got an error and prompt for command line software agreement: So press space until you get to the [agree, print, cancel] option, so careful hit space to scroll down to the end, if you blow past It you have to run a command to get it back. Use sudo xcodebuild -license to get to it again. Just be careful on scrolling down and enter agree and press return and it will launch into an update. Then I tried to use git after the install, and it prompted me to install Xcode tools again. I followed my own advice from previous years (see below), and went to https://developer.apple.com/download/all and downloaded \"Command Line Tools for Xcode 14\" (You have to log in with your Apple ID and enter MFA code, so have all the devices you need for that handy. Then select \"Command Line Tools for Xcode 14\", or if you want to get into the alphas or betas, that's up to you. But stable releases are probably the best choice for software developers. You have to either download the tools from CLI or the developer page and before you can use git, you need to reboot!!! Or you will get stuck in a loop of prompt & downloading Rebooting will break the loop and complete the installation of your CLI tools including git so that you can get back to work Solutions for previous years, these may or may not be valid these days as the downloads page has changed significantly: PREVIOUS YEARS SOLUTIONS, probably #2 is most helpful. *** Solution #1 : Go back to your terminal and enter: xcode-select --install You'll then receive the following output: xcode-select: note: install requested for command line developer tools You will then be prompted in a window to update Xcode Command Line tools. (which could take a while) Open a new terminal window and your development tools should be returned. Addition: With any major or semi-major update you'll need to update the command line tools in order to get them functioning properly again. Check Xcode with any update. This goes beyond Mojave... After that restart your terminal Alternatively, IF that fails, and it might.... you'll get a pop-up box saying \"Software not found on server\", proceed to solution 2. *** Solution #2 : (Preferred method) If you hit xcode-select --install and it doesn't find the software, log into Apple Developer, and install it via webpage. Log in or sign up here: https://developer.apple.com/download/more/ Look for: \"Command Line Tools for Xcode 14.x\" in the list of downloads Then click the dmg and download. (See previous image above) either way, you will probably wind up at an apple downloads webpage."
  },
  {
    "question": "What is the difference between git add [--all | -A] and git add . ?",
    "answer": "This answer only applies to Git version 1.x . For Git version 2.x, see other answers. Summary: git add -A stages all changes git add . stages new files and modifications, without deletions (on the current directory and its subdirectories). git add -u stages modifications and deletions, without new files Detail: git add -A is equivalent to git add .; git add -u . The important point about git add . is that it looks at the working tree and adds all those paths to the staged changes if they are either changed or are new and not ignored, it does not stage any 'rm' actions. git add -u looks at all the already tracked files and stages the changes to those files if they are different or if they have been removed. It does not add any new files, it only stages changes to already tracked files. git add -A is a handy shortcut for doing both of those. You can test the differences out with something like this (note that for Git version 2.x your output for git add . git status will be different): git init echo Change me > change-me echo Delete me > delete-me git add change-me delete-me git commit -m initial echo OK >> change-me rm delete-me echo Add me > add-me git status # Changed but not updated: # modified: change-me # deleted: delete-me # Untracked files: # add-me git add . git status # Changes to be committed: # new file: add-me # modified: change-me # Changed but not updated: # deleted: delete-me git reset git add -u git status # Changes to be committed: # modified: change-me # deleted: delete-me # Untracked files: # add-me git reset git add -A git status # Changes to be committed: # new file: add-me # modified: change-me # deleted: delete-me"
  },
  {
    "question": "How do I globally configure git to use a particular editor (e.g. vim ) for commit messages?",
    "answer": "Setting the default editor for Git Pick one: Set core.editor in your Git config: git config --global core.editor \"vim\" Set the GIT_EDITOR environment variable: export GIT_EDITOR=vim Setting the default editor for all programs Set the standardized VISUAL and EDITOR environment variables*: export VISUAL=vim export EDITOR=\"$VISUAL\" NOTE: Setting both is not necessarily needed, but some programs may not use the more-correct VISUAL . See VISUAL vs. EDITOR . Fixing compatibility issues Some editors require a --wait flag, or they will open a blank page. For example: Sublime Text (if correctly set up ; or use the full path to the executable in place of subl ): export VISUAL=\"subl --wait\" VS Code (after adding the shell command ): export VISUAL=\"code --wait\""
  },
  {
    "question": "What does git cherry-pick <commit> do?",
    "answer": "Cherry-picking in Git means choosing a commit from one branch and applying it to another. This contrasts with other ways such as merge and rebase which normally apply many commits to another branch. It's also possible to cherry-pick multiple commits but merge is the preferred way over cherry-picking. Make sure you are on the branch you want to apply the commit to. git switch master Execute the following: git cherry-pick <commit-hash> N.B.: If you cherry-pick from a public branch, you should consider using git cherry-pick -x <commit-hash> This will generate a standardized commit message. This way, you (and your co-workers) can still keep track of the origin of the commit and may avoid merge conflicts in the future. If you have notes attached to the commit they do not follow the cherry-pick. To bring them over as well, You have to use: git notes copy <from> <to> Additional links: git official guide page git cherry-pick guide"
  },
  {
    "question": "I have the following commit history: HEAD HEAD~ HEAD~2 HEAD~3 git commit --amend modifies the current HEAD commit. But how do I modify HEAD~3 ?",
    "answer": "Use git rebase . For example, to modify commit bbc643cd , run: git rebase --interactive bbc643cd~ Please note the tilde ~ at the end of the command, because you need to reapply commits on top of the previous commit of bbc643cd (i.e. bbc643cd~ ). In the default editor, modify pick to edit in the line mentioning bbc643cd . Save the file and exit. git will interpret and automatically execute the commands in the file. You will find yourself in the previous situation in which you just had created commit bbc643cd . At this point, bbc643cd is your last commit and you can easily amend it . Make your changes and then commit them with the command: git commit --all --amend --no-edit After that, return back to the previous HEAD commit using: git rebase --continue WARNING : Note that this will change the SHA-1 of that commit as well as all children -- in other words, this rewrites the history from that point forward. You can break repos doing this if you push using the command git push --force ."
  },
  {
    "question": "I want to change the author of one specific commit in the history. It's not the latest commit. Related: How do I change the author and committer name/email for multiple commits?",
    "answer": "Interactive rebase off of a point earlier in the history than the commit you need to modify ( git rebase -i <earliercommit> ). In the list of commits being rebased, change the text from pick to edit next to the hash of the one you want to modify. Then when git prompts you to change the commit, use this: git commit --amend --author=\"Author Name <email@address.com>\" --no-edit For example, if your commit history is A-B-C-D-E-F with F as HEAD , and you want to change the author of C and D , then you would... Specify git rebase -i B ( here is an example of what you will see after executing the git rebase -i B command ) if you need to edit A , use git rebase -i --root Change the lines for both C and D from pick to edit Exit the editor (for vim, this would be pressing Esc and then typing :wq ). Once the rebase started, it would first pause at C You would git commit --amend --author=\"Author Name <email@address.com>\" Then git rebase --continue It would pause again at D Then you would git commit --amend --author=\"Author Name <email@address.com>\" again git rebase --continue The rebase would complete. Use git push -f to update your origin with the updated commits."
  },
  {
    "question": "Say I'm in a Git repository. I delete a file and commit that change. I continue working and make some more commits. Then, I discover that I need to restore that file after deleting it. I know I can checkout a file using git checkout <commit> -- filename.txt , but I don't know when that file was deleted. How do I find the commit that deleted a given filename? How do I restore that file back into my working copy?",
    "answer": "Find the last commit that affected the given path. As the file isn't in the HEAD commit, that previous commit must have deleted it. git rev-list -n 1 HEAD -- <file_path> Then checkout the version at the commit before, using the caret ( ^ ) symbol: git checkout <deleting_commit>^ -- <file_path> Or in one command, if $file is the file in question. git checkout $(git rev-list -n 1 HEAD -- \"$file\")^ -- \"$file\" If you are using zsh and have the EXTENDED_GLOB option enabled, the caret symbol won't work. You can use ~1 instead. git checkout $(git rev-list -n 1 HEAD -- \"$file\")~1 -- \"$file\""
  },
  {
    "question": "To combine stderr and stdout into the stdout stream, we append this to a command: 2>&1 For example, the following command shows the first few errors from compiling main.cpp : g++ main.cpp 2>&1 | head But what does 2>&1 mean?",
    "answer": "File descriptor 1 is the standard output ( stdout ). File descriptor 2 is the standard error ( stderr ). At first, 2>1 may look like a good way to redirect stderr to stdout . However, it will actually be interpreted as \"redirect stderr to a file named 1 \". & indicates that what follows and precedes is a file descriptor , and not a filename. Thus, we use 2>&1 . Consider >& to be a redirect merger operator."
  },
  {
    "question": "The remote repository contains various branches such as origin/daves_branch : $ git branch -r origin/HEAD -> origin/master origin/daves_branch origin/master How do I switch to daves_branch in the local repository so that it tracks origin/daves_branch ? I tried: $ git fetch origin daves_branch $ git checkout daves_branch",
    "answer": "Update: Using Git Switch All of the information written below was accurate, but a new command, git switch has been added that simplifies the effort. If daves_branch exists on the remote repository, but not on your local branch, you can simply type: git switch daves_branch Since you do not have the branch locally, this will automatically make switch look on the remote repo. It will then also automatically set up remote branch tracking. Note that if daves_branch doesn't exist locally you'll need to git fetch first before using switch . Original Post You need to create a local branch that tracks a remote branch. The following command will create a local branch named daves_branch , tracking the remote branch origin/daves_branch . When you push your changes the remote branch will be updated. For most recent versions of Git: git checkout --track origin/daves_branch --track is shorthand for git checkout -b [branch] [remotename]/[branch] where [remotename] is origin in this case and [branch] is twice the same, daves_branch in this case. For Git 1.5.6.5 you needed this: git checkout --track -b daves_branch origin/daves_branch For Git 1.7.2.3 and higher, this is enough (it might have started earlier, but this is the earliest confirmation I could find quickly): git checkout daves_branch Note that with recent Git versions, this command will not create a local branch and will put you in a 'detached HEAD' state. If you want a local branch, use the --track option. Full details are here: 3.5 Git Branching - Remote Branches, Tracking Branches"
  },
  {
    "question": "How would I validate that a program exists, in a way that will either return an error and exit, or continue with the script? It seems like it should be easy, but it's been stumping me.",
    "answer": "Answer POSIX compatible: command -v <the_command> Example use: if ! command -v <the_command> >/dev/null 2>&1 then echo \"<the_command> could not be found\" exit 1 fi For Bash specific environments: hash <the_command> # For regular commands. Or... type <the_command> # To check built-ins and keywords Explanation Avoid which . Not only is it an external process you're launching for doing very little (meaning builtins like hash , type or command are way cheaper), you can also rely on the builtins to actually do what you want, while the effects of external commands can easily vary from system to system. Why care? Many operating systems have a which that doesn't even set an exit status , meaning the if which foo won't even work there and will always report that foo exists, even if it doesn't (note that some POSIX shells appear to do this for hash too). Many operating systems make which do custom and evil stuff like change the output or even hook into the package manager. So, don't use which . Instead use one of these: command -v foo >/dev/null 2>&1 || { echo >&2 \"I require foo but it's not installed. Aborting.\"; exit 1; } type foo >/dev/null 2>&1 || { echo >&2 \"I require foo but it's not installed. Aborting.\"; exit 1; } hash foo 2>/dev/null || { echo >&2 \"I require foo but it's not installed. Aborting.\"; exit 1; } (Minor side-note: some will suggest 2>&- is the same 2>/dev/null but shorter – this is untrue . 2>&- closes FD 2 which causes an error in the program when it tries to write to stderr, which is very different from successfully writing to it and discarding the output (and dangerous!)) (Additional minor side-note: some will suggest &>/dev/null , but this is not POSIX compliant ) If your hash bang is /bin/sh then you should care about what POSIX says. type and hash 's exit codes aren't terribly well defined by POSIX, and hash is seen to exit successfully when the command doesn't exist (haven't seen this with type yet). command 's exit status is well defined by POSIX, so that one is probably the safest to use. If your script uses bash though, POSIX rules don't really matter anymore and both type and hash become perfectly safe to use. type now has a -P to search just the PATH and hash has the side-effect that the command's location will be hashed (for faster lookup next time you use it), which is usually a good thing since you probably check for its existence in order to actually use it. As a simple example, here's a function that runs gdate if it exists, otherwise date : gnudate() { if hash gdate 2>/dev/null; then gdate \"$@\" else date \"$@\" fi }"
  },
  {
    "question": "How do I change the author for a range of commits?",
    "answer": "This answer uses git-filter-branch , for which the docs now give this warning: git filter-branch has a plethora of pitfalls that can produce non-obvious manglings of the intended history rewrite (and can leave you with little time to investigate such problems since it has such abysmal performance). These safety and performance issues cannot be backward compatibly fixed and as such, its use is not recommended. Please use an alternative history filtering tool such as git filter-repo . If you still need to use git filter-branch, please carefully read SAFETY (and PERFORMANCE ) to learn about the land mines of filter-branch, and then vigilantly avoid as many of the hazards listed there as reasonably possible. Changing the author (or committer) would require rewriting all of the history. If you're okay with that and think it's worth it then you should check out git filter-branch . The manual page includes several examples to get you started. Also note that you can use environment variables to change the name of the author, committer, dates, etc. -- see the \"Environment Variables\" section of the git manual page . Specifically, you can fix all the wrong author names and emails for all branches and tags with this command (source: GitHub help ): #!/bin/sh git filter-branch --env-filter ' OLD_EMAIL=\"your-old-email@example.com\" CORRECT_NAME=\"Your Correct Name\" CORRECT_EMAIL=\"your-correct-email@example.com\" if [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ] then export GIT_COMMITTER_NAME=\"$CORRECT_NAME\" export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\" fi if [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ] then export GIT_AUTHOR_NAME=\"$CORRECT_NAME\" export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\" fi ' --tag-name-filter cat -- --branches --tags For using alternative history filtering tool git filter-repo , you can first install it and construct a git-mailmap according to the format of gitmailmap . Proper Name <proper@email.xx> Commit Name <commit@email.xx> And then run filter-repo with the created mailmap: git filter-repo --mailmap git-mailmap"
  },
  {
    "question": "The command git clone git@github.com:whatever creates a directory named whatever containing a Git repository: ./ whatever/ .git I want the contents of the Git repository cloned into my current directory ./ instead: ./ .git",
    "answer": "Option A: git clone git@github.com:whatever folder-name Ergo, for right here use: git clone git@github.com:whatever . Option B: Move the .git folder, too. Note that the .git folder is hidden in most graphical file explorers, so be sure to show hidden files. mv /where/it/is/right/now/* /where/I/want/it/ mv /where/it/is/right/now/.* /where/I/want/it/ The first line grabs all normal files, the second line grabs dot-files. It is also possibe to do it in one line by enabling dotglob (i.e. shopt -s dotglob ) but that is probably a bad solution if you are asking the question this answer answers. Better yet: Keep your working copy somewhere else, and create a symbolic link. Like this: ln -s /where/it/is/right/now /the/path/I/want/to/use For your case this would be something like: ln -sfn /opt/projectA/prod/public /httpdocs/public Which easily could be changed to test if you wanted it, i.e.: ln -sfn /opt/projectA/test/public /httpdocs/public without moving files around. Added -fn in case someone is copying these lines ( -f is force, -n avoid some often unwanted interactions with already and non-existing links). If you just want it to work, use Option A, if someone else is going to look at what you have done, use Option C."
  },
  {
    "question": "I have this string stored in a variable: IN=\"bla@some.com;john@home.com\" Now I would like to split the strings by ; delimiter so that I have: ADDR1=\"bla@some.com\" ADDR2=\"john@home.com\" I don't necessarily need the ADDR1 and ADDR2 variables. If they are elements of an array that's even better. After suggestions from the answers below, I ended up with the following which is what I was after: #!/usr/bin/env bash IN=\"bla@some.com;john@home.com\" mails=$(echo $IN | tr \";\" \"\\n\") for addr in $mails do echo \"> [$addr]\" done Output: > [bla@some.com] > [john@home.com] There was a solution involving setting Internal_field_separator (IFS) to ; . I am not sure what happened with that answer, how do you reset IFS back to default? RE: IFS solution, I tried this and it works, I keep the old IFS and then restore it: IN=\"bla@some.com;john@home.com\" OIFS=$IFS IFS=';' mails2=$IN for x in $mails2 do echo \"> [$x]\" done IFS=$OIFS BTW, when I tried mails2=($IN) I only got the first string when printing it in loop, without brackets around $IN it works.",
    "answer": "You can set the internal field separator (IFS) variable, and then let it parse into an array. When this happens in a command, then the assignment to IFS only takes place to that single command's environment (to read ). It then parses the input according to the IFS variable value into an array, which we can then iterate over. This example will parse one line of items separated by ; , pushing it into an array: IFS=';' read -ra ADDR <<< \"$IN\" for i in \"${ADDR[@]}\"; do # process \"$i\" done This other example is for processing the whole content of $IN , each time one line of input separated by ; : while IFS=';' read -ra ADDR; do for i in \"${ADDR[@]}\"; do # process \"$i\" done done <<< \"$IN\""
  },
  {
    "question": "I have a project in which I have to change the mode of files with chmod to 777 while developing, but which should not change in the main repo. Git picks up on chmod -R 777 . and marks all files as changed. Is there a way to make Git ignore mode changes that have been made to files?",
    "answer": "Try: git config core.fileMode false From git-config(1) : core.fileMode Tells Git if the executable bit of files in the working tree is to be honored. Some filesystems lose the executable bit when a file that is marked as executable is checked out, or checks out a non-executable file with executable bit on. git-clone(1) or git-init(1) probe the filesystem to see if it handles the executable bit correctly and this variable is automatically set as necessary. A repository, however, may be on a filesystem that handles the filemode correctly, and this variable is set to true when created, but later may be made accessible from another environment that loses the filemode (e.g. exporting ext4 via CIFS mount, visiting a Cygwin created repository with Git for Windows or Eclipse). In such a case it may be necessary to set this variable to false. See git-update-index(1). The default is true (when core.filemode is not specified in the config file). The -c flag can be used to set this option for one-off commands: git -c core.fileMode=false diff Typing the -c core.fileMode=false can be bothersome and so you can set this flag for all git repos or just for one git repo: # this will set your the flag for your user for all git repos (modifies `$HOME/.gitconfig`) # WARNING: this will be override by local config, fileMode value is automatically selected with latest version of git. # This mean that if git detect your current filesystem is compatible it will set local core.fileMode to true when you clone or init a repository. # Tool like cygwin emulation will be detected as compatible and so your local setting WILL BE SET to true no matter what you set in global setting. git config --global core.fileMode false # this will set the flag for one git repo (modifies `$current_git_repo/.git/config`) git config core.fileMode false Additionally, git clone and git init explicitly set core.fileMode to true in the repo config as discussed in Git global core.fileMode false overridden locally on clone Warning core.fileMode is not the best practice and should be used carefully. This setting only covers the executable bit of mode and never the read/write bits. In many cases you think you need this setting because you did something like chmod -R 777 , making all your files executable. But in most projects most files don't need and should not be executable for security reasons . The proper way to solve this kind of situation is to handle folder and file permission separately, with something like: find . -type d -exec chmod a+rwx {} \\; # Make folders traversable and read/write find . -type f -exec chmod a+rw {} \\; # Make files read/write If you do that, you'll never need to use core.fileMode , except in very rare environment."
  },
  {
    "question": "I want to get the filename (without extension) and the extension separately. The best solution I found so far is: NAME=`echo \"$FILE\" | cut -d'.' -f1` EXTENSION=`echo \"$FILE\" | cut -d'.' -f2` This is wrong because it doesn't work if the file name contains multiple . characters. If, let's say, I have a.b.js , it will consider a and b.js , instead of a.b and js . It can be easily done in Python with file, ext = os.path.splitext(path) but I'd prefer not to fire up a Python interpreter just for this, if possible. Any better ideas?",
    "answer": "First, get file name without the path: filename=$(basename -- \"$fullfile\") extension=\"${filename##*.}\" filename=\"${filename%.*}\" Alternatively, you can focus on the last '/' of the path instead of the '.' which should work even if you have unpredictable file extensions: filename=\"${fullfile##*/}\" You may want to check the documentation : On the web at section \" 3.5.3 Shell Parameter Expansion \" In the bash manpage at section called \"Parameter Expansion\""
  },
  {
    "question": "I have an already initialized Git repository that I added a .gitignore file to. How can I refresh the file index so the files I want ignored get ignored?",
    "answer": "To untrack a single file that has already been added/initialized to your repository, i.e. , stop tracking the file but not delete it from your system use: git rm --cached filename To untrack every file that is now in your .gitignore : First commit any outstanding code changes , and then, run this command: git rm -r --cached . This removes any changed files from the index (staging area), then just run: git add . Commit it: git commit -m \".gitignore is now working\" To undo git rm --cached filename , use git add filename . Make sure to commit all your important changes before running git add . Otherwise, you will lose any changes to other files. Please be careful, when you push this to a repository and pull from somewhere else into a state where those files are still tracked, the files will be DELETED To remove all files that do not match the paths listed in some path spec file (something that has the same format as a .gitignore file): git rm --cached --ignore-unmatch -r --pathspec-from-file .ignorelist Note: unlike .gitignore , which can have new lines, .ignorelist cannot have new lines because git will complain about empty patterns not being valid path spec items. Explanation: -r : to allow recursive removal when directories are involved --pathspec-from-file : path to file containing the path specifications for files to be removed --ignore-unmatch : tell git to ignore any path specifications that do not have a matching cache hit (otherwise it will abort with an error on that path spec)"
  },
  {
    "question": "How do I see what is inside a stash without actually applying it?",
    "answer": "From man git-stash (which can also be obtained via git help stash ): The modifications stashed away by this command can be listed with git stash list , inspected with git stash show , and ... show [<stash>] Show the changes recorded in the stash as a diff between the stashed state and its original parent. When no <stash> is given, shows the latest one. By default, the command shows the diffstat, but it will accept any format known to git diff (e.g., git stash show -p stash@{1} to view the second most recent stash in patch form). Note: the -p option generates a patch , as per git-diff documentation. List the stashes: git stash list Show the files in the most recent stash: git stash show Show the changes of the most recent stash: git stash show -p Show the changes of the named stash: git stash show -p stash@{1} Or in short: git stash show -p 1 If you want to view changes of only the last stash: git stash show -p 0"
  },
  {
    "question": "How do I get the hash of the current commit in Git?",
    "answer": "To turn any extended object reference into a hash, use git-rev-parse : git rev-parse HEAD or git rev-parse --verify HEAD As noted by Alexander's answer , you can also retrieve the short hash: git rev-parse --short HEAD To turn references (e.g. branches and tags ) into hashes, use git show-ref and git for-each-ref ."
  },
  {
    "question": "I want to use a push and pull automatically in Git Extensions , Sourcetree or any other Git GUI without entering my username and password in a prompt, every time. So how can I save my credentials in Git?",
    "answer": "Attention: This method saves the credentials in plaintext on your PC's disk. Everyone on your computer can access it, e.g. malicious NPM modules. Run : git config --global credential.helper store then : git pull provide a username and password and those details will then be remembered later. The credentials are stored in a file on the disk, with the disk permissions of \"just user readable/writable\" but still in plaintext. If you want to change the password later: git pull Will fail, because the password is incorrect, git then removes the offending user+password from the ~/.git-credentials file, so now re-run: git pull to provide a new password so it works as earlier."
  },
  {
    "question": "How do I clone a git repository so that it also clones its submodules? Running git clone $REPO_URL merely creates empty submodule directories.",
    "answer": "With version 2.13 of Git and later, --recurse-submodules can be used instead of --recursive : git clone --recurse-submodules -j8 git://github.com/foo/bar.git cd bar Editor’s note: -j8 is an optional performance optimization that became available in version 2.8, and fetches up to 8 submodules at a time in parallel — see man git-clone . With version 1.9 of Git up until version 2.12 ( -j flag only available in version 2.8+): git clone --recursive -j8 git://github.com/foo/bar.git cd bar With version 1.6.5 of Git and later, you can use: git clone --recursive git://github.com/foo/bar.git cd bar For already cloned repos, or older Git versions, use: git clone git://github.com/foo/bar.git cd bar git submodule update --init --recursive"
  },
  {
    "question": "I have a bunch of commits in the repository. I want to see a list of files changed between two commits - from SHA1 to SHA2 . What command should I use?",
    "answer": "git diff --name-only SHA1 SHA2 where you only need to include enough of the SHA hash to identify the commits. The order of the SHAs does not matter. The output (which includes the relative path, not just the file name) follows this format: dir 1/dir 2/filename.ext dir 3/dir 4/other filename.ext You can also do, for example git diff --name-only HEAD~10 HEAD~5 to see the differences between the tenth latest commit and the fifth latest (or so)."
  },
  {
    "question": "We're using git submodules to manage a couple of large projects that have dependencies on many other libraries we've developed. Each library is a separate repo brought into the dependent project as a submodule. During development, we often want to just go grab the latest version of every dependent submodule. How do I pull the latest changes for all git submodules?",
    "answer": "If it's the first time you check-out a repo you need to use --init first: git submodule update --init --recursive For git 1.8.2 or above, the option --remote was added to support updating to latest tips of remote branches: git submodule update --recursive --remote This has the added benefit of respecting any \"non default\" branches specified in the .gitmodules or .git/config files (if you happen to have any, default is origin/master, in which case some of the other answers here would work as well). For git 1.7.3 or above you can use (but the below gotchas around what update does still apply): git submodule update --recursive or: git pull --recurse-submodules if you want to pull your submodules to latest commits instead of the current commit the repo points to. See git-submodule(1) for details"
  },
  {
    "question": "How do I delete branches which have already been merged? Can I delete them all at once, instead of deleting each branch one-by-one?",
    "answer": "NOTE: You can add other branches to exclude like master and dev if your workflow has those as a possible ancestor. Usually I branch off of a \"sprint-start\" tag and master , dev and qa are not ancestors. First, list locally-tracking branches that were merged in remote (consider using -r flag to list all remote-tracking branches). git branch --merged You might see a few branches you don't want to remove. We can add arguments to skip important branches that we don't want to delete like master or a develop. The following command will skip the master / main branch and anything that has 'dev' in it. git branch --merged | grep -Ev \"(^\\*|^\\+|master|main|dev)\" The first part ( ^\\*|^+ ) excludes the current branch and any branch checked out in another worktree. If you want to skip a branch, you can add it to the grep command as below. The branch skip_branch_name will not be deleted. git branch --merged | grep -Ev \"(^\\*|^\\+|master|main|dev|skip_branch_name)\" To delete all local branches that are already merged into the currently checked out branch: git branch --merged | grep -Ev \"(^\\*|^\\+|master|main|dev)\" | xargs --no-run-if-empty git branch -d You can see that master and dev are excluded in case they are an ancestor. You can delete a merged local branch with: git branch -d branchname To force deletion of an unmerged branch, use: git branch -D branchname To delete it from the remote use: git push --delete origin branchname git push origin :branchname # for really old git Once you delete the branch from the remote, you can prune to get rid of remote tracking branches with: git remote prune origin or prune individual remote tracking branches, as the other answer suggests, with: git branch -dr branchname"
  },
  {
    "question": "I understand that a .gitignore file cloaks specified files from Git's version control. How do I tell .gitignore to ignore everything except the files I'm tracking with Git? Something like: # Ignore everything: * # Do not ignore these files: script.pl template.latex",
    "answer": "An optional prefix ! which negates the pattern; any matching file excluded by a previous pattern will become included again. If a negated pattern matches, this will override lower precedence patterns sources. # Ignore everything * # But not these files... !.gitignore !script.pl !template.latex # etc... # ...even if they are in subdirectories !*/"
  },
  {
    "question": "I ran git status which told me everything was up to date and there were no local changes. Then I made several consecutive changes and realized I wanted to throw everything away and get back to my original state. Will this command do it for me? git reset --hard HEAD",
    "answer": "To revert changes made to your working copy, do this: git checkout . Or equivalently, for git version >= 2.23: git restore . To revert changes made to the index (i.e., that you have added), do this. Warning this will reset all of your unpushed commits to master! : git reset To revert a change that you have committed: git revert <commit 1> <commit 2> To remove untracked files (e.g., new files, generated files): git clean -f Or untracked directories (e.g., new or automatically generated directories): git clean -fd"
  },
  {
    "question": "If I have an n number of commits, how can I create a branch from the n-3 commit?",
    "answer": "Create the branch using a commit hash: git branch branch_name <commit-hash> Or by using a symbolic reference: git branch branch_name HEAD~3 To checkout the branch while creating it, use: git checkout -b branch_name <commit-hash or HEAD~3>"
  },
  {
    "question": "A new branch from master is created, we call it test . There are several developers who either commit to master or create other branches and later merge into master . Let's say work on test is taking several days and you want to continuously keep test updated with commits inside master . I would do git pull origin master from test . Question 1: Is this the right approach? Other developers could have easily worked on same files as I have worked btw. My work on test is done and I am ready to merge it back to master . Here are the two ways I can think of: A: git checkout test git pull origin master git push origin test git checkout master git pull origin test B: git checkout test git pull origin master git checkout master git merge test I am not using --rebase because from my understanding, rebase will get the changes from master and stack mine on top of that hence it could overwrite changes other people made. Question 2: Which one of these two methods is right? What is the difference there? The goal in all of this is to keep my test branch updated with the things happening in master and later I could merge them back into master hoping to keep the timeline as linear as possible.",
    "answer": "How I would do this git checkout master git pull origin master git merge test git push origin master If I have a local branch from a remote one, I don't feel comfortable with merging other branches than this one with the remote. Also I would not push my changes, until I'm happy with what I want to push and also I wouldn't push things at all, that are only for me and my local repository. In your description it seems, that test is only for you? So no reason to publish it. git always tries to respect yours and others changes, and so will --rebase . I don't think I can explain it appropriately, so have a look at the Git book - Rebasing or git-ready: Intro into rebasing for a little description. It's a quite cool feature"
  },
  {
    "question": "What are the differences between .gitignore and .gitkeep ? Are they the same thing with a different name, or do they both serve a different function? I don't seem to be able to find much documentation on .gitkeep .",
    "answer": ".gitkeep isn’t documented, because it’s not a feature of Git. Git cannot add a completely empty directory . People who want to track empty directories in Git have created the convention of putting files called .gitkeep in these directories. The file could be called anything; Git assigns no special significance to this name. There is a competing convention of adding a .gitignore file to the empty directories to get them tracked, but some people see this as confusing since the goal is to keep the empty directories, not ignore them; .gitignore is also used to list files that should be ignored by Git when looking for untracked files."
  },
  {
    "question": "I staged a few changes to be committed. How do I see the diffs of all files which are staged for the next commit? Is there a handy one-liner for this? git status only shows names of files which are staged, but I want to see the actual diffs. The git-diff(1) man page says: git diff [--options] [--] […] This form is to view the changes you made relative to the index (staging area for the next commit). In other words, the differences are what you could tell git to further add to the index but you still haven't. You can stage these changes by using git-add(1).",
    "answer": "It should just be: git diff --cached --cached means show the changes in the cache/index (i.e. staged changes) against the current HEAD . --staged is a synonym for --cached . --staged and --cached does not point to HEAD , just difference with respect to HEAD . If you cherry pick what to commit using git add --patch (or git add -p ), --staged will return what is staged."
  },
  {
    "question": "I frequently use git stash and git stash pop to save and restore changes in my working tree. Yesterday, I had some changes in my working tree that I had stashed and popped, and then I made more changes to my working tree. I'd like to go back and review yesterday's stashed changes, but git stash pop appears to remove all references to the associated commit. I know that if I use git stash then .git/refs/stash contains the reference of the commit used to create the stash. And .git/logs/refs/stash contains the whole stash. But those references are gone after git stash pop . I know that the commit is still in my repository somewhere, but I don't know what it was. Is there an easy way to recover yesterday's stash commit reference?",
    "answer": "Once you know the hash of the stash commit you dropped, you can apply it as a stash: git stash apply $stash_hash Or, you can create a separate branch for it with git branch recovered $stash_hash After that, you can do whatever you want with all the normal tools. When you’re done, just blow the branch away. Finding the hash If you have only just popped it and the terminal is still open, you will still have the hash value printed by git stash pop on screen (thanks, Dolda). Otherwise, you can find this way in Linux, Unix or Git Bash for Windows: git fsck --no-reflog | awk '/dangling commit/ {print $NF}' … or in PowerShell for Windows: git fsck --no-reflog | select-string 'dangling commit' | foreach { $_.ToString().Split(\" \")[-1] } This will show you all the commits at the tips of your commit graph which are no longer referenced from any branch or tag – every lost commit, including every stash commit you’ve ever created, will be somewhere in that graph. The easiest way to find the stash commit you want is probably to pass that list straight to gitk : gitk --all $( git fsck --no-reflog | awk '/dangling commit/ {print $NF}' ) … or in PowerShell for Windows: gitk --all $( git fsck --no-reflog | select-string 'dangling commit' | foreach { $_.ToString().Split(\" \")[-1] } ) This will launch a repository browser showing you every single commit in the repository ever , regardless of whether it is reachable or not. You can replace gitk there with something like git log --graph --oneline --decorate if you prefer a nice graph on the console over a separate GUI app. To spot stash commits, look for commit messages of this form: WIP on somebranch : commithash Some old commit message Note : The commit message will only be in this form (starting with \"WIP on\") if you did not supply a message when you did git stash ."
  },
  {
    "question": "How can I delete \"file1.txt\" from my repository?",
    "answer": "Use git rm . If you want to remove the file from the Git repository and the filesystem , use: git rm file1.txt git commit -m \"remove file1.txt\" But if you want to remove the file only from the Git repository and not remove it from the filesystem, use: git rm --cached file1.txt git commit -m \"remove file1.txt\" And to push changes to remote repo git push origin branch_name"
  },
  {
    "question": "Say, I have a script that gets called with this line: ./myscript -vfd ./foo/bar/someFile -o /fizz/someOtherFile or this one: ./myscript -v -f -d -o /fizz/someOtherFile ./foo/bar/someFile What's the accepted way of parsing this such that in each case (or some combination of the two) $v , $f , and $d will all be set to true and $outFile will be equal to /fizz/someOtherFile ?",
    "answer": "Bash Space-Separated (e.g., --option argument ) cat >/tmp/demo-space-separated.sh <<'EOF' #!/bin/bash POSITIONAL_ARGS=() while [[ $# -gt 0 ]]; do case $1 in -e|--extension) EXTENSION=\"$2\" shift # past argument shift # past value ;; -s|--searchpath) SEARCHPATH=\"$2\" shift # past argument shift # past value ;; --default) DEFAULT=YES shift # past argument ;; -*|--*) echo \"Unknown option $1\" exit 1 ;; *) POSITIONAL_ARGS+=(\"$1\") # save positional arg shift # past argument ;; esac done set -- \"${POSITIONAL_ARGS[@]}\" # restore positional parameters echo \"FILE EXTENSION = ${EXTENSION}\" echo \"SEARCH PATH = ${SEARCHPATH}\" echo \"DEFAULT = ${DEFAULT}\" echo \"Number files in SEARCH PATH with EXTENSION:\" $(ls -1 \"${SEARCHPATH}\"/*.\"${EXTENSION}\" | wc -l) if [[ -n $1 ]]; then echo \"Last line of file specified as non-opt/last argument:\" tail -1 \"$1\" fi EOF chmod +x /tmp/demo-space-separated.sh /tmp/demo-space-separated.sh -e conf -s /etc /etc/hosts Output from copy-pasting the block above FILE EXTENSION = conf SEARCH PATH = /etc DEFAULT = Number files in SEARCH PATH with EXTENSION: 14 Last line of file specified as non-opt/last argument: #93.184.216.34 example.com Usage demo-space-separated.sh -e conf -s /etc /etc/hosts Bash Equals-Separated (e.g., --option=argument ) cat >/tmp/demo-equals-separated.sh <<'EOF' #!/bin/bash for i in \"$@\"; do case $i in -e=*|--extension=*) EXTENSION=\"${i#*=}\" shift # past argument=value ;; -s=*|--searchpath=*) SEARCHPATH=\"${i#*=}\" shift # past argument=value ;; --default) DEFAULT=YES shift # past argument with no value ;; -*|--*) echo \"Unknown option $i\" exit 1 ;; *) ;; esac done echo \"FILE EXTENSION = ${EXTENSION}\" echo \"SEARCH PATH = ${SEARCHPATH}\" echo \"DEFAULT = ${DEFAULT}\" echo \"Number files in SEARCH PATH with EXTENSION:\" $(ls -1 \"${SEARCHPATH}\"/*.\"${EXTENSION}\" | wc -l) if [[ -n $1 ]]; then echo \"Last line of file specified as non-opt/last argument:\" tail -1 $1 fi EOF chmod +x /tmp/demo-equals-separated.sh /tmp/demo-equals-separated.sh -e=conf -s=/etc /etc/hosts Output from copy-pasting the block above FILE EXTENSION = conf SEARCH PATH = /etc DEFAULT = Number files in SEARCH PATH with EXTENSION: 14 Last line of file specified as non-opt/last argument: #93.184.216.34 example.com Usage demo-equals-separated.sh -e=conf -s=/etc /etc/hosts To better understand ${i#*=} search for \"Substring Removal\" in this guide . It is functionally equivalent to `sed 's/[^=]*=//' <<< \"$i\"` which calls a needless subprocess or `echo \"$i\" | sed 's/[^=]*=//'` which calls two needless subprocesses. Using bash with getopt[s] getopt(1) limitations (older, relatively-recent getopt versions): can't handle arguments that are empty strings can't handle arguments with embedded whitespace More recent getopt versions don't have these limitations. For more information, see these docs . POSIX getopts Additionally, the POSIX shell and others offer getopts which doen't have these limitations. I've included a simplistic getopts example. cat >/tmp/demo-getopts.sh <<'EOF' #!/bin/sh # A POSIX variable OPTIND=1 # Reset in case getopts has been used previously in the shell. # Initialize our own variables: output_file=\"\" verbose=0 while getopts \"h?vf:\" opt; do case \"$opt\" in h|\\?) show_help exit 0 ;; v) verbose=1 ;; f) output_file=$OPTARG ;; esac done shift $((OPTIND-1)) [ \"${1:-}\" = \"--\" ] && shift echo \"verbose=$verbose, output_file='$output_file', Leftovers: $@\" EOF chmod +x /tmp/demo-getopts.sh /tmp/demo-getopts.sh -vf /etc/hosts foo bar Output from copy-pasting the block above verbose=1, output_file='/etc/hosts', Leftovers: foo bar Usage demo-getopts.sh -vf /etc/hosts foo bar The advantages of getopts are: It's more portable, and will work in other shells like dash . It can handle multiple single options like -vf filename in the typical Unix way, automatically. The disadvantage of getopts is that it can only handle short options ( -h , not --help ) without additional code. There is a getopts tutorial which explains what all of the syntax and variables mean. In bash, there is also help getopts , which might be informative."
  },
  {
    "question": "I've been wondering whether there is a good \"git export\" solution that creates a copy of a tree without the .git repository directory. There are at least three methods I know of: git clone followed by removing the .git repository directory. git checkout-index alludes to this functionality but starts with \"Just read the desired tree into the index...\" which I'm not entirely sure how to do. git-export is a third-party script that essentially does a git clone into a temporary location followed by rsync --exclude='.git' into the final destination. None of these solutions really strike me as being satisfactory. The closest one to svn export might be option 1, because both require the target directory to be empty first. But option 2 seems even better, assuming I can figure out what it means to read a tree into the index.",
    "answer": "Probably the simplest way to achieve this is with git archive . If you really need just the expanded tree you can do something like this. git archive master | tar -x -C /somewhere/else Most of the time that I need to 'export' something from git, I want a compressed archive in any case so I do something like this. git archive master | bzip2 >source-tree.tar.bz2 ZIP archive: git archive --format zip --output /full/path/to/zipfile.zip master git help archive for more details, it's quite flexible. Be aware that even though the archive will not contain the .git directory, it will, however, contain other hidden git-specific files like .gitignore, .gitattributes, etc. If you don't want them in the archive, make sure you use the export-ignore attribute in a .gitattributes file and commit this before doing your archive. Read more... Note: If you are interested in exporting the index, the command is git checkout-index -a -f --prefix=/destination/path/ (See Greg's answer for more details) Here's a real-world example using libchrony on Linux: mkdir $HOME/dev cd $HOME/dev pushd /tmp git clone https://gitlab.com/chrony/libchrony.git cd libchrony BRANCH=$(git rev-parse --abbrev-ref HEAD) git archive -o ../libchrony.zip --prefix=\"libchrony/\" $BRANCH popd unzip /tmp/libchrony.zip Those commands produce a zip file and extract it into $HOME/dev/libchrony . We can peek into the archive using: $ unzip -v /tmp/libchrony Archive: /tmp/libchrony.zip e0a3807f770b56f6b0e9833254baa7c4fc13564b Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 0 Stored 0 0% 2023-07-20 09:37 00000000 libchrony/ 49 Defl:N 47 4% 2023-07-20 09:37 37c3f2e2 libchrony/.gitignore 26530 Defl:N 9350 65% 2023-07-20 09:37 5622583e libchrony/COPYING 961 Defl:N 467 51% 2023-07-20 09:37 da9221e3 libchrony/Makefile 475 Defl:N 304 36% 2023-07-20 09:37 cae27f70 libchrony/README.adoc 3313 Defl:N 1119 66% 2023-07-20 09:37 37eb110f libchrony/chrony.h 7673 Defl:N 2261 71% 2023-07-20 09:37 5d455a52 libchrony/client.c 6190 Defl:N 2093 66% 2023-07-20 09:37 7ea9d81b libchrony/example-reports.c 16348 Defl:N 3855 76% 2023-07-20 09:37 e82f5fe3 libchrony/message.c 2946 Defl:N 1099 63% 2023-07-20 09:37 945ee82b libchrony/message.h -------- ------- --- ------- 64485 20595 68% 10 files"
  },
  {
    "question": "How can I stash a specific file leaving the others currently modified out of the stash I am about to save? For example, if git status gives me this: younker % git status # On branch master # Your branch is ahead of 'origin/master' by 1 commit. # # Changes not staged for commit: # (use \"git add <file>...\" to update what will be committed) # (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified: app/controllers/cart_controller.php # modified: app/views/cart/welcome.thtml # no changes added to commit (use \"git add\" and/or \"git commit -a\") and I only want to stash app/views/cart/welcome.thtml, how would I do that? Something like (but of course this does not work): git stash save welcome_cart app/views/cart/welcome.thtml",
    "answer": "Since git 2.13, there is a command to save a specific path to the stash: git stash push <path> . For example: git stash push -m welcome_cart app/views/cart/welcome.thtml With earlier versions: You can do that using git stash --patch (or git stash -p ) -- you'll enter interactive mode where you'll be presented with each hunk that was changed. Use n to skip the files that you don't want to stash, y when you encounter the one that you want to stash, and q to quit and leave the remaining hunks unstashed. a will stash the shown hunk and the rest of the hunks in that file. Not the most user-friendly approach, but it gets the work done if you really need it."
  },
  {
    "question": "npm 5 was released today and one of the new features include deterministic installs with the creation of a package-lock.json file. Is this file supposed to be kept in source control? I'm assuming it's similar to yarn.lock and composer.lock , both of which are supposed to be kept in source control.",
    "answer": "Yes, package-lock.json is intended to be checked into source control. If you're using npm 5+, you may see this notice on the command line: created a lockfile as package-lock.json. You should commit this file. According to npm help package-lock.json : package-lock.json is automatically generated for any operations where npm modifies either the node_modules tree, or package.json . It describes the exact tree that was generated, such that subsequent installs are able to generate identical trees, regardless of intermediate dependency updates. This file is intended to be committed into source repositories , and serves various purposes: Describe a single representation of a dependency tree such that teammates, deployments, and continuous integration are guaranteed to install exactly the same dependencies. Provide a facility for users to \"time-travel\" to previous states of node_modules without having to commit the directory itself. To facilitate greater visibility of tree changes through readable source control diffs. And optimize the installation process by allowing npm to skip repeated metadata resolutions for previously-installed packages. One key detail about package-lock.json is that it cannot be published, and it will be ignored if found in any place other than the toplevel package. It shares a format with npm-shrinkwrap.json, which is essentially the same file, but allows publication. This is not recommended unless deploying a CLI tool or otherwise using the publication process for producing production packages. If both package-lock.json and npm-shrinkwrap.json are present in the root of a package, package-lock.json will be completely ignored."
  },
  {
    "question": "I have a pretty simple script that is something like the following: #!/bin/bash VAR1=\"$1\" MOREF='sudo run command against $VAR1 | grep name | cut -c7-' echo $MOREF When I run this script from the command line and pass it the arguments, I am not getting any output. However, when I run the commands contained within the $MOREF variable, I am able to get output. How can one take the results of a command that needs to be run within a script, save it to a variable, and then output that variable on the screen?",
    "answer": "In addition to backticks `command` , command substitution can be done with $(command) or \"$(command)\" , which I find easier to read, and allows for nesting. OUTPUT=\"$(ls -1)\" echo \"${OUTPUT}\" MULTILINE=\"$(ls \\ -1)\" echo \"${MULTILINE}\" Quoting ( \" ) does matter to preserve multi-line variable values and it is safer to use with whitespace and special characters such as ( * ) and therefore advised; it is, however, optional on the right-hand side of an assignment when word splitting is not performed , so OUTPUT=$(ls -1) would work fine."
  },
  {
    "question": "How do I know if a variable is set in Bash? For example, how do I check if the user gave the first parameter to a function? function a { # if $1 is set ? }",
    "answer": "(Usually) The right way if [ -z ${var+x} ]; then echo \"var is unset\"; else echo \"var is set to '$var'\"; fi where ${var+x} is a parameter expansion which evaluates to nothing if var is unset, and substitutes the string x otherwise. Quotes Digression Quotes can be omitted (so we can say ${var+x} instead of \"${var+x}\" ) because this syntax & usage guarantees this will only expand to something that does not require quotes (since it either expands to x (which contains no word breaks so it needs no quotes), or to nothing (which results in [ -z ] , which conveniently evaluates to the same value (true) that [ -z \"\" ] does as well)). However, while quotes can be safely omitted, and it was not immediately obvious to all (it wasn't even apparent to the first author of this quotes explanation who is also a major Bash coder), it would sometimes be better to write the solution with quotes as [ -z \"${var+x}\" ] , at the very small possible cost of an O(1) speed penalty. The first author also added this as a comment next to the code using this solution giving the URL to this answer, which now also includes the explanation for why the quotes can be safely omitted. (Often) The wrong way if [ -z \"$var\" ]; then echo \"var is blank\"; else echo \"var is set to '$var'\"; fi This is often wrong because it doesn't distinguish between a variable that is unset and a variable that is set to the empty string. That is to say, if var='' , then the above solution will output \"var is blank\". The distinction between unset and \"set to the empty string\" is essential in situations where the user has to specify an extension, or additional list of properties, and that not specifying them defaults to a non-empty value, whereas specifying the empty string should make the script use an empty extension or list of additional properties. The distinction may not be essential in every scenario though. In those cases [ -z \"$var\" ] will be just fine."
  },
  {
    "question": "I have changes to a file, plus a new file, and would like to use git stash to put them away while I switch to another task. But git stash by itself stashes only the changes to the existing file; the new file remains in my working tree, cluttering up my future work. How do I stash this untracked file?",
    "answer": "To stash your working directory including untracked files (especially those that are in the .gitignore ) then you probably want to use this cmd: git stash --include-untracked Alternatively, you can use the shorthand -u instead of --include-untracked , or simply git stash --all (see warning below for this one) which stashes all files, including untracked and ignored files. This behaviour changed in 2018, so make sure your git is up to date. Warning: there seems to be (or have been) situations in which contents of ignored directories could be deleted permanently. See this archived website for more information ."
  },
  {
    "question": "Due to some bad cherry-picking, my local Git repository is currently five commits ahead of the origin, and not in a good state. I want to get rid of all these commits and start over again. Obviously, deleting my working directory and re-cloning would do it, but downloading everything from GitHub again seems like overkill, and not a good use of my time. Maybe git revert is what I need, but I don't want to end up 10 commits ahead of the origin (or even six), even if it does get the code itself back to the right state. I just want to pretend the last half-hour never happened. Is there a simple command that will do this? It seems like an obvious use case, but I'm not finding any examples of it. Note that this question is specifically about commits , not about: untracked files unstaged changes staged, but uncommitted changes",
    "answer": "If your excess commits are only visible to you, you can just do git reset --hard origin/<branch_name> to move back to where the origin is. This will reset the state of the repository to the previous commit, and it will discard all local changes. Doing a git revert makes new commits to remove old commits in a way that keeps everyone's history sane."
  },
  {
    "question": "I cloned a Git repository containing many branches. However, git branch only shows one: $ git branch * master How would I pull all the branches locally so when I do git branch , it shows the following? $ git branch * master * staging * etc...",
    "answer": "TL;DR answer git branch -r \\ | grep -v '\\->' \\ | sed \"s,\\x1B\\[[0-9;]*[a-zA-Z],,g\" \\ | while read remote; do \\ git branch --track \"${remote#origin/}\" \"$remote\"; \\ done git fetch --all git pull --all ( grep -v matches the inverse of given string; sed removes control sequences: \\x1B matches esc ) (It seems that pull fetches all branches from all remotes, but I always fetch first just to be sure.) Run the first command only if there are remote branches on the server that aren't tracked by your local branches. Complete answer You can fetch all branches from all remotes like this: git fetch --all It's basically a power move . fetch updates local copies of remote branches so this is always safe for your local branches BUT : fetch will not update local branches (which track remote branches); if you want to update your local branches you still need to pull every branch. fetch will not create local branches (which track remote branches), you have to do this manually. If you want to list all remote branches: git branch -a To update local branches which track remote branches: git pull --all However, this can be still insufficient. It will work only for your local branches which track remote branches. To track all remote branches execute this oneliner BEFORE git pull --all : git branch -r | grep -v '\\->' | sed \"s,\\x1B\\[[0-9;]*[a-zA-Z],,g\" | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\"; done P.S. AFAIK git fetch --all and git remote update are equivalent. Kamil Szot's comment , which folks have found useful. I had to use: for remote in `git branch -r`; do git branch --track ${remote#origin/} $remote; done because your code created local branches named origin/branchname and I was getting \"refname 'origin/branchname' is ambiguous whenever I referred to it."
  },
  {
    "question": "When I do git diff COMMIT I see the changes between that commit and HEAD (as far as I know), but I would like to see the changes that were made by that single commit. I haven't found any obvious options on diff / log that will give me that output.",
    "answer": "To see the diff for a particular COMMIT hash, where COMMIT is the hash of the commit: git diff COMMIT~ COMMIT will show you the difference between that COMMIT 's ancestor and the COMMIT . See the man pages for git diff for details about the command and gitrevisions about the ~ notation and its friends. Alternatively, git show COMMIT will do something very similar. (The commit's data, including its diff - but not for merge commits.) See the git show manpage . (also git diff COMMIT will show you the difference between that COMMIT and the head.)"
  },
  {
    "question": "I want to write a script that loops through 15 strings (array possibly?) Is that possible? Something like: for databaseName in listOfNames then # Do something end",
    "answer": "You can use it like this: ## declare an array variable declare -a arr=(\"element1\" \"element2\" \"element3\") ## now loop through the above array for i in \"${arr[@]}\" do echo \"$i\" # or do whatever with individual element of the array done # You can access them using echo \"${arr[0]}\", \"${arr[1]}\" also Also works for multi-line array declaration declare -a arr=(\"element1\" \"element2\" \"element3\" \"element4\" )"
  },
  {
    "question": "I want to merge two branches that have been separated for a while and wanted to know which files have been modified. Came across this link: http://linux.yyz.us/git-howto.html (moved to web.archive.org) which was quite useful. The tools to compare branches I've come across are: git diff master..branch git log master..branch git shortlog master..branch Was wondering if there's something like \"git status master..branch\" to only see those files that are different between the two branches. Without creating a new tool, I think this is the closest you can get to do that now (which of course will show repeats if a file was modified more than once): git diff master..branch | grep \"^diff\" Was wondering if there's something I missed...",
    "answer": "To compare the current branch against main branch: $ git diff --name-status main To compare any two branches: $ git diff --name-status firstbranch..yourBranchName There are more options to git diff in the official documentation (and specifically the --name-status option)."
  },
  {
    "question": "How do I remove a file from the latest commit?",
    "answer": "I think other answers here are wrong, because this is a question of moving the mistakenly committed files back to the staging area from the previous commit, without cancelling the changes done to them. This can be done like Paritosh Singh suggested: git reset --soft HEAD^ or git reset --soft HEAD~1 Then reset the unwanted files in order to leave them out from the commit (the old way): git reset HEAD path/to/unwanted_file Note, that since Git 2.23.0 one can ( the new way ): git restore --staged path/to/unwanted_file Now commit again, you can even re-use the same commit message: git commit -c ORIG_HEAD EDIT : The easiest way to do this is to use e.g. git gui . Just select Commit => Amend Last Commit and simply uncheck the desired file from the commit and click Commit ."
  },
  {
    "question": "How can I view any local commits I've made, that haven't yet been pushed to the remote repository? Occasionally, git status will print out that my branch is X commits ahead of origin/master , but not always. Is this a bug with my install of Git, or am I missing something?",
    "answer": "This gives a log of all commits between origin/master and HEAD: git log origin/master..HEAD When HEAD is on the master branch, this gives a log of unpushed commits. Similarly, to view the diff: git diff origin/master..HEAD"
  },
  {
    "question": "Is there a simple way to delete all tracking branches whose remote equivalent no longer exists? Example: Branches (local and remote) master origin/master origin/bug-fix-a origin/bug-fix-b origin/bug-fix-c Locally, I only have a master branch. Now I need to work on bug-fix-a , so I check it out, work on it, and push changes to the remote. Next I do the same with bug-fix-b . Branches (local and remote) master bug-fix-a bug-fix-b origin/master origin/bug-fix-a origin/bug-fix-b origin/bug-fix-c Now I have local branches master , bug-fix-a , bug-fix-b . The Master branch maintainer will merge my changes into master and delete all branches he has already merged. So the current state is now: Branches (local and remote) master bug-fix-a bug-fix-b origin/master origin/bug-fix-c Now I would like to call some command to delete branches (in this case bug-fix-a , bug-fix-b ), which are no longer represented in the remote repository. It would be something like the existing command git remote prune origin , but more like git local prune origin .",
    "answer": "git remote prune origin prunes tracking branches not on the remote. git branch --merged lists branches that have been merged into the current branch. xargs git branch -d deletes branches listed on standard input. Be careful deleting branches listed by git branch --merged . The list could include master or other branches you'd prefer not to delete. To give yourself the opportunity to edit the list before deleting branches, you could do the following in one line: git branch --merged >/tmp/merged-branches && \\ vi /tmp/merged-branches && xargs git branch -d </tmp/merged-branches"
  },
  {
    "question": "Consider the following scenario: I have developed a small experimental project A in its own Git repo. It has now matured, and I'd like A to be part of larger project B, which has its own big repository. I'd now like to add A as a subdirectory of B. How do I merge A into B, without losing history on any side?",
    "answer": "A single branch of another repository can be easily placed under a subdirectory retaining its history. For example: git subtree add --prefix=rails git://github.com/rails/rails.git master This will appear as a single commit where all files of Rails master branch are added into \"rails\" directory. However the commit's title contains a reference to the old history tree: Add 'rails/' from commit <rev> Where <rev> is a SHA-1 commit hash. You can still see the history, blame some changes. git log <rev> git blame <rev> -- README.md Note that you can't see the directory prefix from here since this is an actual old branch left intact. You should treat this like a usual file move commit: you will need an extra jump when reaching it. # finishes with all files added at once commit git log rails/README.md # then continue from original tree git log <rev> -- README.md There are more complex solutions like doing this manually or rewriting the history as described in other answers. The git-subtree command is a part of official git-contrib, some packet managers install it by default (OS X Homebrew). But you might have to install it by yourself in addition to git."
  },
  {
    "question": "I have a script that works fine in one branch and is broken in another. I want to look at the two versions side-by-side and see what's different. Is there a way to do this? To be clear I'm not looking for a compare tool (I use Beyond Compare ). I'm looking for a Git diff command that will allow me to compare the master version to my current branch version to see what has changed. I'm not in the middle of a merge or anything. I just want to say something like git diff mybranch/myfile.cs master/myfile.cs",
    "answer": "git diff can show you the difference between two commits: git diff mybranch master -- myfile.cs Or, equivalently: git diff mybranch..master -- myfile.cs Note you must specify the relative path to the file. So if the file were in the src directory, you'd say src/myfile.cs instead of myfile.cs . Using the latter syntax, if either side is HEAD it may be omitted (e.g., master.. compares master to HEAD ). You may also be interested in mybranch...master (from git diff documentation ): This form is to view the changes on the branch containing and up to the second <commit> , starting at a common ancestor of both <commit> . git diff A...B is equivalent to git diff $(git-merge-base A B) B . In other words, this will give a diff of changes in master since it diverged from mybranch (but without new changes since then in mybranch ). In all cases, the -- separator before the file name indicates the end of command line flags (mind the space between the separator and the filename). This is optional unless Git will get confused if the argument refers to a commit or a file, but including it is not a bad habit to get into. See Dietrich Epp's answer to Meaning of Git checkout double dashes for a few examples. The same arguments can be passed to git difftool if you have one configured."
  },
  {
    "question": "How do I iterate over a range of numbers in Bash when the range is given by a variable? I know I can do this (called \"sequence expression\" in the Bash documentation ): for i in {1..5}; do echo $i; done Which gives: 1 2 3 4 5 Yet, how can I replace either of the range endpoints with a variable? This doesn't work: END=5 for i in {1..$END}; do echo $i; done Which prints: {1..5}",
    "answer": "for i in $(seq 1 $END); do echo $i; done edit: I prefer seq over the other methods because I can actually remember it ;)"
  },
  {
    "question": "If I make changes to .bashrc , how do I reload it without logging out and back in?",
    "answer": "You can enter the long form command: source ~/.bashrc or you can use the shorter version of the command: . ~/.bashrc"
  },
  {
    "question": "How do I recursively grep all directories and subdirectories? find . | xargs grep \"texthere\" *",
    "answer": "grep -r \"texthere\" . The first parameter represents the regular expression to search for, while the second one represents the directory that should be searched. In this case, . means the current directory. Note: This works for GNU grep, and on some platforms like Solaris you must specifically use GNU grep as opposed to legacy implementation. For Solaris this is the ggrep command."
  },
  {
    "question": "How can I delete all of my Git stashes at once? Specifically I mean, with typing in one command.",
    "answer": "The following command deletes all your stashes: git stash clear From the git documentation : clear Remove all the stashed states. IMPORTANT WARNING: Those states will then be subject to pruning, and may be impossible to recover (...)."
  },
  {
    "question": "In one of my development branches, I made some changes to my codebase. Before I was able to complete the features I was working on, I had to switch my current branch to master to demo some features. But just using a \"git checkout master\" preserved the changes I also made in my development branch, thus breaking some of the functionality in master. So what I did was commit the changes on my development branch with a commit message \"temporary commit\" and then checkout master for the demo. Now that I'm done with the demo and back to work on my development branch, I would like to remove the \"temporary commit\" that I made while still preserving the changes I made. Is that possible?",
    "answer": "It's as simple as this: git reset HEAD^ Note: some shells treat ^ as a special character (for example some Windows shells or ZSH with globbing enabled ), so you may have to quote \"HEAD^\" or use HEAD~1 in those cases. git reset without a --hard or --soft moves your HEAD to point to the specified commit, without changing any files. HEAD^ refers to the (first) parent commit of your current commit, which in your case is the commit before the temporary one. Note that another option is to carry on as normal, and then at the next commit point instead run: git commit --amend [-m … etc] which will instead edit the most recent commit, having the same effect as above. Note that this (as with nearly every git answer) can cause problems if you've already pushed the bad commit to a place where someone else may have pulled it from. Try to avoid that"
  },
  {
    "question": "I was doing some work in my repository and noticed a file had local changes. I didn't want them anymore so I deleted the file, thinking I can just checkout a fresh copy. I wanted to do the Git equivalent of svn up . Using git pull didn't seem to work. Some random searching led me to a site where someone recommended doing git checkout HEAD^ src/ ( src is the directory containing the deleted file). Now I find out I have a detached head. I have no idea what that is. How can I undo?",
    "answer": "Detached head means you are no longer on a branch, you have checked out a single commit in the history (in this case the commit previous to HEAD, i.e. HEAD^). If you want to keep your changes associated with the detached HEAD Run git branch tmp - this will save your changes in a new branch called tmp . Run git checkout master If you would like to incorporate the changes you made into master , run git merge tmp from the master branch. You should be on the master branch after running git checkout master . If you want to delete your changes associated with the detached HEAD You only need to checkout the branch you were on, e.g. git checkout master Next time you have changed a file and want to restore it to the state it is in the index, don't delete the file first, just do git checkout -- path/to/foo This will restore the file foo to the state it is in the index."
  },
  {
    "question": "How do I iterate through each line of a text file with Bash ? With this script: echo \"Start!\" for p in (peptides.txt) do echo \"${p}\" done I get this output on the screen: Start! ./runPep.sh: line 3: syntax error near unexpected token `(' ./runPep.sh: line 3: `for p in (peptides.txt)' (Later I want to do something more complicated with $p than just output to the screen.) The environment variable SHELL is (from env): SHELL=/bin/bash /bin/bash --version output: GNU bash, version 3.1.17(1)-release (x86_64-suse-linux-gnu) Copyright (C) 2005 Free Software Foundation, Inc. cat /proc/version output: Linux version 2.6.18.2-34-default (geeko@buildhost) (gcc version 4.1.2 20061115 (prerelease) (SUSE Linux)) #1 SMP Mon Nov 27 11:46:27 UTC 2006 The file peptides.txt contains: RKEKNVQ IPKKLLQK QYFHQLEKMNVK IPKKLLQK GDLSTALEVAIDCYEK QYFHQLEKMNVKIPENIYR RKEKNVQ VLAKHGKLQDAIN ILGFMK LEDVALQILL",
    "answer": "One way to do it is: while read p; do echo \"$p\" done <peptides.txt As pointed out in the comments, this has the side effects of trimming leading whitespace, interpreting backslash sequences, and skipping the last line if it's missing a terminating linefeed. If these are concerns, you can do: while IFS=\"\" read -r p || [ -n \"$p\" ] do printf '%s\\n' \"$p\" done < peptides.txt Exceptionally, if the loop body may read from standard input , you can open the file using a different file descriptor: while read -u 10 p; do ... done 10<peptides.txt Here, 10 is just an arbitrary number (different from 0, 1, 2)."
  },
  {
    "question": "I have two branches in my Git repository: master seotweaks (created originally from master ) I created seotweaks with the intention of quickly merging it back into master . However, that was three months ago and the code in this branch is 13 versions ahead of master . It has effectively become our working master branch as all the code in master is more or less obsolete now. Very bad practice I know, lesson learned. Do you know how I can replace all of the contents of the master branch with those in seotweaks ? I could just delete everything in master and merge, but this does not feel like best practice.",
    "answer": "You should be able to use the “ours” merge strategy to overwrite master with seotweaks like this: git checkout master git pull git checkout seotweaks git merge -s ours master git checkout master git merge seotweaks The first two steps are a useful precaution to ensure your local copy of master is up-to-date. The result should be that your master is now essentially seotweaks. ( -s ours is short for --strategy=ours ) From the docs about the 'ours' strategy: This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the recursive merge strategy. Update from comments: If you get fatal: refusing to merge unrelated histories , then change the fourth line to this: git merge --allow-unrelated-histories -s ours master"
  },
  {
    "question": "If I have a file or directory that is a symbolic link and I commit it to a Git repository, what happens to it? I would assume that it leaves it as a symbolic link until the file is deleted and then if you pull the file back from an old version it just creates a normal file. What does it do when I delete the file it references? Does it just commit the dangling link?",
    "answer": "From linux symlink manual (assuming you are in Linux): A symbolic link is a special type of file whose contents are a string that is the pathname of another file, the file to which the link refers. (The contents of a symbolic link can be read using readlink(2).) So a symbolic link is just another file, no different than a README.md or a Makefile . Git just stores the contents of the link (i.e. the aforementioned path of the file system object that it links to) in a 'blob' just like it would for any other file. It then stores the name, mode and type (including the fact that it is a symlink) in the tree object that represents its containing directory. When you checkout a tree containing the link, it restores the object as a symlink regardless of whether the target file system object exists or not. If you delete the file that the symlink references it doesn't affect the Git-controlled symlink in any way. You will have a dangling reference. It is up to the user to either remove or change the link to point to something valid if needed."
  },
  {
    "question": "I'm trying to figure out how I can download a particular tag of a Git repository - it's one version behind the current version. I saw there was a tag for the previous version on the git web page, with object name of something long hex number. But the version name is \" Tagged release 1.1.5 \" according the site. I tried a command like this (with names changed): git clone http://git.abc.net/git/abc.git my_abc And I did get something - a directory, a bunch of subdirectories, etc. If it's the whole repository, how do I get at the version I'm seeking? If not, how do I download that particular version?",
    "answer": "$ git clone will give you the whole repository. After the clone, you can list the tags with $ git tag -l and then checkout a specific tag: $ git checkout tags/<tag_name> Even better, checkout and create a branch (otherwise you will be on a branch named after the revision number of tag): $ git checkout tags/<tag_name> -b <branch_name>"
  },
  {
    "question": "I have my Git repository which, at the root, has two subdirectories: /finisht /static When this was in SVN , /finisht was checked out in one place, while /static was checked out elsewhere, like so: svn co svn+ssh://admin@domain.example/home/admin/repos/finisht/static static Is there a way to do this with Git?",
    "answer": "As of Git 2.19, this is finally possible, as can be seen in this answer . Consider upvoting that answer. Note: in Git 2.19, only client-side support is implemented, server-side support is still missing, so it only works when cloning local repositories. Also note that large Git hosters, e.g. GitHub, don't actually use the Git server, they use their own implementation, so even if support shows up in the Git server, it does not automatically mean that it works on Git hosters. (On the other hand, since they don't use the Git server, they could implement it faster in their own implementations before it shows up in Git server.) No, that's not possible in Git. Implementing something like this in Git would be a substantial effort and it would mean that the integrity of the client-side repository could no longer be guaranteed. If you are interested, search for discussions on \"sparse clone\" and \"sparse fetch\" on the Git mailing list. In general, the consensus in the Git community is that if you have several directories that are always checked out independently, then these are really two different projects and should live in two different repositories. You can glue them back together using Git Submodules ."
  },
  {
    "question": "I recently switched to synchronizing my repositories to https:// on GitHub (due to firewall issues), and it asks for a password every time. Is there a way to cache the credentials, instead of authenticating every time that git push ?",
    "answer": "Since Git 1.7.9 (released 2012), there is a neat mechanism in Git to avoid having to type your password all the time for HTTP / HTTPS, called credential helpers . You can just use one of the following credential helpers: git config --global credential.helper cache The credential.helper cache value tells Git to keep your password cached in memory for a particular amount of minutes . The default is 15 minutes, you can set a longer timeout with: # Cache for 1 hour git config --global credential.helper \"cache --timeout=3600\" # Cache for 1 day git config --global credential.helper \"cache --timeout=86400\" # Cache for 1 week git config --global credential.helper \"cache --timeout=604800\" You can also store your credentials permanently if so desired, see the other answers below. GitHub's help also suggests that if you're on Mac OS X and used Homebrew to install Git, you can use the native Mac OS X keystore with: git config --global credential.helper osxkeychain For Windows , there is a helper called Git Credential Manager for Windows or wincred in msysgit . git config --global credential.helper wincred # obsolete With Git for Windows 2.7.3+ (March 2016): git config --global credential.helper manager For Linux , you would use (in 2011) gnome-keyring (or other keyring implementation such as KWallet). Nowadays (2020), that would be (on Linux) Fedora sudo dnf install git-credential-libsecret git config --global credential.helper /usr/libexec/git-core/git-credential-libsecret Ubuntu sudo apt-get install libsecret-1-0 libsecret-1-dev cd /usr/share/doc/git/contrib/credential/libsecret sudo make git config --global credential.helper /usr/share/doc/git/contrib/credential/libsecret/git-credential-libsecret"
  },
  {
    "question": "I have a main branch with a file called app.js . I made changes to this file on an experiment branch. I want to apply only the changes made to app.js from experiment onto the main branch.",
    "answer": "git checkout main # first get back to main git checkout experiment -- app.js # then copy the version of app.js # from branch \"experiment\" See also Undo working copy modifications of one file in Git . Update August 2019, Git 2.23 With the new git switch and git restore commands, that would be: git switch main git restore --source experiment -- app.js By default, only the working tree is restored. If you want to update the index as well (meaning restore the file content, and add it to the index in one command): git restore --source experiment --staged --worktree -- app.js # shorter: git restore -s experiment -SW -- app.js As Jakub Narębski mentions in the comments: git show experiment:path/to/app.js > path/to/app.js works too, except that, as detailed in the SO question \" How to retrieve a single file from specific revision in Git? \", you need to use the full path from the root directory of the repo. Hence the path/to/app.js used by Jakub in his example. As Frosty mentions in the comment: you will only get the most recent state of app.js But, for git checkout or git show , you can actually reference any revision you want, as illustrated in the SO question \" git checkout revision of a file in git gui \": $ git show $REVISION:$FILENAME $ git checkout $REVISION -- $FILENAME would be the same is $FILENAME is a full path of a versioned file. $REVISION can be as shown in git rev-parse : experiment@{yesterday}:app.js # app.js as it was yesterday experiment^:app.js # app.js on the first commit parent experiment@{2}:app.js # app.js two commits ago and so on. schmijos adds in the comments : you also can do this from a stash: git checkout stash -- app.js This is very useful if you're working on two branches and don't want to commit."
  },
  {
    "question": "How do I resolve a git merge conflict in favor of pulled changes? I want to remove all conflicting changes from a working tree without having to go through all of the conflicts with git mergetool , while keeping all conflict-free changes. Preferably, I want to do this while pulling, not afterwards.",
    "answer": "If you're already in conflicted state, and do not want to checkout path one by one. You may try git merge --abort git pull -X theirs"
  },
  {
    "question": "I have a repository in Git. I made a branch, then did some changes both to the master and to the branch. Then, tens of commits later, I realized the branch is in much better state than the master, so I want the branch to \"become\" the master and disregard the changes on master. I cannot merge it, because I don't want to keep the changes on master. What should I do? Extra : In this case, the 'old' master has already been push -ed to another repository such as GitHub. How does this change things?",
    "answer": "The problem with the other two answers is that the new master doesn't have the old master as an ancestor, so when you push it, everyone else will get messed up. This is what you want to do: git checkout better_branch # This is the branch whose commits you want to keep git merge --strategy=ours master # keep the content of this branch, but record a merge git checkout master # You want to **lose** all changes on this branch git merge better_branch # fast-forward master up to the merge In older versions of git , if you want your history to be a little clearer, I'd recommend adding some information to the merge commit message to make it clear what you've done. Change the second line to: git merge --strategy=ours --no-commit master git commit # add information to the template merge message In newer versions of git, git will automatically open the git message editor for you. (Or you can use git mere --strategy=ours master -m \"Keeping better_branch\" )"
  },
  {
    "question": "After the last commit, I modified a bunch of files in my working copy, but I want to undo the changes to one of those files, as in reset it to the same state as the most recent commit. However, I only want to undo the working copy changes of just that one file alone, nothing else with it. How do I do that?",
    "answer": "You can use git checkout -- file You can do it without the -- (as suggested by nimrodm), but if the filename looks like a branch or tag (or other revision identifier), it may get confused, so using -- is best. You can also check out a particular version of a file: git checkout v1.2.3 -- file # tag v1.2.3 git checkout stable -- file # stable branch git checkout origin/master -- file # upstream master git checkout HEAD -- file # the version from the most recent commit git checkout HEAD^ -- file # the version before the most recent commit More details included based on comments First check the the commits of the file git log -- <filename> Then you can run this git checkout <sha-reference> -- filename where the sha-reference is a reference to the sha of a commit, in any form (branch, tag, parent, etc."
  },
  {
    "question": "I have cloned a project that includes some .csproj files. I don't need/like my local csproj files being tracked by Git (or being brought up when creating a patch), but clearly they are needed in the project. I have added *.csproj to my LOCAL .gitignore , but the files are already in the repo. When I type git status, it shows my changes to csproj which I am not interested in keeping track of or submitting for patches. How do I remove the \"tracking of\" these files from my personal repo (but keep them in the source so I can use them) so that I don't see the changes when I do a status (or create a patch)? Is there a correct/canonical way to handle this situation?",
    "answer": "Just calling git rm --cached on each of the files you want to remove from revision control should be fine. As long as your local ignore patterns are correct you won't see these files included in the output of git status. Note that this solution removes the files from the repository, so all developers would need to maintain their own local (non-revision controlled) copies of the file To prevent git from detecting changes in these files you should also use this command: git update-index --assume-unchanged [path] What you probably want to do: (from below @Ryan Taylor answer ) This is to tell git you want your own independent version of the file or folder. For instance, you don't want to overwrite (or delete) production/staging config files. git update-index --skip-worktree <path-name> The full answer is here in this URL: http://source.kohlerville.com/2009/02/untrack-files-in-git/"
  },
  {
    "question": "We've got a PHP application and want to count all the lines of code under a specific directory and its subdirectories. We don't need to ignore comments, as we're just trying to get a rough idea. wc -l *.php That command works great for a given directory, but it ignores subdirectories. I was thinking the following comment might work, but it is returning 74, which is definitely not the case... find . -name '*.php' | wc -l What's the correct syntax to feed in all the files from a directory resursively?",
    "answer": "Try: find . -name '*.php' | xargs wc -l or (when file names include special characters such as spaces) find . -name '*.php' | sed 's/.*/\"&\"/' | xargs wc -l The SLOCCount tool may help as well. It will give an accurate source lines of code count for whatever hierarchy you point it at, as well as some additional stats. Sorted output: find . -name '*.php' | xargs wc -l | sort -nr"
  },
  {
    "question": "I want to get a list of all the branches in a Git repository with the \"freshest\" branches at the top, where the \"freshest\" branch is the one that's been committed to most recently (and is, therefore, more likely to be one I want to pay attention to). Is there a way I can use Git to either (a) sort the list of branches by latest commit, or (b) get a list of branches together with each one's last-commit date, in some kind of machine-readable format? Worst case, I could always run git branch to get a list of all the branches, parse its output, and then git log -n 1 branchname --format=format:%ci for each one, to get each branch's commit date. But this will run on a Windows box, where spinning up a new process is relatively expensive, so launching the Git executable once per branch could get slow if there are a lot of branches. Is there a way to do all this with a single command?",
    "answer": "Use the --sort=-committerdate option of git for-each-ref ; Also available since Git 2.7.0 for git branch : Basic Usage: git for-each-ref --sort=-committerdate refs/heads/ # Or using git branch (since version 2.7.0) git branch --sort=-committerdate # DESC git branch --sort=committerdate # ASC Result: Advanced Usage: git for-each-ref --sort=committerdate refs/heads/ --format='%(HEAD) %(align:35)%(color:yellow)%(refname:short)%(color:reset)%(end) - %(color:red)%(objectname:short)%(color:reset) - %(align:40)%(contents:subject)%(end) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))' Result: Pro Usage (Unix): You can put the following snippet in your ~/.gitconfig . The recentb alias accepts two arguments: refbranch : which branch the ahead and behind columns are calculated against. Default master count : how many recent branches to show. Default 20 [alias] # ATTENTION: All aliases prefixed with ! run in /bin/sh make sure you use sh syntax, not bash/zsh or whatever recentb = \"!r() { refbranch=$1 count=$2; git for-each-ref --sort=-committerdate refs/heads --format='%(refname:short)|%(HEAD)%(color:yellow)%(refname:short)|%(color:bold green)%(committerdate:relative)|%(color:blue)%(subject)|%(color:magenta)%(authorname)%(color:reset)' --color=always --count=${count:-20} | while read line; do branch=$(echo \\\"$line\\\" | awk 'BEGIN { FS = \\\"|\\\" }; { print $1 }' | tr -d '*'); ahead=$(git rev-list --count \\\"${refbranch:-origin/master}..${branch}\\\"); behind=$(git rev-list --count \\\"${branch}..${refbranch:-origin/master}\\\"); colorline=$(echo \\\"$line\\\" | sed 's/^[^|]*|//'); echo \\\"$ahead|$behind|$colorline\\\" | awk -F'|' -vOFS='|' '{$5=substr($5,1,70)}1' ; done | ( echo \\\"ahead|behind|branch|lastcommit|message|author\\n\\\" && cat) | column -ts'|';}; r\" Result:"
  },
  {
    "question": "To redirect standard output to a truncated file in Bash, I know to use: cmd > file.txt To redirect standard output in Bash, appending to a file, I know to use: cmd >> file.txt To redirect both standard output and standard error to a truncated file, I know to use: cmd &> file.txt How do I redirect both standard output and standard error appending to a file? cmd &>> file.txt did not work for me.",
    "answer": "cmd >>file.txt 2>&1 Bash executes the redirects from left to right as follows: >>file.txt : Open file.txt in append mode and redirect stdout there. 2>&1 : Redirect stderr to \"where stdout is currently going\" . In this case, that is a file opened in append mode. In other words, the &1 reuses the file descriptor which stdout currently uses."
  },
  {
    "question": "I create a new branch in Git: git branch my_branch Push it: git push origin my_branch Now say someone made some changes on the server and I want to pull from origin/my_branch . I do: git pull But I get: You asked me to pull without telling me which branch you want to merge with, and 'branch.my_branch.merge' in your configuration file does not tell me, either. Please specify which branch you want to use on the command line and try again (e.g. 'git pull <repository> <refspec>'). See git-pull(1) for details. If you often merge with the same branch, you may want to use something like the following in your configuration file: [branch \"my_branch\"] remote = <nickname> merge = <remote-ref> [remote \"<nickname>\"] url = <url> fetch = <refspec> See git-config(1) for details. I learned that I can make it work with: git branch --set-upstream my_branch origin/my_branch But why do I need to do this for every branch I create? Isn't it obvious that if I push my_branch into origin/my_branch , then I would want to pull origin/my_branch into my_branch ? How can I make this the default behavior?",
    "answer": "Git v2.37.1 and above If you are using the mentioned version or above you can use this new config entry to automatically setup remote tracking: git config --global push.autoSetupRemote true After that, when you do git push tracking is setup automatically. No need for git push -u origin my_branch A shortcut, which doesn't depend on remembering the syntax for git branch --set-upstream 1 is to do: git push -u origin my_branch ... the first time that you push that branch. Or, to push to the current branch from a branch of the same name (handy for an alias): git push -u origin HEAD You only need to use -u once, and that sets up the association between your branch and the one at origin in the same way as git branch --set-upstream does. Personally, I think it's a good thing to have to set up that association between your branch and one on the remote explicitly. It's just a shame that the rules are different for git push and git pull . 1 It may sound silly, but I very frequently forget to specify the current branch, assuming that's the default - it's not, and the results are most confusing. Update 2012-10-11 : Apparently I'm not the only person who found it easy to get wrong! Thanks to VonC for pointing out that git 1.8.0 introduces the more obvious git branch --set-upstream-to , which can be used as follows, if you're on the branch my_branch : git branch --set-upstream-to origin/my_branch ... or with the short option: git branch -u origin/my_branch This change, and its reasoning, is described in the release notes for git 1.8.0, release candidate 1 : It was tempting to say git branch --set-upstream origin/master , but that tells Git to arrange the local branch origin/master to integrate with the currently checked out branch, which is highly unlikely to be what the user meant. The option is deprecated; use the new --set-upstream-to (with a short-and-sweet -u ) option instead."
  },
  {
    "question": "How do I undo this command? git reset HEAD~",
    "answer": "Short answer: git reset 'HEAD@{1}' Long answer: Git keeps a log of all ref updates (e.g., checkout, reset, commit, merge). You can view it by typing: git reflog Somewhere in this list is the commit that you lost. Let's say you just typed git reset HEAD~ and want to undo it. My reflog looks like this: $ git reflog 3f6db14 HEAD@{0}: HEAD~: updating HEAD d27924e HEAD@{1}: checkout: moving from d27924e0fe16776f0d0f1ee2933a0334a4787b4c [...] The first line says that HEAD 0 positions ago (in other words, the current position) is 3f6db14; it was obtained by resetting to HEAD~ . The second line says that HEAD 1 position ago (in other words, the state before the reset) is d27924e. It was obtained by checking out a particular commit (though that's not important right now). So, to undo the reset, run git reset HEAD@{1} (or git reset d27924e ). If, on the other hand, you've run some other commands since then that update HEAD, the commit you want won't be at the top of the list, and you'll need to search through the reflog . One final note: It may be easier to look at the reflog for the specific branch you want to un-reset, say master, rather than HEAD : $ git reflog show master c24138b master@{0}: merge origin/master: Fast-forward 90a2bf9 master@{1}: merge origin/master: Fast-forward [...] This should have less noise it in than the general HEAD reflog ."
  },
  {
    "question": "I need to check the existence of an input argument. I have the following script if [ \"$1\" -gt \"-1\" ] then echo hi fi I get [: : integer expression expected How do I check the input argument1 first to see if it exists?",
    "answer": "It is: if [ $# -eq 0 ] then echo \"No arguments supplied\" fi The $# variable will tell you the number of input arguments the script was passed. Or you can check if an argument is an empty string or not like: if [ -z \"$1\" ] then echo \"No argument supplied\" fi The -z switch will test if the expansion of \"$1\" is a null string or not. If it is a null string then the body is executed."
  },
  {
    "question": "I accidentally amended my previous commit. The commit should have been separate to keep history of the changes I made to a particular file. Is there a way to undo that last commit? If I do something like git reset --hard HEAD^ , the first commit also is undone. (I have not yet pushed to any remote directories)",
    "answer": "What you need to do is to create a new commit with the same details as the current HEAD commit, but with the parent as the previous version of HEAD . git reset --soft will move the branch pointer so that the next commit happens on top of a different commit from where the current branch head is now. # Move the current head so that it's pointing at the old commit # Leave the index intact for redoing the commit. # HEAD@{1} gives you \"the commit that HEAD pointed at before # it was moved to where it currently points at\". Note that this is # different from HEAD~1, which gives you \"the commit that is the # parent node of the commit that HEAD is currently pointing to.\" git reset --soft HEAD@{1} # commit the current tree using the commit details of the previous # HEAD commit. (Note that HEAD@{1} is pointing somewhere different from the # previous command. It's now pointing at the erroneously amended commit.) # The -C option takes the given commit and reuses the log message and # authorship information. git commit -C HEAD@{1}"
  },
  {
    "question": "I have a Git repository which contains a number of subdirectories. Now I have found that one of the subdirectories is unrelated to the other and should be detached to a separate repository. How can I do this while keeping the history of the files within the subdirectory? I guess I could make a clone and remove the unwanted parts of each clone, but I suppose this would give me the complete tree when checking out an older revision etc. This might be acceptable, but I would prefer to be able to pretend that the two repositories doesn't have a shared history. Just to make it clear, I have the following structure: XYZ/ .git/ XY1/ ABC/ XY2/ But I would like this instead: XYZ/ .git/ XY1/ XY2/ ABC/ .git/ ABC/",
    "answer": "Update : This process is so common, that the git team made it much simpler with a new tool, git subtree . See here: Detach (move) subdirectory into separate Git repository You want to clone your repository and then use git filter-branch to mark everything but the subdirectory you want in your new repo to be garbage-collected. To clone your local repository: git clone /XYZ /ABC (Note: the repository will be cloned using hard-links, but that is not a problem since the hard-linked files will not be modified in themselves - new ones will be created.) Now, let us preserve the interesting branches which we want to rewrite as well, and then remove the origin to avoid pushing there and to make sure that old commits will not be referenced by the origin: cd /ABC for i in branch1 br2 br3; do git branch -t $i origin/$i; done git remote rm origin or for all remote branches: cd /ABC for i in $(git branch -r | sed \"s/.*origin\\///\"); do git branch -t $i origin/$i; done git remote rm origin Now you might want to also remove tags which have no relation with the subproject; you can also do that later, but you might need to prune your repo again. I did not do so and got a WARNING: Ref 'refs/tags/v0.1' is unchanged for all tags (since they were all unrelated to the subproject); additionally, after removing such tags more space will be reclaimed. Apparently git filter-branch should be able to rewrite other tags, but I could not verify this. If you want to remove all tags, use git tag -l | xargs git tag -d . Then use filter-branch and reset to exclude the other files, so they can be pruned. Let's also add --tag-name-filter cat --prune-empty to remove empty commits and to rewrite tags (note that this will have to strip their signature): git filter-branch --tag-name-filter cat --prune-empty --subdirectory-filter ABC -- --all or alternatively, to only rewrite the HEAD branch and ignore tags and other branches: git filter-branch --tag-name-filter cat --prune-empty --subdirectory-filter ABC HEAD Then delete the backup reflogs so the space can be truly reclaimed (although now the operation is destructive) git reset --hard git for-each-ref --format=\"%(refname)\" refs/original/ | xargs -n 1 git update-ref -d git reflog expire --expire=now --all git gc --aggressive --prune=now and now you have a local git repository of the ABC sub-directory with all its history preserved. Note: For most uses, git filter-branch should indeed have the added parameter -- --all . Yes that's really - - space - - all . This needs to be the last parameters for the command. As Matli discovered, this keeps the project branches and tags included in the new repo. Edit: various suggestions from comments below were incorporated to make sure, for instance, that the repository is actually shrunk (which was not always the case before)."
  },
  {
    "question": "Once upon a time, there was a file in my project that I would now like to be able to get. The problem is: I have no idea of when have I deleted it and on which path it was. How can I locate the commits of this file when it existed?",
    "answer": "If you do not know the exact path you may use git log --all --full-history -- \"**/thefile.*\" If you know the path the file was at, you can do this: git log --all --full-history -- <path-to-file> This should show a list of commits in all branches which touched that file. Then, you can find the version of the file you want, and display it with... git show <SHA> -- <path-to-file> Or restore it into your working copy with: git checkout <SHA>^ -- <path-to-file> Note the caret symbol ( ^ ), which gets the checkout prior to the one identified, because at the moment of <SHA> commit the file is deleted, we need to look at the previous commit to get the deleted file's contents"
  },
  {
    "question": "I have deleted a file or some code in a file sometime in the past. Can I search through the content (not just the commit messages)? A very poor solution is to grep the log: git log -p | grep <pattern> However, this doesn't return the commit hash straight away. I played around with git grep to no avail.",
    "answer": "You should use the pickaxe ( -S ) option of git log . To search for Foo : git log -SFoo -- path_containing_change git log -SFoo --since=2009.1.1 --until=2010.1.1 -- path_containing_change See Git history - find lost line by keyword for more. -S (named pickaxe ) comes originally from a git diff option (Git v0.99, May 2005). Then -S ( pickaxe ) was ported to git log in May 2006 with Git 1.4.0-rc1. As Jakub Narębski commented: this looks for differences that introduce or remove an instance of <string> . It usually means \"revisions where you added or removed line with 'Foo'\". the --pickaxe-regex option allows you to use extended POSIX regex instead of searching for a string. Example (from git log ): git log -S\"frotz\\(nitfol\" --pickaxe-regex As Rob commented, this search is case-sensitive - he opened a follow-up question on how to search case-insensitive. Hi Angel notes in the comments : Executing a git log -G<regexp> --branches --all (the -G is same as -S but for regexes) does same thing as the accepted one ( git grep <regexp> $(git rev-list --all) ), but it soooo much faster! The accepted answer was still searching for text after ≈10 minutes of me running it, whereas this one gives results after ≈4 seconds 🤷‍♂️. The output here is more useful as well"
  },
  {
    "question": "I have a remote Git server, here is the scenario which I want to perform: For each bug/feature I create a different Git branch I keep on committing my code in that Git branch with un-official Git messages In top repository we have to do one commit for one bug with official Git message So how can I merge my branch to remote branch so that they get just one commit for all my check-ins (I even want to provide commit message for this)?",
    "answer": "Say your bug fix branch is called bugfix and you want to merge it into master : git checkout master git merge --squash bugfix git commit This will take all the commits from the bugfix branch, squash them into 1 commit, and merge it with your master branch. Explanation : git checkout master Switches to your master branch. git merge --squash bugfix Takes all commits from the bugfix branch and groups it for a 1 commit with your current branch. (no merge commit appears; you could resolve conflicts manually before following commit) git commit Creates a single commit from the merged changes. Omitting the -m parameter lets you modify a draft commit message containing every message from your squashed commits before finalizing your commit."
  },
  {
    "question": "How can I see the changes un-stashing will make to the current working tree? I would like to know what changes will be made before applying them!",
    "answer": "See the most recent stash: git stash show -p See an arbitrary stash: git stash show -p stash@{1} From the git stash manpages: By default, the command shows the diffstat, but it will accept any format known to git diff (e.g., git stash show -p stash@{1} to view the second most recent stash in patch form)."
  },
  {
    "question": "I cloned a Git repository from my GitHub account to my PC. I want to work with both my PC and laptop, but with one GitHub account. When I try to push to or pull from GitHub using my PC, it requires a username and password, but not when I'm using the laptop! I don't want to type my username and password every time I interact with origin . What am I missing here?",
    "answer": "A common cause is cloning using the default (HTTPS) instead of SSH. You can correct this by going to your repository, clicking \"Clone or download\", then clicking the \"Use SSH\" button above the URL field and updating the URL of your origin remote like this: git remote set-url origin git@github.com:username/repo.git You can check if you have added the remote as HTTPS or SSH using: git remote -v This is documented at GitHub: Switching remote URLs from HTTPS to SSH ."
  },
  {
    "question": "I've set up a remote non-bare \"main\" repo and cloned it to my computer. I made some local changes, updated my local repository, and pushed the changes back to my remote repo. Things were fine up to that point. Now, I had to change something in the remote repo. Then I changed something in my local repo. I realized that the change to the remote repo was not needed. So I tried to git push from my local repo to my remote repo, but I got an error like: To prevent you from losing history, non-fast-forward updates were rejected Merge the remote changes before pushing again. See the 'Note about fast-forwards' section of git push --help for details. I thought that probably a git push --force would force my local copy to push changes to the remote one and make it the same. It does force the update , but when I go back to the remote repo and make a commit, I notice that the files contain outdated changes (ones that the main remote repo previously had). As I mentioned in the comments to one of the answers : [I] tried forcing, but when going back to master server to save the changes, i get outdated staging. Thus, when i commit the repositories are not the same. And when i try to use git push again, i get the same error. How can I fix this issue?",
    "answer": "Just do: git push origin <your_branch_name> --force or if you have a specific repo: git push https://git.... --force This will delete your previous commit(s) and push your current one. It may not be proper, but if anyone stumbles upon this page, thought they might want a simple solution... Short flag Also note that -f is short for --force , so git push origin <your_branch_name> -f will also work."
  },
  {
    "question": "I want to pause input in a shell script, and prompt the user for choices. The standard Yes , No , or Cancel type question. How do I accomplish this in a typical bash prompt?",
    "answer": "A widely available method to get user input at a shell prompt is the read command. Here is a demonstration: while true; do read -p \"Do you wish to install this program? \" yn case $yn in [Yy]* ) make install; break;; [Nn]* ) exit;; * ) echo \"Please answer yes or no.\";; esac done Another method, pointed out by Steven Huwig , is Bash's select command. Here is the same example using select : echo \"Do you wish to install this program?\" select yn in \"Yes\" \"No\"; do case $yn in Yes ) make install; break;; No ) exit;; esac done With select you don't need to sanitize the input – it displays the available choices, and you type a number corresponding to your choice. It also loops automatically, so there's no need for a while true loop to retry if they give invalid input. If you want to allow more flexible input (accepting the words of the options, rather than just their number ), you can alter it like this: echo \"Do you wish to install this program?\" select strictreply in \"Yes\" \"No\"; do relaxedreply=${strictreply:-$REPLY} case $relaxedreply in Yes | yes | y ) make install; break;; No | no | n ) exit;; esac done Also, Léa Gris demonstrated a way to make the request language agnostic in her answer . Adapting my first example to better serve multiple languages might look like this: set -- $(locale LC_MESSAGES) yesexpr=\"$1\"; noexpr=\"$2\"; yesword=\"$3\"; noword=\"$4\" while true; do read -p \"Install (${yesword} / ${noword})? \" yn if [[ \"$yn\" =~ $yesexpr ]]; then make install; exit; fi if [[ \"$yn\" =~ $noexpr ]]; then exit; fi echo \"Answer ${yesword} / ${noword}.\" done Obviously other communication strings remain untranslated here (Install, Answer) which would need to be addressed in a more fully completed translation, but even a partial translation would be helpful in many cases. Finally, please check out the excellent answer by F. Hauri ."
  },
  {
    "question": "Can I ignore files locally without polluting the global git config for everyone else? I have untracked files that are spam in my git status but I don't want to commit git config changes for every single little random untracked file I have in my local branches.",
    "answer": "From the relevant Git documentation : Patterns which are specific to a particular repository but which do not need to be shared with other related repositories (e.g., auxiliary files that live inside the repository but are specific to one user's workflow) should go into the $GIT_DIR/info/exclude file. The .git/info/exclude file has the same format as any .gitignore file. Another option is to set core.excludesFile to the name of a file containing global patterns. Note, if you already have unstaged changes you must run the following after editing your ignore-patterns: git update-index --assume-unchanged <file-list> Note on $GIT_DIR : This is a notation used all over the git manual simply to indicate the path to the git repository. If the environment variable is set, then it will override the location of whichever repo you're in, which probably isn't what you want. Edit : Another way is to use: git update-index --skip-worktree <file-list> Reverse it by: git update-index --no-skip-worktree <file-list>"
  },
  {
    "question": "I have a local branch master that points to a remote branch origin/regacy (oops, typo!). How do I rename the remote branch to origin/legacy or origin/master ? I tried: git remote rename regacy legacy But this gave an error: error : Could not rename config section 'remote.regacy' to 'remote.legacy'",
    "answer": "There are a few ways to accomplish that: Change your local branch and then push your changes Push the branch to remote with the new name while keeping the original name locally Renaming local and remote # Names of things - allows you to copy/paste commands old_name=feature/old new_name=feature/new remote=origin # Rename the local branch to the new name git branch -m $old_name $new_name # Delete the old branch on remote git push $remote --delete $old_name # Or shorter way to delete remote branch [:] git push $remote :$old_name # Prevent git from using the old name when pushing in the next step. # Otherwise, git will use the old upstream name instead of $new_name. git branch --unset-upstream $new_name # Push the new branch to remote git push $remote $new_name # Reset the upstream branch for the new_name local branch git push $remote -u $new_name Renaming Only remote branch Credit: ptim # In this option, we will push the branch to the remote with the new name # While keeping the local name as is git push $remote $remote/$old_name:refs/heads/$new_name :$old_name Important note: When you use the git branch -m (move), Git is also updating your tracking branch with the new name. git remote rename legacy legacy git remote rename is trying to update your remote section in your configuration file. It will rename the remote with the given name to the new name, but in your case, it did not find any, so the renaming failed. But it will not do what you think; it will rename your local configuration remote name and not the remote branch. Note Git servers might allow you to rename Git branches using the web interface or external programs (like Sourcetree, etc.), but you have to keep in mind that in Git all the work is done locally, so it's recommended to use the above commands to the work."
  },
  {
    "question": "Without creating a branch and doing a bunch of funky work on a new branch, is it possible to break a single commit into a few different commits after it's been committed to the local repository?",
    "answer": "git rebase -i will do it. First, start with a clean working directory: git status should show no pending modifications, deletions, or additions. Now, you have to decide which commit(s) you want to split. A) Splitting the most recent commit To split apart your most recent commit, first: $ git reset HEAD~ Now commit the pieces individually in the usual way, producing as many commits as you need. B) Splitting a commit farther back This requires rebasing , that is, rewriting history. To specify the correct commit, you have several choices: If it is three commits back, then $ git rebase -i HEAD~3 where 3 is how many commits back it is. If it is farther back in the tree than you want to count, then $ git rebase -i 123abcd~ where 123abcd is the SHA1 of the commit you want to split up. If you want to rebase the entire current branch simply do: $ git rebase -i If you are on a different branch (e.g., a feature branch) that you want to merge into master : $ git rebase -i master When you get the rebase edit screen, find the commit you want to break apart. At the beginning of that line, replace pick with edit ( e for short). Save the buffer and exit. Rebase will now stop just after the commit you want to edit. Then: $ git reset HEAD~ Commit the pieces individually in the usual way, producing as many commits as you need. Finally $ git rebase --continue If you want to preserve authorship If you want to preserve the authorship of commits, and possibly the date as well, see copy author and date from other commit, but _not_ the message"
  },
  {
    "question": "A rather unusual situation perhaps, but I want to specify a private SSH-key to use when executing a shell ( git ) command from the local computer. Basically like this: git clone git@github.com:TheUser/TheProject.git -key \"/home/christoffer/ssh_keys/theuser\" Or even better (in Ruby): with_key(\"/home/christoffer/ssh_keys/theuser\") do sh(\"git clone git@github.com:TheUser/TheProject.git\") end I have seen examples of connecting to a remote server with Net::SSH that uses a specified private key, but this is a local command. Is it possible?",
    "answer": "Something like this should work (suggested by orip): ssh-agent bash -c 'ssh-add /somewhere/yourkey; git clone git@github.com:user/project.git' if you prefer subshells, you could try the following (though it is more fragile): ssh-agent $(ssh-add /somewhere/yourkey; git clone git@github.com:user/project.git) Git will invoke SSH which will find its agent by environment variable; this will, in turn, have the key loaded. Alternatively, setting HOME may also do the trick, provided you are willing to setup a directory that contains only a .ssh directory as HOME ; this may either contain an identity.pub, or a config file setting IdentityFile."
  },
  {
    "question": "I used to use CShell ( csh ), which lets you make an alias that takes a parameter. The notation was something like alias junk=\"mv \\\\!* ~/.Trash\" In Bash, this does not seem to work. Given that Bash has a multitude of useful features, I would assume that this one has been implemented but I am wondering how.",
    "answer": "Bash alias does not directly accept parameters. You will have to create a function. alias does not accept parameters but a function can be called just like an alias. For example: myfunction() { #do things with parameters like $1 such as mv \"$1\" \"$1.bak\" cp \"$2\" \"$1\" } myfunction old.conf new.conf #calls `myfunction` By the way, Bash functions defined in your .bashrc and other files are available as commands within your shell. So for instance you can call the earlier function like this $ myfunction original.conf my.conf"
  },
  {
    "question": "How do I discard the changes to a single file and overwrite it with a fresh HEAD copy? I want to do git reset --hard to only a single file.",
    "answer": "To reset both the working copy of my-file.txt and its state in the Git index to that of HEAD: git checkout HEAD -- my-file.txt -- means \"treat every argument after this point as a filename\" . More details in this answer . Thanks to VonC for pointing this out."
  },
  {
    "question": "Is there a way in bash to convert a string into a lower case string? For example, if I have: a=\"Hi all\" I want to convert it to: \"hi all\"",
    "answer": "There are various ways: POSIX standard tr $ echo \"$a\" | tr '[:upper:]' '[:lower:]' hi all AWK $ echo \"$a\" | awk '{print tolower($0)}' hi all Non-POSIX You may run into portability issues with the following examples: Bash 4.0 $ echo \"${a,,}\" hi all sed $ echo \"$a\" | sed -e 's/\\(.*\\)/\\L\\1/' hi all # this also works: $ sed -e 's/\\(.*\\)/\\L\\1/' <<< \"$a\" hi all Perl $ echo \"$a\" | perl -ne 'print lc' hi all Bash lc(){ case \"$1\" in [A-Z]) n=$(printf \"%d\" \"'$1\") n=$((n+32)) printf \\\\$(printf \"%o\" \"$n\") ;; *) printf \"%s\" \"$1\" ;; esac } word=\"I Love Bash\" for((i=0;i<${#word};i++)) do ch=\"${word:$i:1}\" lc \"$ch\" done Note: YMMV on this one. Doesn't work for me (GNU bash version 4.2.46 and 4.0.33 (and same behaviour 2.05b.0 but nocasematch is not implemented)) even with using shopt -u nocasematch; . Unsetting that nocasematch causes [[ \"fooBaR\" == \"FOObar\" ]] to match OK BUT inside case weirdly [b-z] are incorrectly matched by [A-Z] . Bash is confused by the double-negative (\"unsetting nocasematch\")! :-)"
  },
  {
    "question": "git revert <commit_hash> alone won't work. Apparently, -m must be specified.",
    "answer": "In git revert -m , the -m option specifies the parent number . This is needed because a merge commit has more than one parent, and Git does not know automatically which parent was the mainline, and which parent was the branch you want to un-merge. When you view a merge commit in the output of git log , you will see its parents listed on the line that begins with Merge: (the second line in this case): commit 8f937c683929b08379097828c8a04350b9b8e183 Merge: 8989ee0 7c6b236 Author: Ben James <ben@example.com> Date: Wed Aug 17 22:49:41 2011 +0100 Merge branch 'gh-pages' Conflicts: README In this situation, git revert 8f937c6 -m 1 will get you the tree as it was in 8989ee0 , and git revert -m 2 will reinstate the tree as it was in 7c6b236 . To better understand what you're about to revert do git diff <parent_commit> <commit_to_revert> , in this case: git diff 8989ee0 8f937c6 and git diff 7c6b236 8f937c6 However, it's very important you realize that in doing so \"...declares that you will never want the tree changes brought in by the merge. As a result, later merges will only bring in tree changes introduced by commits that are not ancestors of the previously reverted merge. This may or may not be what you want. See the revert-a-faulty-merge How-To for more details.\" ( git-merge man page )."
  },
  {
    "question": "git init git add . Gives the following warnings for many files: The file will have its original line endings in your working directory. warning: LF will be replaced by CRLF in <filename>. What's the difference between LF and CRLF? What should I do about the warnings?",
    "answer": "In Unix systems the end of a line is represented with a line feed (LF). In windows a line is represented with a carriage return (CR) and a line feed (LF) thus (CRLF). when you get code from git that was uploaded from a unix system they will only have an LF. If you are a single developer working on a windows machine, and you don't care that git automatically replaces LFs to CRLFs, you can turn this warning off by typing the following in the git command line git config core.autocrlf true If you want to make an intelligent decision how git should handle this, read the documentation Here is a snippet Formatting and Whitespace Formatting and whitespace issues are some of the more frustrating and subtle problems that many developers encounter when collaborating, especially cross-platform. It’s very easy for patches or other collaborated work to introduce subtle whitespace changes because editors silently introduce them, and if your files ever touch a Windows system, their line endings might be replaced. Git has a few configuration options to help with these issues. core.autocrlf If you’re programming on Windows and working with people who are not (or vice-versa), you’ll probably run into line-ending issues at some point. This is because Windows uses both a carriage-return character and a linefeed character for newlines in its files, whereas Mac and Linux systems use only the linefeed character. This is a subtle but incredibly annoying fact of cross-platform work; many editors on Windows silently replace existing LF-style line endings with CRLF, or insert both line-ending characters when the user hits the enter key. Git can handle this by auto-converting CRLF line endings into LF when you add a file to the index, and vice versa when it checks out code onto your filesystem. You can turn on this functionality with the core.autocrlf setting. If you’re on a Windows machine, set it to true – this converts LF endings into CRLF when you check out code: $ git config --global core.autocrlf true If you’re on a Linux or Mac system that uses LF line endings, then you don’t want Git to automatically convert them when you check out files; however, if a file with CRLF endings accidentally gets introduced, then you may want Git to fix it. You can tell Git to convert CRLF to LF on commit but not the other way around by setting core.autocrlf to input: $ git config --global core.autocrlf input This setup should leave you with CRLF endings in Windows checkouts, but LF endings on Mac and Linux systems and in the repository. If you’re a Windows programmer doing a Windows-only project, then you can turn off this functionality, recording the carriage returns in the repository by setting the config value to false: $ git config --global core.autocrlf false"
  },
  {
    "question": "I'm using Git on a new project that has two parallel -- but currently experimental -- development branches: master : import of existing codebase plus a few modifications that I'm generally sure of exp1 : experimental branch #1 exp2 : experimental branch #2 exp1 and exp2 represent two very different architectural approaches. Until I get further along I have no way of knowing which one (if either) will work. As I make progress in one branch I sometimes have edits that would be useful in the other branch and would like to merge just those. What is the best way to merge selective changes from one development branch to another while leaving behind everything else? Approaches I've considered: git merge --no-commit followed by manual unstaging of a large number of edits that I don't want to make common between the branches. Manual copying of common files into a temporary directory followed by git checkout to move to the other branch and then more manual copying out of the temporary directory into the working tree. A variation on the above. Abandon the exp branches for now and use two additional local repositories for experimentation. This makes the manual copying of files much more straightforward. All three of these approaches seem tedious and error-prone. I'm hoping there is a better approach; something akin to a filter path parameter that would make git-merge more selective.",
    "answer": "You use the cherry-pick command to get individual commits from one branch. If the change(s) you want are not in individual commits, then use the method shown here to split the commit into individual commits . Roughly speaking, you use git rebase -i to get the original commit to edit, then git reset HEAD^ to selectively revert changes, then git commit to commit that bit as a new commit in the history. There is another nice method here in Red Hat Magazine, where they use git add --patch or possibly git add --interactive which allows you to add just parts of a hunk, if you want to split different changes to an individual file (search in that page for \"split\"). Having split the changes, you can now cherry-pick just the ones you want."
  },
  {
    "question": "How can I remove those annoying Mac OS X .DS_Store files from a Git repository?",
    "answer": "Remove existing .DS_Store files from the repository: find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch Add this line: .DS_Store to the file .gitignore , which can be found at the top level of your repository (or create the file if it isn't there already). You can do this easily with this command in the top directory: echo .DS_Store >> .gitignore Then commit the file to the repo: git add .gitignore git commit -m '.DS_Store banished!'"
  },
  {
    "question": "I'd like to show all configured Git sections. I only found git config --get core.editor , and I'd like to output everything that's configured globally, not only the configured default editor.",
    "answer": "You can use: git config --list or look at your ~/.gitconfig file. The local configuration will be in your repository's .git/config file. Use: git config --list --show-origin to see where that setting is defined (global, user, repo, etc...)"
  },
  {
    "question": "I made a branch called 'f' and did a checkout to master. When I tried the git pull command I got this message: You have not concluded your merge (MERGE_HEAD exists). Please, commit your changes before you can merge. When I try the git status , it gave me the following: On branch master # Your branch and 'origin/master' have diverged, # and have 1 and 13 different commit(s) each, respectively. # # Changes to be committed: # # modified: app/assets/images/backward.png # modified: app/assets/images/forward.png # new file: app/assets/images/index_background.jpg # new file: app/assets/images/loading.gif # modified: app/assets/images/pause.png # modified: app/assets/images/play.png # new file: app/assets/javascripts/jquery-ui-bootstrap.js # new file: app/assets/stylesheets/jquery-ui-bootstrap.css # modified: app/controllers/friends_controller.rb # modified: app/controllers/plays_controller.rb # modified: app/mailers/invite_friends_mailer.rb # modified: app/mailers/send_plays_mailer.rb # modified: app/mailers/shot_chart_mailer.rb # modified: app/views/friends/show_plays.html.erb # modified: app/views/layouts/application.html.erb # modified: app/views/plays/_inbox_table.html.erb # modified: app/views/plays/show.html.erb # modified: app/views/welcome/contact_form.html.erb # modified: app/views/welcome/index.html.erb # modified: log/development.log # modified: log/restclient.log # new file: tmp/cache/assets/C1A/C00/sprockets%2Fb7901e0813446f810e560158a1a97066 # modified: tmp/cache/assets/C64/930/sprockets%2F65aa1510292214f4fd1342280d521e4c # new file: tmp/cache/assets/C73/C40/sprockets%2F96912377b93498914dd04bc69fa98585 # new file: tmp/cache/assets/CA9/090/sprockets%2Fa71992733a432421e67e03ff1bd441d8 # new file: tmp/cache/assets/CCD/7E0/sprockets%2F47125c2ebd0e8b29b6511b7b961152a1 # modified: tmp/cache/assets/CD5/DD0/sprockets%2F59d317902de6e0f68689899259caff26 # modified: tmp/cache/assets/CE3/080/sprockets%2F5c3b516e854760f14eda2395c4ff2581 # new file: tmp/cache/assets/CED/B20/sprockets%2F423772fde44ab6f6f861639ee71444c4 # new file: tmp/cache/assets/D0C/E10/sprockets%2F8d1f4b30c6be13017565fe1b697156ce # new file: tmp/cache/assets/D12/290/sprockets%2F93ae21f3cdd5e24444ae4651913fd875 # new file: tmp/cache/assets/D13/FC0/sprockets%2F57aad34b9d3c9e225205237dac9b1999 # new file: tmp/cache/assets/D1D/DE0/sprockets%2F5840ff4283f6545f472be8e10ce67bb8 # new file: tmp/cache/assets/D23/BD0/sprockets%2F439d5dedcc8c54560881edb9f0456819 # new file: tmp/cache/assets/D24/570/sprockets%2Fb449db428fc674796e18b7a419924afe # new file: tmp/cache/assets/D28/480/sprockets%2F9aeec798a04544e478806ffe57e66a51 # new file: tmp/cache/assets/D3A/ED0/sprockets%2Fcd959cbf710b366c145747eb3c062bb4 # new file: tmp/cache/assets/D3C/060/sprockets%2F363ac7c9208d3bb5d7047f11c159d7ce # new file: tmp/cache/assets/D48/D00/sprockets%2Fe23c97b8996e7b5567a3080c285aaccb # new file: tmp/cache/assets/D6A/900/sprockets%2Fa5cece9476b21aa4d5f46911ca96c450 # new file: tmp/cache/assets/D6C/510/sprockets%2Fb086a020de3c258cb1c67dfc9c67d546 # new file: tmp/cache/assets/D70/F30/sprockets%2Facf9a6348722adf1ee7abbb695603078 # new file: tmp/cache/assets/DA3/4A0/sprockets%2F69c26d0a9ca8ce383e20897cefe05aa4 # new file: tmp/cache/assets/DA7/2F0/sprockets%2F61da396fb86c5ecd844a2d83ac759b4b # new file: tmp/cache/assets/DB9/C80/sprockets%2F876fbfb9685b2b8ea476fa3c67ae498b # new file: tmp/cache/assets/DBD/7A0/sprockets%2F3640ea84a1dfaf6f91a01d1d6fbe223d # new file: tmp/cache/assets/DC1/8D0/sprockets%2Fe5ee1f1cfba2144ec00b1dcd6773e691 # new file: tmp/cache/assets/DCC/E60/sprockets%2Fd6a95f601456c93ff9a1bb70dea3dfc0 # new file: tmp/cache/assets/DF1/130/sprockets%2Fcda4825bb42c91e2d1f1ea7b2b958bda # new file: tmp/cache/assets/E23/DE0/sprockets%2Fb1acc25c28cd1fabafbec99d169163d3 # new file: tmp/cache/assets/E23/FD0/sprockets%2Fea3dbcd1f341008ef8be67b1ccc5a9c5 # modified: tmp/cache/assets/E4E/AD0/sprockets%2Fb930f45cfe7c6a8d0efcada3013cc4bc # new file: tmp/cache/assets/E63/7D0/sprockets%2F77de495a665c3ebcb47befecd07baae6 # modified: tmp/pids/server.pid # # Untracked files: # (use \"git add <file>...\" to include in what will be committed) # # Coachbase/ # log/development.log.orig # log/restclient.log.orig What should I do?",
    "answer": "The problem is your previous pull failed to merge automatically and went to conflict state. And the conflict wasn't resolved properly before the next pull. Undo the merge and pull again. To undo a merge: git merge --abort [Since git version 1.7.4] git reset --merge [prior git versions] Resolve the conflict. Don't forget to add and commit the merge. git pull now should work fine."
  },
  {
    "question": "My .gitignore file seems to be being ignored by Git - could the .gitignore file be corrupt? Which file format, locale or culture does Git expect? My .gitignore : # This is a comment debug.log nbproject/ Output from git status : # On branch master # Your branch is ahead of 'origin/master' by 1 commit. # # Untracked files: # (use \"git add <file>...\" to include in what will be committed) # # debug.log # nbproject/ nothing added to commit but untracked files present (use \"git add\" to track) I would like debug.log and nbproject/ not to appear in the untracked files list. Where should I start looking to fix this?",
    "answer": "Fixed. OK, I created the .gitignore file in Notepad on Windows and it wasn't working. When I viewed the .gitignore file on Linux it looked like organised gibberish - perhaps Notepad had written out Unicode rather than ASCII or whatever 8-bit is. So I rewrote the file on my Linux box, and when I pulled it back into Windows it works fine! Hurrah!"
  },
  {
    "question": "I'm new at the branching complexities of Git. I always work on a single branch and commit changes and then periodically push to my remote origin. Somewhere recently, I did a reset of some files to get them out of commit staging, and later did a rebase -i to get rid of a couple recent local commits. Now I'm in a state I don't quite understand. In my working area, git log shows exactly what I'd expect-- I'm on the right train with the commits I didn't want gone, and new ones there, etc. But I just pushed to the remote repository, and what's there is different-- a couple of the commits I'd killed in the rebase got pushed, and the new ones committed locally aren't there. I think \"master/origin\" is detached from HEAD, but I'm not 100% clear on what that means, how to visualize it with the command line tools, and how to fix it.",
    "answer": "First, let’s clarify what HEAD is and what it means when it is detached. HEAD is the symbolic name for the currently checked out commit. When HEAD is not detached (the “normal” 1 situation: you have a branch checked out), HEAD actually points to a branch’s “ref” and the branch points to the commit. HEAD is thus “attached” to a branch. When you make a new commit, the branch that HEAD points to is updated to point to the new commit. HEAD follows automatically since it just points to the branch. git symbolic-ref HEAD yields refs/heads/master The branch named “master” is checked out. git rev-parse refs/heads/master yield 17a02998078923f2d62811326d130de991d1a95a That commit is the current tip or “head” of the master branch. git rev-parse HEAD also yields 17a02998078923f2d62811326d130de991d1a95a This is what it means to be a “symbolic ref”. It points to an object through some other reference. (Symbolic refs were originally implemented as symbolic links, but later changed to plain files with extra interpretation so that they could be used on platforms that do not have symlinks.) We have HEAD → refs/heads/master → 17a02998078923f2d62811326d130de991d1a95a When HEAD is detached, it points directly to a commit—instead of indirectly pointing to one through a branch. You can think of a detached HEAD as being on an unnamed branch. git symbolic-ref HEAD fails with fatal: ref HEAD is not a symbolic ref git rev-parse HEAD yields 17a02998078923f2d62811326d130de991d1a95a Since it is not a symbolic ref, it must point directly to the commit itself. We have HEAD → 17a02998078923f2d62811326d130de991d1a95a The important thing to remember with a detached HEAD is that if the commit it points to is otherwise unreferenced (no other ref can reach it), then it will become “dangling” when you checkout some other commit. Eventually, such dangling commits will be pruned through the garbage collection process (by default, they are kept for at least 2 weeks and may be kept longer by being referenced by HEAD’s reflog). 1 It is perfectly fine to do “normal” work with a detached HEAD, you just have to keep track of what you are doing to avoid having to fish dropped history out of the reflog. The intermediate steps of an interactive rebase are done with a detached HEAD (partially to avoid polluting the active branch’s reflog). If you finish the full rebase operation, it will update your original branch with the cumulative result of the rebase operation and reattach HEAD to the original branch. My guess is that you never fully completed the rebase process; this will leave you with a detached HEAD pointing to the commit that was most recently processed by the rebase operation. To recover from your situation, you should create a branch that points to the commit currently pointed to by your detached HEAD: git branch temp git checkout temp (these two commands can be abbreviated as git checkout -b temp ) This will reattach your HEAD to the new temp branch. Next, you should compare the current commit (and its history) with the normal branch on which you expected to be working: git log --graph --decorate --pretty=oneline --abbrev-commit master origin/master temp git diff master temp git diff origin/master temp (You will probably want to experiment with the log options: add -p , leave off --pretty=… to see the whole log message, etc.) If your new temp branch looks good, you may want to update (e.g.) master to point to it: git branch -f master temp git checkout master (these two commands can be abbreviated as git checkout -B master temp ) You can then delete the temporary branch: git branch -d temp Finally, you will probably want to push the reestablished history: git push origin master You may need to add --force to the end of this command to push if the remote branch can not be “fast-forwarded” to the new commit (i.e. you dropped, or rewrote some existing commit, or otherwise rewrote some bit of history). If you were in the middle of a rebase operation you should probably clean it up. You can check whether a rebase was in process by looking for the directory .git/rebase-merge/ . You can manually clean up the in-progress rebase by just deleting that directory (e.g. if you no longer remember the purpose and context of the active rebase operation). Usually you would use git rebase --abort , but that does some extra resetting that you probably want to avoid (it moves HEAD back to the original branch and resets it back to the original commit, which will undo some of the work we did above)."
  },
  {
    "question": "I have two branches: master and dev I want to create a \"feature branch\" from the dev branch. Currently on the branch dev , I do: git checkout -b myfeature dev ... (some work) git commit -am \"blablabla\" git push origin myfeature But, after visualizing my branches, I got: --**master** ------0-----0-----0-----0-----0 ------------------------**dev**----**myfeature** I mean that the branch seems fast-forward merged, and I don't understand why... What am I doing wrong? How can you branch off from another branch and push back to the remote repository for the feature branch? All that in a branching model like the one described here .",
    "answer": "If you like the method in the link you've posted, have a look at Git Flow . It's a set of scripts he created for that workflow. But to answer your question: git checkout -b myFeature dev Creates the myFeature branch off dev . Do your work and then git commit -am \"Your message\" Now merge your changes to dev without a fast-forward git checkout dev git merge --no-ff myFeature Now push the changes to the server git push origin dev git push origin myFeature And you'll see it how you want it."
  },
  {
    "question": "I have a Git repository that looks like this: A <- B <- C <- D <- HEAD I want the head of the branch to point to A, i.e., I want B, C, D, and HEAD to disappear and I want head to be synonymous with A. It sounds like I can either try to rebase (doesn't apply, since I've pushed changes in between), or revert. But how do I revert multiple commits? Do I revert one at a time? Is the order important?",
    "answer": "Expanding what I wrote in a comment The general rule is that you should not rewrite (change) history that you have published, because somebody might have based their work on it. If you rewrite (change) history, you would make problems with merging their changes and with updating for them. So the solution is to create a new commit which reverts changes that you want to get rid of. You can do this using git revert command. You have the following situation: A <-- B <-- C <-- D <-- master <-- HEAD (arrows here refers to the direction of the pointer: the \"parent\" reference in the case of commits, the top commit in the case of branch head (branch ref), and the name of branch in the case of HEAD reference). What you need to create is the following: A <-- B <-- C <-- D <-- [(BCD) -1 ] <-- master <-- HEAD where [(BCD)^-1] means the commit that reverts changes in commits B, C, D. Mathematics tells us that (BCD) -1 = D -1 C -1 B -1 , so you can get the required situation using the following commands: $ git revert --no-commit D $ git revert --no-commit C $ git revert --no-commit B $ git commit -m \"the commit message for all of them\" Works for everything except merge commits. Alternate solution would be to checkout contents of commit A, and commit this state. Also works with merge commits. Added files will not be deleted, however. If you have any local changes git stash them first: $ git checkout -f A -- . # checkout that revision over the top of local files $ git commit -a Then you would have the following situation: A <-- B <-- C <-- D <-- A' <-- master <-- HEAD The commit A' has the same contents as commit A, but is a different commit (commit message, parents, commit date). Alternate solution by Jeff Ferland, modified by Charles Bailey builds upon the same idea, but uses git reset . Here it is slightly modified, this way WORKS FOR EVERYTHING: $ git reset --hard A $ git reset --soft D # (or ORIG_HEAD or @{1} [previous location of HEAD]), all of which are D $ git commit"
  },
  {
    "question": "I have made a git commit and subsequent push. I would like to change the commit message. If I understand correctly, this is not advisable because someone might have pulled from the remote repository before I make such changes. What if I know that no one has pulled? Is there a way to do this?",
    "answer": "Changing history If it is the most recent commit, you can simply do this: git commit --amend This brings up the editor with the last commit message and lets you edit the message. (You can use -m if you want to wipe out the old message and use a new one.) Pushing And then when you push, do this: git push --force-with-lease <repository> <branch> Or you can use \"+\": git push <repository> +<branch> Or you can use --force : git push --force <repository> <branch> Be careful when using these commands. If someone else pushed changes to the same branch, you probably want to avoid destroying those changes. The --force-with-lease option is the safest, because it will abort if there are any upstream changes ( If you don't specify the branch explicitly, Git will use the default push settings. If your default push setting is \"matching\", then you may destroy changes on several branches at the same time. Pulling / fetching afterwards Anyone who already pulled will now get an error message, and they will need to update (assuming they aren't making any changes themselves) by doing something like this: git fetch origin git reset --hard origin/master # Loses local commits Be careful when using reset --hard . If you have changes to the branch, those changes will be destroyed. A note about modifying history The destroyed data is really just the old commit message, but --force doesn't know that, and will happily delete other data too. So think of --force as \"I want to destroy data, and I know for sure what data is being destroyed.\" But when the destroyed data is committed, you can often recover old commits from the reflog—the data is actually orphaned instead of destroyed (although orphaned commits are periodically deleted). If you don't think you're destroying data, then stay away from --force ... bad things might happen . This is why --force-with-lease is somewhat safer."
  },
  {
    "question": "How can I delete a single directory containing files from a Git repository?",
    "answer": "Remove directory from Git and local Checkout 'master' with both directories: git rm -r one-of-the-directories // This deletes from filesystem git commit . -m \"Remove duplicated directory\" git push origin <your-git-branch> (typically 'master', but not always) Remove directory from Git but NOT local To remove this directory from Git, but not delete it entirely from the filesystem (local): git rm -r --cached myFolder"
  },
  {
    "question": "When using git log , how can I filter by user so that I see only commits from that user?",
    "answer": "This works for both git log and gitk - the 2 most common ways of viewing history. You don't need to use the whole name: git log --author=\"Jon\" will match a commit made by \"Jonathan Smith\" git log --author=Jon and git log --author=Smith would also work. The quotes are optional if you don't need any spaces. Add --all if you intend to search all branches and not just the current commit's ancestors in your repo. You can also easily match on multiple authors as regex is the underlying mechanism for this filter. So to list commits by Jonathan or Adam, you can do this: git log --author=\"\\(Adam\\)\\|\\(Jon\\)\" In order to exclude commits by a particular author or set of authors using regular expressions as noted in this question , you can use a negative lookahead in combination with the --perl-regexp switch: git log --author='^(?!Adam|Jon).*$' --perl-regexp Alternatively, you can exclude commits authored by Adam by using bash and piping: git log --format='%H %an' | grep -v Adam | cut -d ' ' -f1 | xargs -n1 git log -1 If you want to exclude commits commited (but not necessarily authored) by Adam, replace %an with %cn . More details about this are in my blog post here: http://dymitruk.com/blog/2012/07/18/filtering-by-author-name/"
  },
  {
    "question": "Is it possible to undo the changes caused by the following command? If so, how? git reset --hard HEAD~1",
    "answer": "Pat Notz is correct. You can get the commit back so long as it's been within a few days. git only garbage collects after about a month or so unless you explicitly tell it to remove newer blobs. $ git init Initialized empty Git repository in .git/ $ echo \"testing reset\" > file1 $ git add file1 $ git commit -m 'added file1' Created initial commit 1a75c1d: added file1 1 files changed, 1 insertions(+), 0 deletions(-) create mode 100644 file1 $ echo \"added new file\" > file2 $ git add file2 $ git commit -m 'added file2' Created commit f6e5064: added file2 1 files changed, 1 insertions(+), 0 deletions(-) create mode 100644 file2 $ git reset --hard HEAD^ HEAD is now at 1a75c1d... added file1 $ cat file2 cat: file2: No such file or directory $ git reflog 1a75c1d... HEAD@{0}: reset --hard HEAD^: updating HEAD f6e5064... HEAD@{1}: commit: added file2 $ git reset --hard f6e5064 HEAD is now at f6e5064... added file2 $ cat file2 added new file You can see in the example that the file2 was removed as a result of the hard reset, but was put back in place when I reset via the reflog."
  },
  {
    "question": "I have a Git repository with n commits. I have a file that I need, and that used to be in the repository, and that I suddenly look for and think \"Oh! Where'd that file go?\" Is there a (series of) Git command(s) that will tell me that \"file really_needed.txt was deleted at commit n-13\"? In other words, without looking at every individual commit, and knowing that my Git repo has every change of every file, can I quickly find the last commit that HAS that file, so I can get it back?",
    "answer": "To show the commits that changed a file, even if the file was deleted, run this command: git log --all -- [file path] If you want to see only the last commit, which deleted the file, use -1 in addition to the command above: git log --all -1 -- [file path] NOTE: git log --full-history -- [file path] does NOT work in git version 2.42.0) See also my article: Which commit deleted a file ."
  },
  {
    "question": "I created a Git repository with git init . I'd like to delete it entirely and initialise a new one.",
    "answer": "Git keeps all of its files in the .git directory. Just remove that one and initialise again. If you can't find it, it's because it is hidden. In Windows 7 , you need to go to your folder, click on Organize on the top left, then click on Folder and search options , then click on the View tab and click on the Show hidden files, folders and drives radio button. On a Mac OS X: Open a Terminal instance (via Spotlight : press CMD + SPACE , type terminal and press Enter ) and run: defaults write com.apple.finder AppleShowAllFiles 1 && killall Finder Note: The keyboard shortcut to show hidden files in Finder is CMD + SHIFT + . , so it isn't necessary any longer to modify the Finder configuration this way You could also type cd (the space is important), drag and drop your Git repository folder from Finder to the terminal window, press return , type rm -fr .git , and then return again. On Ubuntu ( Linux ), use shortcut Ctrl + H ."
  }
]