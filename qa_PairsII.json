[
  {
    "question": "I accidentally committed the wrong files to\nGit\n but haven't pushed the commit to the server yet.\nHow do I undo those commits from the\nlocal\n repository?",
    "answer": "Undo a commit & redo\n$ git commit -m \"Something terribly misguided\" # (0: Your Accident)\n$ git reset HEAD~                              # (1)\n# === If you just want to undo the commit, stop here! ===\n[ edit files as necessary ]                    # (2)\n$ git add .                                    # (3)\n$ git commit -c ORIG_HEAD                      # (4)\ngit reset\n is the command responsible for the\nundo\n. It will undo your last commit while\nleaving your working tree (the state of your files on disk) untouched.\n You'll need to add them again before you can commit them again.\nMake corrections to\nworking tree\n files.\ngit add\n anything that you want to include in your new commit.\nCommit the changes, reusing the old commit message.\nreset\n copied the old head to\n.git/ORIG_HEAD\n;\ncommit\n with\n-c ORIG_HEAD\n will open an editor, which initially contains the log message from the old commit and allows you to edit it. If you do not need to edit the message, you could use the\n-C\n option.\nAlternatively, to edit the previous commit (or just its commit message)\n,\ncommit --amend\n will add changes within the current index to the previous commit.\nTo remove (not revert) a commit that has been pushed to the server\n, rewriting history with\ngit push origin main --force[-with-lease]\n is necessary.\nIt's\nalmost always\n a bad idea to use\n--force\n; prefer\n--force-with-lease\n instead, and as noted in\nthe git manual\n:\nYou should understand the implications of rewriting history if you amend a commit that has already been published.\nFurther Reading\nYou can use\ngit reflog\n to determine the SHA-1\n for the commit to which you wish to revert. Once you have this value, use the sequence of commands as explained above.\nHEAD~\n is the same as\nHEAD~1\n. The article\nWhat is the HEAD in git?\n is helpful if you want to uncommit multiple commits."
  },
  {
    "question": "Failed Attempts to Delete a Remote Branch:\n$ git branch -d remotes/origin/bugfix\nerror: branch 'remotes/origin/bugfix' not found.\n$ git branch -d origin/bugfix\nerror: branch 'origin/bugfix' not found.\n$ git branch -rd origin/bugfix\nDeleted remote branch origin/bugfix (was 2a14ef7).\n$ git push\nEverything up-to-date\n$ git pull\nFrom github.com:gituser/gitproject\n* [new branch] bugfix -> origin/bugfix\nAlready up-to-date.\nHow do I properly delete the\nremotes/origin/bugfix\n branch both locally and remotely?",
    "answer": "Executive Summary\ngit push -d <remote_name> <branchname>   # Delete remote\ngit branch -d <branchname>               # Delete local\nNote:\n In most cases,\n<remote_name>\n will be\norigin\n.\nDelete Local Branch\nTo delete the\nlocal\n branch, use one of the following:\ngit branch -d <branch_name>\ngit branch -D <branch_name>\nThe\n-d\n option is an alias for\n--delete\n, which only deletes the branch if it has already been fully merged in its upstream branch.\nThe\n-D\n option is an alias for\n--delete --force\n, which deletes the branch \"irrespective of its merged status.\" [Source:\nman git-branch\n]\nAs of\nGit v2.3\n,\ngit branch -d\n (delete) learned to honor the\n-f\n (force) flag.\nYou will receive an error if you try to delete the currently selected branch.\nDelete Remote Branch\nAs of\nGit v1.7.0\n, you can delete a\nremote\n branch using\n$ git push <remote_name> --delete <branch_name>\nwhich might be easier to remember than\n$ git push <remote_name> :<branch_name>\nwhich was added in\nGit v1.5.0\n \"to delete a remote branch or a tag.\"\nStarting with\nGit v2.8.0\n, you can also use\ngit push\n with the\n-d\n option as an alias for\n--delete\n. Therefore, the version of Git you have installed will dictate whether you need to use the easier or harder syntax.\nDelete Remote Branch [Original Answer from 5-Jan-2010]\nFrom Chapter 3 of\nPro Git\n by Scott Chacon:\nDeleting Remote Branches\nSuppose you’re done with a remote branch — say, you and your collaborators are finished with a feature and have merged it into your remote’s main branch (or whatever branch your stable code-line is in). You can delete a remote branch using the rather obtuse syntax\ngit push [remotename] :[branch]\n. If you want to delete your\nserverfix\n branch from the server, you run the following:\n$ git push origin :serverfix\nTo git@github.com:schacon/simplegit.git\n - [deleted]         serverfix\nBoom. No more branches on your server. You may want to dog-ear this page, because you’ll need that command, and you’ll likely forget the syntax. A way to remember this command is by recalling the\ngit push [remotename] [localbranch]:[remotebranch]\n syntax that we went over a bit earlier. If you leave off the\n[localbranch]\n portion, then you’re basically saying, “Take nothing on my side and make it be\n[remotebranch]\n.”\nI ran\ngit push origin :bugfix\n, and it worked beautifully. Scott Chacon was right—I will want to\ndog-ear\n that page (or virtually dog ear-by answering this on Stack Overflow).\nFetch changes\nFinally, execute the following on other machines to propagate changes:\n# Fetch changes from all remotes and locally delete\n# remote deleted branches/tags etc\n# --prune will do the job :-;\ngit fetch --all --prune"
  },
  {
    "question": "What are the differences between\ngit pull\n and\ngit fetch\n?",
    "answer": "In the simplest terms,\ngit pull\n does a\ngit fetch\n followed by a\ngit merge\n.\ngit fetch\n updates your remote-tracking branches under\nrefs/remotes/<remote>/\n. This operation is safe to run at any time since it never changes any of your local branches under\nrefs/heads\n.\ngit pull\n brings a local branch up-to-date with its remote version, while also updating your other remote-tracking branches.\nFrom the Git documentation for\ngit pull\n:\ngit pull\n runs\ngit fetch\n with the given parameters and then depending on configuration options or command line flags, will call either\ngit rebase\n or\ngit merge\n to reconcile diverging branches."
  },
  {
    "question": "How can I rename a local branch which has not yet been pushed to a remote repository?\nRelated:\nRename master branch for both local and remote Git repositories\nHow do I rename both a Git local and remote branch name?",
    "answer": "To rename the current branch:\ngit branch -m <newname>\nTo rename a branch while pointed to any branch:\ngit branch -m <oldname> <newname>\n-m\n is short for\n--move\n.\nTo push the  local branch and reset the upstream branch:\ngit push origin -u <newname>\nTo delete the  remote branch:\ngit push origin --delete <oldname>\nTo create a\ngit rename\n alias:\ngit config --global alias.rename 'branch -m'\nOn Windows or another case-insensitive filesystem, use\n-M\n if there are only capitalization changes in the name. Otherwise, Git will throw a\n\"branch already exists\"\n error.\ngit branch -M <newname>"
  },
  {
    "question": "I mistakenly added files to Git using the command:\ngit add myfile.txt\nI have not yet run\ngit commit\n. How do I undo this so that these changes will not be included in the commit?",
    "answer": "To unstage a specific file\ngit reset <file>\nThat will remove the file from the current index (the \"about to be committed\" list) without changing anything else.\nTo unstage all files from the current change set:\ngit reset\nIn old versions of Git, the above commands are equivalent to\ngit reset HEAD <file>\n and\ngit reset HEAD\n respectively, and will fail if\nHEAD\n is undefined (because you haven't yet made any commits in your repository) or ambiguous (because you created a branch called\nHEAD\n, which is a stupid thing that you shouldn't do). This\nwas changed in Git 1.8.2\n, though, so in modern versions of Git you can use the commands above even prior to making your first commit:\n\"git reset\" (without options or parameters) used to error out when\nyou do not have any commits in your history, but it now gives you\nan empty index (to match non-existent commit you are not even on).\nDocumentation:\ngit reset"
  },
  {
    "question": "How do I force an overwrite of local files on a\ngit pull\n? My local repository contains a file of the same filename as on the server.\nerror: Untracked working tree file 'example.txt' would be overwritten by merge",
    "answer": "⚠ Warning:\nAny uncommitted local change to tracked files will be lost,\neven if staged\n.\nBut any local file that's\nnot\n tracked by Git will\nnot\n be affected.\nFirst, update all\norigin/<branch>\n refs to latest:\ngit fetch --all\nBackup your current branch (e.g.\nmain\n):\ngit branch backup-main\nJump to the latest commit on\norigin/main\n and checkout those files:\ngit reset --hard origin/main\nExplanation:\ngit fetch\n downloads the latest from remote without trying to merge or rebase anything.\ngit reset\n resets the master branch to what you just fetched. The\n--hard\n option changes all the files in your working tree to match the files in\norigin/main\n.\nMaintain current local commits\n[*]\n: It's worth noting that it is possible to maintain current local commits by creating a branch from\nmain\n before resetting:\ngit checkout main\ngit branch new-branch-to-save-current-commits\ngit fetch --all\ngit reset --hard origin/main\nAfter this, all of the old commits will be kept in\nnew-branch-to-save-current-commits\n.\nUncommitted changes\nUncommitted changes, even if staged (with\ngit add\n), will be lost. Make sure to\nstash\n or commit anything you need. For example, run the following:\ngit stash\nAnd later (after\ngit reset\n), reapply these uncommitted changes:\ngit stash pop\nWhich may create merge conflicts."
  },
  {
    "question": "How do I check out the remote\ntest\n branch? I can see it with\ngit branch -r\n. I tried:\ngit checkout test\n, which does nothing\ngit checkout origin/test\n gives\n* (no branch)",
    "answer": "The answer has been split depending on whether there is one remote repository configured or multiple. The reason for this is that for the single remote case, some of the commands can be simplified as there is less ambiguity.\nUpdated for Git 2.23:\n For older versions, see the section at the end.\nWith One Remote\nIn both cases, start by fetching from the remote repository to make sure you have all the latest changes downloaded.\n$ git fetch\nThis will fetch all of the remote branches for you. You can see the branches available for checkout with:\n$ git branch -v -a\n...\nremotes/origin/test\nThe branches that start with\nremotes/*\n can be thought of as read only copies of the remote branches. To work on a branch you need to create a local branch from it. This is done with the Git command\nswitch\n (since Git 2.23) by giving it the name of the remote branch (minus the remote name):\n$ git switch test\nIn this case Git is guessing (can be disabled with\n--no-guess\n) that you are trying to checkout and track the remote branch with the same name.\nWith Multiple Remotes\nIn the case where multiple remote repositories exist, the remote repository needs to be explicitly named.\nAs before, start by fetching the latest remote changes:\n$ git fetch origin\nThis will fetch all of the remote branches for you. You can see the branches available for checkout with:\n$ git branch -v -a\nWith the remote branches in hand, you now need to check out the branch you are interested in with\n-c\n to create a new local branch:\n$ git switch -c test origin/test\nFor more information about using\ngit switch\n:\n$ man git-switch\nPrior to Git 2.23\ngit switch\n was added in Git 2.23, prior to this\ngit checkout\n was used to switch branches.\nTo checkout out with only a single remote repository:\ngit checkout test\nif there are multiple remote repositories configured then it becomes a bit longer\ngit checkout -b test <name of remote>/test"
  },
  {
    "question": "I put a file that was previously being tracked by Git onto the\n.gitignore\n list. However, the file still shows up in\ngit status\n after it is edited. How do I force Git to completely forget the file?",
    "answer": ".gitignore\n will prevent untracked files from being added (without an\nadd -f\n) to the set of files tracked by Git. However, Git will continue to track any files that are already being tracked.\nUpdated Answer in 2024\nDo NOT use\ngit rm --cached <file>\n if you ever want to see that file again. It will remove it from git, and also your local machine.\nIf you want to keep the file locally, but remove it from git tracking, use the answer by Konstantin. In short, use the following instead of\ngit rm\n:\ngit update-index --skip-worktree <file>\nHowever, according to the official\ngit documentation\n:\nUsers often try to use the assume-unchanged and skip-worktree bits to tell Git to ignore changes to files that are tracked. This does not work as expected, since Git may still check working tree files against the index when performing certain operations. In general, Git does not provide a way to ignore changes to tracked files, so alternate solutions are recommended.\nTherefore, you should still consider using the original answer below.\nOriginal Answer\nWARNING: This will remove the physical file from your local machine and other developers' machines on your or their next\ngit pull\n.\nTo stop tracking a file, we must remove it from the index:\ngit rm --cached <file>\nTo remove a folder and all files in the folder recursively:\ngit rm -r --cached <folder>\nThe removal of the file from the head revision will happen on the next commit."
  },
  {
    "question": "How do I delete untracked local files from the current working tree?",
    "answer": "git-clean\n - Remove untracked files from the working tree\nSynopsis\ngit clean [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] <path>…​\nDescription\nCleans the working tree by recursively removing files that are not under version control,\nstarting from the current directory\n.\nNormally, only files unknown to Git are removed, but if the\n-x\n option is specified, ignored files are also removed. This can, for example, be useful to remove all build products.\nIf any optional\n<path>...\n arguments are given, only those paths are affected.\nStep 1 is to show what will be deleted by using the\n-n\n option:\n# Print out the list of files and directories which will be removed (dry run)\ngit clean -n -d\nClean Step -\nbeware: this will delete files\n:\n# Delete the files from the repository\ngit clean -f\nTo remove directories, run\ngit clean -f -d\n or\ngit clean -fd\nTo remove ignored files, run\ngit clean -f -X\n or\ngit clean -fX\nTo remove ignored and non-ignored files, run\ngit clean -f -x\n or\ngit clean -fx\nNote\n the case difference on the\nX\n for the two latter commands.\nIf\nclean.requireForce\n is set to \"true\" (the default) in your configuration, one needs to specify\n-f\n otherwise nothing will actually happen.\nAgain see the\ngit-clean\n docs for more information.\nOptions\n-f\n,\n--force\nIf the Git configuration variable clean.requireForce is not set to\nfalse, git clean will refuse to run unless given\n-f\n,\n-n\n or\n-i\n.\n-x\nDon’t use the standard ignore rules read from .gitignore (per\ndirectory) and\n$GIT_DIR/info/exclude\n, but do still use the ignore\nrules given with\n-e\n options. This allows removing all untracked files,\nincluding build products. This can be used (possibly in conjunction\nwith git reset) to create a pristine working directory to test a clean\nbuild.\n-X\nRemove only files ignored by Git. This may be useful to rebuild\neverything from scratch, but keep manually created files.\n-n\n,\n--dry-run\nDon’t actually remove anything, just show what would be done.\n-d\nRemove untracked directories in addition to untracked files. If an\nuntracked directory is managed by a different Git repository, it is\nnot removed by default. Use\n-f\n option twice if you really want to\nremove such a directory."
  },
  {
    "question": "How do I find all files containing a specific string of text within their file contents?\nThe following doesn't work. It seems to display every single file in the system.\nfind / -type f -exec grep -H 'text-to-find-here' {} \\;",
    "answer": "Do the following:\ngrep -rnw '/path/to/somewhere/' -e 'pattern'\n-r\n or\n-R\n is recursive,\n-n\n is line number, and\n-w\n stands for match the whole word.\n-l\n (lower-case L) can be added to just give the file name of matching files.\n-e\n is the pattern used during the search\nAlong with these,\n--exclude\n,\n--include\n,\n--exclude-dir\n flags could be used for efficient searching:\nThis will only search through those files which have .c or .h extensions:\ngrep --include=\\*.{c,h} -rnw '/path/to/somewhere/' -e \"pattern\"\nThis will exclude searching all the files ending with .o extension:\ngrep --exclude=\\*.o -rnw '/path/to/somewhere/' -e \"pattern\"\nFor directories it's possible to exclude one or more directories using the\n--exclude-dir\n parameter. For example, this will exclude the dirs\ndir1/\n,\ndir2/\n and all of them matching\n*.dst/\n:\ngrep --exclude-dir={dir1,dir2,*.dst} -rnw '/path/to/search/' -e \"pattern\"\nThis works very well for me, to achieve almost the same purpose like yours.\nFor more options, see\nman grep\n."
  },
  {
    "question": "I wrote the wrong thing in a commit message.\nHow can I change the message? The commit has not been pushed yet.",
    "answer": "Amending the most recent commit message\ngit commit --amend\nwill open your editor, allowing you to change the commit message of the most recent commit. Additionally, you can set the commit message directly in the command line with:\ngit commit --amend -m \"New commit message\"\n…however, this can make multi-line commit messages or small corrections more cumbersome to enter.\nMake sure you don't have any working copy changes\nstaged\n before doing this or they will get committed too. (\nUnstaged\n changes will not get committed.)\nChanging the message of a commit that you've already pushed to your remote branch\nIf you've already pushed your commit up to your remote branch, then - after amending your commit locally (as described above) - you'll also\nneed to force push the commit\n with:\ngit push <remote> <branch> --force\n# Or\ngit push <remote> <branch> -f\nWarning: force-pushing will overwrite the remote branch with the state of your local one\n. If there are commits on the remote branch that you don't have in your local branch, you\nwill\n lose those commits.\nWarning: be cautious about amending commits that you have already shared with other people.\n Amending commits essentially\nrewrites\n them to have different\nSHA\n IDs, which poses a problem if other people have copies of the old commit that you've rewritten. Anyone who has a copy of the old commit will need to synchronize their work with your newly re-written commit, which can sometimes be difficult, so make sure you coordinate with others when attempting to rewrite shared commit history, or just avoid rewriting shared commits altogether.\nPerform an interactive rebase\nAnother option is to use interactive rebase.\nThis allows you to edit any message you want to update even if it's not the latest message.\nIn order to do a Git squash, follow these steps:\n// n is the number of commits up to the last commit you want to be able to edit\ngit rebase -i HEAD~n\nOnce you squash your commits - choose the\ne/r\n for editing the message:\nImportant note about interactive rebase\nWhen you use\ngit rebase -i HEAD~n\n there can be\nmore\n than n commits. Git will \"collect\" all the commits in the last n commits, and if there was a merge somewhere in between that range you will see all the commits as well, so the outcome will be n + .\nGood tip:\nIf you have to do it for more than a single branch and you might face conflicts when amending the content, set up\ngit rerere\n and let Git resolve those conflicts automatically for you.\nDocumentation\ngit-commit(1) Manual Page\ngit-rebase(1) Manual Page\ngit-push(1) Manual Page"
  },
  {
    "question": "How do I revert from my current state to a snapshot made on a certain commit?\nIf I do\ngit log\n, then I get the following output:\n$ git log\ncommit a867b4af366350be2e7c21b8de9cc6504678a61b`\nAuthor: Me <me@me.com>\nDate:   Thu Nov 4 18:59:41 2010 -0400\nblah blah blah...\ncommit 25eee4caef46ae64aa08e8ab3f988bc917ee1ce4\nAuthor: Me <me@me.com>\nDate:   Thu Nov 4 05:13:39 2010 -0400\nmore blah blah blah...\ncommit 0766c053c0ea2035e90f504928f8df3c9363b8bd\nAuthor: Me <me@me.com>\nDate:   Thu Nov 4 00:55:06 2010 -0400\nAnd yet more blah blah...\ncommit 0d1d7fc32e5a947fbd92ee598033d85bfc445a50\nAuthor: Me <me@me.com>\nDate:   Wed Nov 3 23:56:08 2010 -0400\nYep, more blah blah.\nHow do I revert to the commit from November 3, i.e. commit\n0d1d7fc\n?",
    "answer": "This depends a lot on what you mean by \"revert\".\nTemporarily switch to a different commit\nIf you want to temporarily go back to it, fool around, then come back to where you are, all you have to do is check out the desired commit:\n# This will detach your HEAD, that is, leave you with no branch checked out:\ngit checkout 0d1d7fc32\nOr if you want to make commits while you're there, go ahead and make a new branch while you're at it:\ngit checkout -b old-state 0d1d7fc32\nTo go back to where you were, just check out the branch you were on again. (If you've made changes, as always when switching branches, you'll have to deal with them as appropriate. You could reset to throw them away; you could stash, checkout, stash pop to take them with you; you could commit them to a branch there if you want a branch there.)\nHard delete unpublished commits\nIf, on the other hand, you want to really get rid of everything you've done since then, there are two possibilities. One, if you haven't published any of these commits, simply reset:\n# This will destroy any local modifications.\n# Don't do it if you have uncommitted work you want to keep.\ngit reset --hard 0d1d7fc32\n# Alternatively, if there's work to keep:\ngit stash\ngit reset --hard 0d1d7fc32\ngit stash pop\n# This saves the modifications, then reapplies that patch after resetting.\n# You could get merge conflicts, if you've modified things which were\n# changed since the commit you reset to.\nIf you mess up, you've already thrown away your local changes, but you can at least get back to where you were before by resetting again.\nUndo published commits with new commits\nOn the other hand, if you've published the work, you probably don't want to reset the branch, since that's effectively rewriting history. In that case, you could indeed revert the commits. In many enterprise organisations, the concept of \"protected\" branches will even prevent history from being rewritten on some major branches. In this case, reverting is your only option.\nWith Git, revert has a very specific meaning: create a commit with the reverse patch to cancel it out. This way you don't rewrite any history.\nFirst figure out what commits to revert. Depending on the technique chosen below, you want to either revert only the merge commits, or only the non-merge commits.\n# This lists all merge commits between 0d1d7fc and HEAD:\ngit log --merges --pretty=format:\"%h\" 0d1d7fc..HEAD | tr '\\n' ' '\n# This lists all non merge commits between 0d1d7fc and HEAD:\ngit log --no-merges --pretty=format:\"%h\" 0d1d7fc..HEAD | tr '\\n' ' '\nNote: if you revert multiple commits, the order matters. Start with the most recent commit.\n# This will create three separate revert commits, use non merge commits only:\ngit revert a867b4af 25eee4ca 0766c053\n# It also takes ranges. This will revert the last two commits:\ngit revert HEAD~2..HEAD\n# Similarly, you can revert a range of commits using commit hashes (non inclusive of first hash):\ngit revert 0d1d7fc..a867b4a\n# Reverting a merge commit. You can also use a range of merge commits here.\ngit revert -m 1 <merge_commit_sha>\n# To get just one, you could use `rebase -i` to squash them afterwards\n# Or, you could do it manually (be sure to do this at top level of the repo)\n# get your index and work tree into the desired state, without changing HEAD:\ngit checkout 0d1d7fc32 .\n# Then commit. Be sure and write a good message describing what you just did\ngit commit\nThe\ngit-revert\n manpage\n actually covers a lot of this in its description. Another useful link is\nthis git-scm.com section discussing git-revert\n.\nIf you decide you didn't want to revert after all, you can revert the revert (as described here) or reset back to before the revert (see the previous section).\nYou may also find this answer helpful in this case:\nHow can I move HEAD back to a previous location? (Detached head) & Undo commits"
  },
  {
    "question": "I have a repo (origin) on a USB key that I cloned on my hard drive (local). I moved \"origin\" to a NAS and successfully tested cloning it from here.\nI would like to know if I can change the URI of \"origin\" in the settings of \"local\" so it will now pull from the NAS, and not from the USB key.\nFor now, I can see two solutions:\npush everything to the USB origin, and copy it to the NAS again (implies a lot of work due to new commits to NAS origin);\nadd a new remote to \"local\" and delete the old one (I fear I'll break my history).",
    "answer": "First, view the existing remotes to verify which URL is currently set:\ngit remote -v\nThen, you can set it with:\ngit remote set-url origin <NEW_GIT_URL_HERE>\nSee\ngit help remote\n. You also can edit\n.git/config\n and change the URLs there.\nYou're not in any danger of losing history unless you do something very silly (and if you're worried, just make a copy of your repo, since your repo\nis\n your history.)"
  },
  {
    "question": "How do I move my recent commits on\nmaster\n to a new branch, and reset master to before those commits were made? e.g. From this:\nmaster A - B - C - D - E\nTo this:\nnewbranch     C - D - E\n             /\nmaster A - B",
    "answer": "WARNING: You\nneed to store uncommitted edits\n to your stash before doing this, using\ngit stash\n. Once complete, you can retrieve the stashed uncommitted edits with\ngit stash pop\n.\ngit reset hard command will remove all changes!\nMoving to an existing branch\nIf you want to move your commits to an\nexisting branch\n, it will look like this:\ngit checkout existingbranch\ngit merge branchToMoveCommitFrom\ngit checkout branchToMoveCommitFrom\ngit reset --hard HEAD~3 # Go back 3 commits. You *will* lose uncommitted work.\ngit checkout existingbranch\nMoving to a new branch\nWARNING:\n This method works because you are creating a new branch with the first command:\ngit branch newbranch\n. If you want to move commits to an\nexisting branch\n you need to merge your changes into the existing branch before executing\ngit reset --hard HEAD~3\n (see\nMoving to an existing branch\n above).\nIf you don't merge your changes first, they will be lost.\nUnless there are other circumstances involved, this can be easily done by branching and rolling back.\n# Note: Any changes not committed will be lost.\ngit branch newbranch      # Create a new branch, saving the desired commits\ngit checkout master       # checkout master, this is the place you want to go back\ngit reset --hard HEAD~3   # Move master back by 3 commits (Make sure you know how many commits you need to go back)\ngit checkout newbranch    # Go to the new branch that still has the desired commits\nBut do make sure how many commits to go back. Alternatively, you can instead of\nHEAD~3\n, simply provide the hash of the commit (or the reference like\norigin/master\n) you want to \"revert back to\" on the\nmaster\n (/current) branch, e.g:\ngit reset --hard a1b2c3d4\nNote:\n You will\nonly\n be \"losing\" commits from the master branch, but don't worry, you'll have those commits in newbranch! An easy way to check that, after completing the 4 step sequence of commands above, is by looking at\ngit log -n4\n which will show the history of newbranch actually retained the 3 commits (and the reason is that newbranch was created at the time those changes were already commited on master!). They have only been removed from master, as\ngit reset\n only affected the branch that was checked out at the time of its execution, i.e. master (see\ngit reset\n description:\nReset\ncurrent\n HEAD to the specified state\n).\ngit status\n however will not show any checkouts on the newbranch, which might be surprising at first but that is actually expected.\nLastly,\nyou may need\n to force push your latest changes to main repo:\ngit push origin master --force\nWARNING:\n With Git version 2.0 and later, if you later\ngit rebase\n the new branch upon the original (\nmaster\n) branch, you may need an explicit\n--no-fork-point\n option during the rebase to avoid losing the carried-over commits.  Having\nbranch.autosetuprebase always\n set makes this more likely.  See\nJohn Mellor's answer\n for details."
  },
  {
    "question": "How do I discard changes in my working copy that are not in the index?",
    "answer": "Another quicker way is:\ngit stash save --keep-index --include-untracked\nYou don't need to include\n--include-untracked\n if you don't want to be thorough about it.\nAfter that, you can drop that stash with a\ngit stash drop\n command if you like."
  },
  {
    "question": "How do I get the path of the directory in which a\nBash\n script is located,\ninside\n that script?\nI want to use a Bash script as a launcher for another application. I want to change the working directory to the one where the Bash script is located, so I can operate on the files in that directory, like so:\n$ ./application",
    "answer": "#!/usr/bin/env bash\nSCRIPT_DIR=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\nis a useful one-liner which will give you the full directory name of the script no matter where it is being called from.\nIt will work as long as the last component of the path used to find the script is not a symlink (directory links are OK).  If you also want to resolve any links to the script itself, you need a multi-line solution:\n#!/usr/bin/env bash\nget_script_dir()\n{\n    local SOURCE_PATH=\"${BASH_SOURCE[0]}\"\n    local SYMLINK_DIR\n    local SCRIPT_DIR\n    # Resolve symlinks recursively\n    while [ -L \"$SOURCE_PATH\" ]; do\n        # Get symlink directory\n        SYMLINK_DIR=\"$( cd -P \"$( dirname \"$SOURCE_PATH\" )\" >/dev/null 2>&1 && pwd )\"\n        # Resolve symlink target (relative or absolute)\n        SOURCE_PATH=\"$(readlink \"$SOURCE_PATH\")\"\n        # Check if candidate path is relative or absolute\n        if [[ $SOURCE_PATH != /* ]]; then\n            # Candidate path is relative, resolve to full path\n            SOURCE_PATH=$SYMLINK_DIR/$SOURCE_PATH\n        fi\n    done\n    # Get final script directory path from fully resolved source path\n    SCRIPT_DIR=\"$(cd -P \"$( dirname \"$SOURCE_PATH\" )\" >/dev/null 2>&1 && pwd)\"\n    echo \"$SCRIPT_DIR\"\n}\necho \"get_script_dir: $(get_script_dir)\"\nThis last one will work with any combination of aliases,\nsource\n,\nbash -c\n, symlinks, etc.\nBeware:\n if you\ncd\n to a different directory before running this snippet, the result may be incorrect!\nAlso, watch out for\n$CDPATH\n gotchas\n, and stderr output side effects if the user has smartly overridden cd to redirect output to stderr instead (including escape sequences, such as when calling\nupdate_terminal_cwd >&2\n on Mac). Adding\n>/dev/null 2>&1\n at the end of your\ncd\n command will take care of both possibilities.\nTo understand how it works, try running this more verbose form:\n#!/usr/bin/env bash\nSOURCE=${BASH_SOURCE[0]}\nwhile [ -L \"$SOURCE\" ]; do # resolve $SOURCE until the file is no longer a symlink\n  TARGET=$(readlink \"$SOURCE\")\n  if [[ $TARGET == /* ]]; then\n    echo \"SOURCE '$SOURCE' is an absolute symlink to '$TARGET'\"\n    SOURCE=$TARGET\n  else\n    DIR=$( dirname \"$SOURCE\" )\n    echo \"SOURCE '$SOURCE' is a relative symlink to '$TARGET' (relative to '$DIR')\"\n    SOURCE=$DIR/$TARGET # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located\n  fi\ndone\necho \"SOURCE is '$SOURCE'\"\nRDIR=$( dirname \"$SOURCE\" )\nDIR=$( cd -P \"$( dirname \"$SOURCE\" )\" >/dev/null 2>&1 && pwd )\nif [ \"$DIR\" != \"$RDIR\" ]; then\n  echo \"DIR '$RDIR' resolves to '$DIR'\"\nfi\necho \"DIR is '$DIR'\"\nAnd it will print something like:\nSOURCE './scriptdir.sh' is a relative symlink to 'sym2/scriptdir.sh' (relative to '.')\nSOURCE is './sym2/scriptdir.sh'\nDIR './sym2' resolves to '/home/ubuntu/dotfiles/fo fo/real/real1/real2'\nDIR is '/home/ubuntu/dotfiles/fo fo/real/real1/real2'"
  },
  {
    "question": "How do I reset my local branch to be just like the branch on the remote repository?\nI tried:\ngit reset --hard HEAD\nBut\ngit status\n claims I have modified files:\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n      modified:   java/com/mycompany/TestContacts.java\n      modified:   java/com/mycompany/TestParser.java",
    "answer": "Setting your branch to exactly match the remote branch can be done in two steps:\ngit fetch origin\ngit reset --hard origin/master\nIf your default branch is\nmain\n (GitHub changed the default branch name from\nmaster\n to\nmain\nstarting October 1, 2020\n):\ngit reset --hard origin/main\nIf you want to save your current branch's state before doing this (just in case), you can do:\ngit commit -a -m \"Saving my work, just in case\"\ngit branch my-saved-work\nNow your work is saved on the branch \"my-saved-work\" in case you decide you want it back (or want to look at it later or diff it against your updated branch).\nNote that the first example assumes that the remote repo's name is \"origin\" and that the branch named \"master\" in the remote repo matches the currently checked-out branch in your local repo.\nBTW, this situation that you're in looks an awful lot like a common case where a push has been done into the currently checked out branch of a non-bare repository. Did you recently push into your local repo? If not, then no worries -- something else must have caused these files to unexpectedly end up modified. Otherwise, you should be aware that it's not recommended to push into a non-bare repository (and not into the currently checked-out branch, in particular)."
  },
  {
    "question": "How can I revert a modified file to its previous revision at a specific commit hash (which I determined via\ngit log\n and\ngit diff\n)?",
    "answer": "Assuming the hash of the commit you want is\nc5f567\n:\ngit checkout c5f567 -- file1/to/restore file2/to/restore\nThe\ngit checkout\n man page gives more information.\nIf you want to revert to the commit before\nc5f567\n, append\n~1\n (where 1 is the number of commits you want to go back, it can be anything):\ngit checkout c5f567~1 -- file1/to/restore file2/to/restore\nAs a side note, I've always been uncomfortable with this command because it's used for both ordinary things (changing between branches) and unusual, destructive things (discarding changes in the working directory).\nFor the meaning of\n--\n in the command, refer to\nIn Git, what does\n--\n (dash dash) mean?\nThere is also a new\ngit restore\n command that is specifically designed for restoring working copy files that have been modified. If your git is new enough you can use this command, but the documentation comes with a warning:\nTHIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE.\nBecause\ngit restore\n is experimental, it should not yet be promoted as the primary answer to this question. When the command is no longer marked as \"experimental\", then this answer can be amended to promote the use of\ngit restore\n. [At the time of writing, the\ngit restore\n command has been marked as \"experimental\" for at least four years.]"
  },
  {
    "question": "How do I:\nCreate a local branch from another branch (via\ngit branch\n or\ngit checkout -b\n).\nPush the local branch\nto the remote repository (i.e. publish), but make it\ntrackable so that\ngit pull\n and\ngit push\n will work.",
    "answer": "In Git 1.7.0 and later, you can checkout a new branch:\ngit checkout -b <branch>\nEdit files, add and commit. Then\npush with the\n-u\n (short for\n--set-upstream\n)\n option:\ngit push -u origin <branch>\nGit will set up the tracking information during the push."
  },
  {
    "question": "How do I squash my last N commits together into one commit?",
    "answer": "Use\ngit rebase -i <after-this-commit>\n and replace \"pick\" on the second and subsequent commits with \"squash\" or \"fixup\", as described in\nthe manual\n.\nIn this example,\n<after-this-commit>\n is either the SHA1 hash or the relative location from the HEAD of the current branch from which commits are analyzed for the rebase command. For example, if the user wishes to view 5 commits from the current HEAD in the past, the command is\ngit rebase -i HEAD~5\n."
  },
  {
    "question": "I pulled a project with several forks on GitHub, but forgot which fork it was. How do I determine which fork I pulled?",
    "answer": "To obtain only the remote URL:\ngit config --get remote.origin.url\nIf you require full output, and you are on a network that can reach the remote repo where the origin resides:\ngit remote show origin\nWhen using\ngit clone\n (from GitHub, or any source repository for that matter) the default name for the source of the clone is \"origin\". Using\ngit remote show\n will display the information about this remote name. The first few lines should show:\nC:\\Users\\jaredpar\\VsVim> git remote show origin\n* remote origin\n  Fetch URL: git@github.com:jaredpar/VsVim.git\n  Push  URL: git@github.com:jaredpar/VsVim.git\n  HEAD branch: master\n  Remote branches:\nIf you want to use the value in a script, you would use the first command listed in this answer."
  },
  {
    "question": "How do I add an empty directory (that contains no files) to a Git repository?",
    "answer": "Another way to make a directory stay (almost) empty (in the repository) is to create a\n.gitignore\n file inside that directory that contains these four lines:\n# Ignore everything in this directory\n*\n# Except this file\n!.gitignore\nThen you don't have to get the order right the way that you have to do in m104's\nsolution\n.\nThis also gives the benefit that files in that directory won't show up as \"untracked\" when you do a git status.\nMaking\n@GreenAsJade\n's comment persistent:\nI think it's worth noting that this solution does precisely what the question asked for, but is not perhaps what many people looking at this question will have been looking for. This solution guarantees that the directory remains empty. It says \"I truly never want files checked in here\". As opposed to \"I don't have any files to check in here, yet, but I need the directory here, files may be coming later\"."
  },
  {
    "question": "How do I resolve merge conflicts in my Git repository?",
    "answer": "Try:\ngit mergetool\nIt opens a GUI that steps you through each conflict, and you get to choose how to merge.  Sometimes it requires a bit of hand editing afterwards, but usually it's enough by itself.  It is much better than doing the whole thing by hand certainly.\nAs per\nJosh Glover's comment\n:\n[This command]\ndoesn't necessarily open a GUI unless you install one. Running\ngit mergetool\n for me resulted in\nvimdiff\n being used. You can install\none of the following tools to use it instead:\nmeld\n,\nopendiff\n,\nkdiff3\n,\ntkdiff\n,\nxxdiff\n,\ntortoisemerge\n,\ngvimdiff\n,\ndiffuse\n,\necmerge\n,\np4merge\n,\naraxis\n,\nvimdiff\n,\nemerge\n.\nBelow is a sample procedure using\nvimdiff\n to resolve merge conflicts, based on\nthis link\n.\nRun the following commands in your terminal\ngit config merge.tool vimdiff\ngit config merge.conflictstyle diff3\ngit config mergetool.prompt false\nThis will set\nvimdiff\n as the default merge tool.\nRun the following command in your terminal\ngit mergetool\nYou will see a\nvimdiff\n display in the following format:\n  ╔═══════╦══════╦════════╗\n  ║       ║      ║        ║\n  ║ LOCAL ║ BASE ║ REMOTE ║\n  ║       ║      ║        ║\n  ╠═══════╩══════╩════════╣\n  ║                       ║\n  ║        MERGED         ║\n  ║                       ║\n  ╚═══════════════════════╝\nThese 4 views are\nLOCAL:\n this is the file from the current branch\nBASE:\n the common ancestor, how this file looked before both changes\nREMOTE:\n the file you are merging into your branch\nMERGED:\n the merge result; this is what gets saved in the merge commit and used in the future\nYou can navigate among these views using\nctrl\n+\nw\n. You can directly reach the MERGED view using\nctrl\n+\nw\n followed by\nj\n.\nMore information about\nvimdiff\n navigation is\nhere\n and\nhere\n.\nYou can edit the MERGED view like this:\nIf you want to get changes from REMOTE\n:diffg RE\nIf you want to get changes from BASE\n:diffg BA\nIf you want to get changes from LOCAL\n:diffg LO\nSave, Exit, Commit, and Clean up\n:wqa\n save and exit from vi\ngit commit -m \"message\"\ngit clean\n Remove extra files (e.g.\n*.orig\n).\nWarning:\n It will remove all untracked files, if you won't pass any arguments."
  },
  {
    "question": "How can I delete a Git tag that has already been pushed?",
    "answer": "You can push an 'empty' reference to the remote tag name:\ngit push origin :tagname\nOr, more expressively, use the\n--delete\n option (or\n-d\n if your git version is older than 1.8.0):\ngit push --delete origin tagname\nNote that git has tag namespace and branch namespace so you may use the same name for a branch and for a tag. If you want to make sure that you cannot accidentally remove the branch instead of the tag, you can specify full ref which will never delete a branch:\ngit push origin :refs/tags/tagname\nIf you also need to delete the local tag, use:\ngit tag --delete tagname\nor\ngit tag -d tagname\nBackground\nPushing a branch, tag, or other ref to a remote repository involves specifying \"which repo, what source, what destination?\"\ngit push remote-repo source-ref:destination-ref\nA real world example where you push your master branch to the origin's master branch is:\ngit push origin refs/heads/master:refs/heads/master\nWhich because of default paths, can be shortened to:\ngit push origin master:master\nTags work the same way:\ngit push origin refs/tags/release-1.0:refs/tags/release-1.0\nWhich can also be shortened to:\ngit push origin release-1.0:release-1.0\nBy omitting the source ref (the part before the colon), you push 'nothing' to the destination, deleting the ref on the remote end."
  },
  {
    "question": "I accidentally ran\ngit merge some_other_branch\n on my local master branch. I haven't pushed the changes to origin master. How do I undo the merge?\nAfter merging,\ngit status\n says:\n# On branch master\n# Your branch is ahead of 'origin/master' by 5 commits.\nHow do I undo all these commits?",
    "answer": "With\ngit reflog\n check which commit is one prior the merge (\ngit reflog\n will be a better option than\ngit log\n). Then you can reset it using:\ngit reset --hard commit_sha\nThere's also another way:\ngit reset --hard HEAD~1\nIt will get you back 1 commit.\nBe aware that any modified and uncommitted/unstashed files will be reset to their unmodified state\n. To keep them either stash changes away or see\n--merge\n option below.\nAs @Velmont suggested below in his answer, in this direct case using:\ngit reset --hard ORIG_HEAD\nmight yield better results, as it should preserve your changes.\nORIG_HEAD\n will point to a commit directly before merge has occurred, so you don't have to hunt for it yourself.\nA further tip is to use the\n--merge\n switch instead of\n--hard\n since it doesn't reset files unnecessarily:\ngit reset --merge ORIG_HEAD\n--merge\nResets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added)."
  },
  {
    "question": "My\nmaster\n and\ndevelopment\n branches are tracked remotely on\nGitHub\n. How do I clone both these branches?",
    "answer": "First, clone a remote\nGit\n repository and\ncd\n into it:\n$ git clone git://example.com/myproject\n$ cd myproject\nNext, look at the local branches in your repository:\n$ git branch\n* master\nBut there are other branches hiding in your repository! See these using the\n-a\n flag:\n$ git branch -a\n* master\n  remotes/origin/HEAD\n  remotes/origin/master\n  remotes/origin/v1.0-stable\n  remotes/origin/experimental\nTo take a quick peek at an upstream branch, check it out directly:\n$ git checkout origin/experimental\nTo work on that branch, create a local tracking branch, which is done automatically by:\n$ git checkout experimental\nBranch experimental set up to track remote branch experimental from origin.\nSwitched to a new branch 'experimental'\nHere, \"new branch\" simply means that the branch is taken from the index and created locally for you.  As the\nprevious\n line tells you, the branch is being set up to track the remote branch, which usually means the origin/branch_name branch.\nYour local branches should now show:\n$ git branch\n* experimental\n  master\nYou can track more than one remote repository using\ngit remote\n:\n$ git remote add win32 git://example.com/users/joe/myproject-win32-port\n$ git branch -a\n* master\n  remotes/origin/HEAD\n  remotes/origin/master\n  remotes/origin/v1.0-stable\n  remotes/origin/experimental\n  remotes/win32/master\n  remotes/win32/new-widgets\nAt this point, things are getting pretty crazy, so run\ngitk\n to see what's going on:\n$ gitk --all &"
  },
  {
    "question": "I forked a project, made changes, and created a pull request which was accepted. New commits were later added to the repository. How do I get those commits into my fork?",
    "answer": "In your local clone of your forked repository, you can add the original GitHub repository as a \"remote\".  (\"Remotes\" are like nicknames for the URLs of repositories -\norigin\n is one, for example.)  Then you can fetch all the branches from that upstream repository, and rebase your work to continue working on the upstream version.  In terms of commands that might look like:\n# Add the remote, call it \"upstream\":\ngit remote add upstream https://github.com/whoever/whatever.git\n# Fetch all the branches of that remote into remote-tracking branches\ngit fetch upstream\n# Make sure that you're on your main branch:\ngit checkout main\n# Rewrite your main branch so that any commits of yours that\n# aren't already in upstream/main are replayed on top of that\n# other branch:\ngit rebase upstream/main\nIf you don't want to rewrite the history of your main branch, (for example because other people may have cloned it) then you should replace the last command with\ngit merge upstream/main\n.  However, for making further pull requests that are as clean as possible, it's probably better to rebase.\nIf you've rebased your branch onto\nupstream/main\n you may need to force the push in order to push it to your own forked repository on GitHub.  You'd do that with:\ngit push -f origin main\nYou only need to use the\n-f\n the first time after you've rebased."
  },
  {
    "question": "How do I remove a Git submodule?\nWhy can't I do\ngit submodule rm module_name\n?",
    "answer": "Since\ngit1.8.3 (April 22d, 2013)\n:\nThere was no Porcelain way to say \"I no longer am interested in this submodule\", once you express your interest in a submodule with \"\ngit submodule init\n\".\n\"\ngit submodule deinit\n\" is the way to do so.\nThe deletion process also uses\ngit rm\n (since git1.8.5 October 2013).\nSummary\nThe 3-steps removal process would then be:\n0. mv a/submodule a/submodule_tmp\n1. git submodule deinit -f -- a/submodule\n2. rm -rf .git/modules/a/submodule\n3. git rm -f a/submodule\n# Note: a/submodule (no trailing slash)\n# or, if you want to leave it in your working tree and have done step 0\n3.   git rm --cached a/submodule\n3bis mv a/submodule_tmp a/submodule\nExplanation\nrm -rf\n: This is mentioned in\nDaniel Schroeder\n's\nanswer\n, and summarized by\nEonil\n in\nthe comments\n:\nThis leaves\n.git/modules/<path-to-submodule>/\n unchanged.\nSo if you once delete a submodule with this method and re-add them again, it will not be possible because repository already been corrupted.\ngit rm\n: See\ncommit 95c16418\n:\nCurrently using \"\ngit rm\n\" on a submodule removes the submodule's work tree from that of the superproject and the gitlink from the index.\nBut the submodule's section in\n.gitmodules\n is left untouched, which is a leftover of the now removed submodule and might irritate users (as opposed to the setting in\n.git/config\n, this must stay as a reminder that the user showed interest in this submodule so it will be repopulated later when an older commit is checked out).\nLet \"\ngit rm\n\" help the user by not only removing the submodule from the work tree but by also removing the \"\nsubmodule.<submodule name>\n\" section from the\n.gitmodules\n file and stage both.\ngit submodule deinit\n: It stems from\nthis patch\n:\nWith \"\ngit submodule init\n\" the user is able to tell git they care about one or more submodules and wants to have it populated on the next call to \"\ngit submodule update\n\".\nBut currently there is no easy way they can tell git they do not care about a submodule anymore and wants to get rid of the local work tree (unless the user knows a lot about submodule internals and removes the \"\nsubmodule.$name.url\n\" setting from\n.git/config\n together with the work tree himself).\nHelp those users by providing a '\ndeinit\n' command.\nThis\nremoves the whole\nsubmodule.<name>\n section from\n.git/config\n either for the given\nsubmodule(s)\n (or for all those which have been initialized if '\n.\n' is given).\nFail if the current work tree contains modifications unless forced.\nComplain when for a submodule given on the command line the url setting can't be found in\n.git/config\n, but nonetheless don't fail.\nThis takes care if the (de)initialization steps (\n.git/config\n and\n.git/modules/xxx\n)\nSince git1.8.5, the\ngit rm\n takes\nalso\n care of the:\n'\nadd\n' step which records the url of a submodule in the\n.gitmodules\n file: it is need to removed for you.\nthe submodule\nspecial entry\n (as illustrated by\nthis question\n): the git rm removes it from the index:\ngit rm --cached path_to_submodule\n (no trailing slash)\nThat will remove that directory stored in the index with a special mode \"160000\", marking it as a submodule root directory.\nIf you forget that last step, and try to add what was a submodule as a regular directory, you would get error message like:\ngit add mysubmodule/file.txt\nPath 'mysubmodule/file.txt' is in submodule 'mysubmodule'\nNote: since Git 2.17 (Q2 2018), git submodule deinit is no longer a shell script.\nIt is a call to a C function.\nSee\ncommit 2e61273\n,\ncommit 1342476\n (14 Jan 2018) by\nPrathamesh Chavan (\npratham-pc\n)\n.\n(Merged by\nJunio C Hamano --\ngitster\n --\n in\ncommit ead8dbe\n, 13 Feb 2018)\ngit ${wt_prefix:+-C \"$wt_prefix\"} submodule--helper deinit \\\n  ${GIT_QUIET:+--quiet} \\\n  ${prefix:+--prefix \"$prefix\"} \\\n  ${force:+--force} \\\n  ${deinit_all:+--all} \"$@\""
  },
  {
    "question": "What command checks if a directory exists or not within a Bash shell script?",
    "answer": "To check if a directory exists:\nif [ -d \"$DIRECTORY\" ]; then\n  echo \"$DIRECTORY does exist.\"\nfi\nTo check if a directory does not exist:\nif [ ! -d \"$DIRECTORY\" ]; then\n  echo \"$DIRECTORY does not exist.\"\nfi\nHowever, as\nJon Ericson\n points out, subsequent commands may not work as intended if you do not take into account that a symbolic link to a directory will also pass this check.\nE.g. running this:\nln -s \"$ACTUAL_DIR\" \"$SYMLINK\"\nif [ -d \"$SYMLINK\" ]; then\n  rmdir \"$SYMLINK\"\nfi\nWill produce the error message:\nrmdir: failed to remove `symlink': Not a directory\nSo symbolic links may have to be treated differently, if subsequent commands expect directories:\nif [ -d \"$LINK_OR_DIR\" ]; then\n  if [ -L \"$LINK_OR_DIR\" ]; then\n    # It is a symlink!\n    # Symbolic link specific commands go here.\n    rm \"$LINK_OR_DIR\"\n  else\n    # It's a directory!\n    # Directory command goes here.\n    rmdir \"$LINK_OR_DIR\"\n  fi\nfi\nTake particular note of the double-quotes used to wrap the variables. The reason for this is explained by 8jean\nin another answer\n.\nIf the variables contain spaces or other unusual characters it will probably cause the script to fail."
  },
  {
    "question": "How do I delete a commit from my branch history? Should I use\ngit reset --hard HEAD\n?",
    "answer": "Careful:\ngit reset --hard\nWILL DELETE YOUR WORKING DIRECTORY CHANGES\n.\nBe sure to\nstash any local changes you want to keep\n before running this command.\nAssuming you are sitting on that commit, then this command will wack it...\ngit reset --hard HEAD~1\nThe\nHEAD~1\n means the commit before head.\nOr, you could look at the output of\ngit log\n, find the commit id of the commit you want to back up to, and then do this:\ngit reset --hard <sha1-commit-id>\nIf you already pushed it, you will need to do a force push to get rid of it...\ngit push origin HEAD --force\nHowever\n, if others may have pulled it, then you would be better off starting a new branch.  Because when they pull, it will just merge it into their work, and you will get it pushed back up again.\nIf you already pushed, it may be better to use\ngit revert\n, to create a \"mirror image\" commit that will undo the changes.  However, both commits will be in the log.\nFYI:\ngit reset --hard HEAD\n is great if you want to get rid of WORK IN PROGRESS.It will reset you back to the most recent commit, and erase all the changes in your working tree and index.\ngit stash\n does the same except you can restore it later if you need\n, versus permanently delete with reset hard mode. Check your stashes by using\ngit stash list\n and\ngit stash show 'stash@123'\nLastly, if you need to find a commit that you \"deleted\", it is typically present in\ngit reflog\n unless you have garbage collected your repository."
  },
  {
    "question": "How do I easily undo a git rebase? A lengthy manual method is:\ncheckout the commit parent to both of the branches\ncreate and checkout a temporary branch\ncherry-pick all commits by hand\nreset the faulty rebased branch to point to the temporary branch\nIn my current situation, this works because I can easily spot commits from both branches (one was my stuff, the other was my colleague's stuff). However, my approach strikes me as suboptimal and error-prone (let's say I had just rebased with two of my own branches).\nClarification: I am talking about a rebase during which\nmultiple\n commits were replayed, not only one.",
    "answer": "The easiest way would be to find the head commit of the branch as it was immediately before the rebase started in the\nreflog\n...\ngit reflog\nand to reset the current branch to it.\nSuppose the old commit was\nHEAD@{2}\n in the ref log:\ngit reset --soft \"HEAD@{2}\"\n(If you do not want to retain the working copy changes, you can use\n--hard\n instead of\n--soft\n)\nYou can check the history of the candidate old head by just doing a\ngit log \"HEAD@{2}\"\n.\nIf you've not disabled per branch reflogs you should be able to simply do\ngit reflog \"branchname@{1}\"\n as a rebase detaches the branch head before reattaching to the final head. I would double-check this behavior, though, as I haven't verified it recently.\nPer default, all reflogs are activated for non-bare repositories:\n[core]\n    logAllRefUpdates = true"
  },
  {
    "question": "How do I get the name of the current branch in Git?",
    "answer": "git branch\nshould show all the local branches of your repo. The starred branch is your current branch.\nTo retrieve only the name of the branch you are on:\ngit rev-parse --abbrev-ref HEAD\nVersion 2.22 adds the\n--show-current\n option to\n”print the name of the current branch”\n. The combination also works for freshly initialized repositories before the first commit:\ngit branch --show-current"
  },
  {
    "question": "Git clone will clone remote branch into local.\nIs there any way to clone a specific branch by myself without switching branches on the remote repository?",
    "answer": "git clone --single-branch --branch <branchname> <remote-repo>\nThe\n--single-branch\n option is valid from version\n1.7.10\n and later.\nPlease see also the\nother answer\n which many people prefer.\nYou may also want to make sure you understand the difference. And the difference is: by invoking\ngit clone --branch <branchname> url\n you're fetching\nall\n the branches and checking out one. That may, for instance, mean that your repository has a 5kB documentation or wiki branch and 5GB data branch. And whenever you want to edit your frontpage, you may end up cloning 5GB of data.\nAgain, that is not to say\ngit clone --branch\n is not the way to accomplish that, it's just that it's not\nalways\n what you want to accomplish, when you're asking about cloning a specific branch."
  },
  {
    "question": "This checks if a file exists:\n#!/bin/bash\nFILE=$1\nif [ -f $FILE ]; then\n   echo \"File $FILE exists.\"\nelse\n   echo \"File $FILE does not exist.\"\nfi\nHow do I only check if the file does\nnot\n exist?",
    "answer": "The\ntest\n command (written as\n[\n here) has a \"not\" logical operator,\n!\n (exclamation mark):\nif [ ! -f /tmp/foo.txt ]; then\n    echo \"File not found!\"\nfi"
  },
  {
    "question": "How do I\ngrep\n and show the preceding and following 5 lines surrounding each matched line?",
    "answer": "For\nBSD\n or\nGNU\ngrep\n you can use\n-B num\n to set how many lines before the match and\n-A num\n for the number of lines after the match.\ngrep -B 3 -A 2 foo README.txt\nIf you want the same number of lines before and after you can use\n-C num\n.\ngrep -C 3 foo README.txt\nThis will show 3 lines before and 3 lines after."
  },
  {
    "question": "I know how to make a new branch that tracks remote branches, but\nhow do I make an existing branch track a remote branch?\nI know I can just edit the\n.git/config\n file, but it seems there should be an easier way.",
    "answer": "Given a branch\nfoo\n and a remote\nupstream\n:\nAs of Git 1.8.0:\ngit branch -u upstream/foo\nOr, if local branch\nfoo\n is not the current branch:\ngit branch -u upstream/foo foo\nOr, if you like to type longer commands, these are equivalent to the above two:\ngit branch --set-upstream-to=upstream/foo\ngit branch --set-upstream-to=upstream/foo foo\nAs of Git 1.7.0 (before 1.8.0):\ngit branch --set-upstream foo upstream/foo\nNotes:\nAll of the above commands will cause local branch\nfoo\n to track remote branch\nfoo\n from remote\nupstream\n.\nThe old (1.7.x) syntax is deprecated in favor of the new (1.8+) syntax.  The new syntax is intended to be more intuitive and easier to remember.\nDefining an upstream branch will fail when run against newly-created remotes that have not already been fetched. In that case, run\ngit fetch upstream\n beforehand.\nSee also:\nWhy do I need to do `--set-upstream` all the time?"
  },
  {
    "question": "I want to remove a file from my repository.\ngit rm file_to_remove.txt\nwill remove the file from the repository, but it will also remove the file from the local file system. How do I remove this file from the repo\nwithout\n deleting my local copy of the file?",
    "answer": "The\ngit rm\n documentation states:\nWhen\n--cached\n is given, the staged content has to match either the tip of the branch or the file on disk, allowing the file to be removed from just the index.\nSo, for a single file:\ngit rm --cached file_to_remove.txt\nand for a single directory:\ngit rm --cached -r directory_to_remove"
  },
  {
    "question": "I started some work on a new feature and after coding for a bit, I decided this feature should be on its own branch.\nHow do I move the existing uncommitted changes to a new branch and reset my current one?\nI want to reset my current branch while preserving existing work on the new feature.",
    "answer": "Update 2020 / Git 2.23\nGit 2.23 adds the new\nswitch\n subcommand in an attempt to clear some of the confusion that comes from the overloaded usage of\ncheckout\n (switching branches, restoring files, detaching HEAD, etc.)\nStarting with this version of Git, replace the checkout command with:\ngit switch -c <new-branch>\nThe behavior is identical and remains unchanged.\nBefore Update 2020 / Git 2.23\nUse the following:\ngit checkout -b <new-branch>\nThis will leave your current branch as it is, create and checkout a new branch and keep all your changes. You can then stage changes in files to commit with:\ngit add <files>\nand commit to your\nnew branch\n with:\ngit commit -m \"<Brief description of this commit>\"\nThe changes in the working directory and changes staged in index\ndo not belong to any branch\n yet. This changes the branch where those modifications would end in.\nYou don't\nreset\n your original branch, it stays as it is. The last commit on\n<old-branch>\n will still be the same. Therefore you\ncheckout -b\n and then commit."
  },
  {
    "question": "How do I view the history of an individual file with complete details of what has changed?\ngit log -- [filename]\n shows me the commit history of a file, but how do I see the file content that changed?",
    "answer": "For a graphical view, use\ngitk\n:\ngitk [filename]\nTo follow the file across file renames:\ngitk --follow [filename]"
  },
  {
    "question": "How do I stash only one of the multiple changed files on my branch?",
    "answer": "git stash push -p -m \"my commit message\"\n-p\n let's you select the hunks that should be stashed; whole files can be selected as well.\nYou'll be prompted with a few actions for each hunk:\n   y - stash this hunk\n   n - do not stash this hunk\n   q - quit; do not stash this hunk or any of the remaining ones\n   a - stash this hunk and all later hunks in the file\n   d - do not stash this hunk or any of the later hunks in the file\n   g - select a hunk to go to\n   / - search for a hunk matching the given regex\n   j - leave this hunk undecided, see next undecided hunk\n   J - leave this hunk undecided, see next hunk\n   k - leave this hunk undecided, see previous undecided hunk\n   K - leave this hunk undecided, see previous hunk\n   s - split the current hunk into smaller hunks\n   e - manually edit the current hunk\n   ? - print help"
  },
  {
    "question": "I created a local branch. How do I push it to the remote server?\nUPDATE: I have written a\nsimpler answer for Git 2.0 here\n.",
    "answer": "Simple Git 2.0+ solution:\nAs of\nGit 2.0, the behavior has become simpler\n:\nYou can configure git with\npush.default = current\n to make life easier:\nI added this so now I can just push a new branch upstream with\n$ git push -u\n-u\n will track remote branch of the same name. Now with this configuration, you will auto-guess the remote reference to git push. From\ngit.config documentation\n:\npush.default\nDefines the action git push should take if no refspec is explicitly given.\npush.default = current\n - push the current branch to update a branch with the\nsame name on the receiving end. Works in both central and non-central workflows.\nFor me, this is a good simplification of my day-to-day Git workflow. The configuration setting takes care of the 'usual' use case where you add a branch locally and want to create it remotely. Also, I can just as easily create local branches from remotes by just doing\ngit co remote_branch_name\n (as opposed to using\n--set-upstream-to\n flag).\nI know this question and the accepted answers are rather old, but the behavior has changed so that now configuration options exist to make your workflow simpler.\nTo add to your global Git configuration, run this on the command line:\n$ git config --global push.default current"
  },
  {
    "question": "When I make changes to a file in Git, how can I commit only some of the changes?\nFor example, how could I commit only 15 lines out of 30 lines that have been changed in a file?",
    "answer": "You can use:\ngit add --patch <filename>\nor for short:\ngit add -p <filename>\nGit will break down your file into what it thinks are sensible \"hunks\" (portions of the file). It will then prompt you with this question:\nStage this hunk [y,n,q,a,d,/,j,J,g,s,e,?]?\nHere is a description of each option:\ny\n stage this hunk for the next commit\nn\n do not stage this hunk for the next commit\nq\n quit; do not stage this hunk or any of the remaining hunks\na\n stage this hunk and all later hunks in the file\nd\n do not stage this hunk or any of the later hunks in the file\ng\n select a hunk to go to\n/\n search for a hunk matching the given regex\nj\n leave this hunk undecided, see next undecided hunk\nJ\n leave this hunk undecided, see next hunk\nk\n leave this hunk undecided, see previous undecided hunk\nK\n leave this hunk undecided, see previous hunk\ns\n split the current hunk into smaller hunks\ne\n manually edit the current hunk\nYou can then edit the hunk manually by replacing\n+\n/\n-\n by\n#\n (thanks\nveksen\n)\n?\n print hunk help\nIf the file is not in the repository yet, you can first do\ngit add -N <filename>\n. Afterwards you can go on with\ngit add -p <filename>\n.\nAfterwards, you can use:\ngit diff --staged\n to check that you staged the correct changes\ngit reset -p\n to unstage mistakenly added hunks\ngit commit -v\n to view your commit while you edit the commit message.\nNote this is far different than the\ngit format-patch\n command, whose purpose is to parse commit data into a\n.patch\n files.\nReference for future:\nGit Tools - Interactive Staging"
  },
  {
    "question": "How can I print a plain list of all files that were part of a given commit?\nAlthough the following lists the files, it also includes unwanted diff information for each:\ngit show a303aa90779efdd2f6b9d90693e2cbbbe4613c1d",
    "answer": "Preferred Way\n (because it's a\nplumbing\n command; meant to be programmatic):\n$ git diff-tree --no-commit-id --name-only bd61ad98 -r\nindex.html\njavascript/application.js\njavascript/ie6.js\nAnother Way\n (less preferred for scripts, because it's a\nporcelain\n command; meant to be user-facing)\n$ git show --pretty=\"\" --name-only bd61ad98\nindex.html\njavascript/application.js\njavascript/ie6.js\nThe\n--no-commit-id\n suppresses the commit ID output.\nThe\n--pretty\n argument specifies an empty format string to avoid the cruft at the beginning.\nThe\n--name-only\n argument shows only the file names that were affected (Thanks Hank). Use\n--name-status\n instead, if you want to see what happened to each file (\nD\neleted,\nM\nodified,\nA\ndded)\nThe\n-r\n argument is to recurse into sub-trees"
  },
  {
    "question": "How do I print a newline? This merely prints\n\\n\n:\necho -e \"Hello,\\nWorld!\"\nOutput:\nHello,\\nWorld!",
    "answer": "Use\nprintf\n instead:\nprintf \"hello\\nworld\\n\"\nprintf\n behaves more consistently across different environments than\necho\n."
  },
  {
    "question": "I have a string in Bash:\nstring=\"My string\"\nHow can I test if it contains another string?\nif [ $string ?? 'foo' ]; then\n  echo \"It's there!\"\nfi\nWhere\n??\n is my unknown operator. Do I use\necho\n and\ngrep\n?\nif echo \"$string\" | grep 'foo'; then\n  echo \"It's there!\"\nfi\nThat looks a bit clumsy.",
    "answer": "You can use\nMarcus's answer (* wildcards)\n outside a case statement, too, if you use double brackets:\nstring='My long string'\nif [[ $string == *\"My long\"* ]]; then\n  echo \"It's there!\"\nfi\nNote that spaces in the needle string need to be placed between double quotes, and the\n*\n wildcards should be outside. Also note that a simple comparison operator is used (i.e.\n==\n), not the regex operator\n=~\n."
  },
  {
    "question": "I added a tag to the master branch on my machine:\ngit tag mytag master\nHow do I push this to the remote repository? Running\ngit push\n gives the message:\nEverything up-to-date\nHowever, the remote repository does not contain my tag.",
    "answer": "To push specific, one tag do following\ngit push origin tag_name"
  },
  {
    "question": "In PHP, strings are concatenated together as follows:\n$foo = \"Hello\";\n$foo .= \" World\";\nHere,\n$foo\n becomes\n\"Hello World\"\n.\nHow is this accomplished in Bash?",
    "answer": "foo=\"Hello\"\nfoo=\"${foo} World\"\necho \"${foo}\"\n> Hello World\nIn general to concatenate two variables you can just write them one after another:\na='Hello'\nb='World'\nc=\"${a} ${b}\"\necho \"${c}\"\n> Hello World"
  },
  {
    "question": "I updated to the latest OS, and/or restarted my computer (this happens on every major update, but this time all I did was restart my computer on 2022-09-13).\nThis morning I navigated to my work's codebase in the command line on my\nMacBook Pro\n, typed in \"git status\" in the repository and received an error:\n(In 9/2022, this error was much different, but I didn't capture it)\nxcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun\nGit will not work!\nHow do I fix Git, and the command-line tools?",
    "answer": "The problem is that Xcode Command-line Tools needs to be updated due to a MacOs update.\nDid not run into this on Sonoma.\nMaybe Apple fixed the process?\nUpdated for Ventura\nAfter opening the terminal after restarting, I tried to go to my code, and do a\ngit status\n, and I got an error and prompt for command line software agreement:\nSo press space until you get to the\n[agree, print, cancel]\n option, so careful hit space to scroll down to the end, if you blow past It you have to run a command to get it back. Use\nsudo xcodebuild -license\n to get to it again.\nJust be careful on scrolling down and enter\nagree\n and press return and it will launch into an update.\nThen I tried to use git after the install, and it prompted me to install Xcode tools again.\nI followed my own advice from previous years (see below), and went to\nhttps://developer.apple.com/download/all\n and downloaded\n\"Command Line Tools for Xcode 14\" (You have to log in with your Apple ID and enter MFA code, so have all the devices you need for that handy. Then select \"Command Line Tools for Xcode 14\", or if you want to get into the alphas or betas, that's up to you. But stable releases are probably the best choice for software developers.\nYou have to either download the tools from CLI or the developer page and before you can use git, you need to reboot!!! Or you will get stuck in a loop of prompt & downloading\nRebooting will break the loop and complete the installation of your CLI tools\nincluding\n git so that you can get back to work\nSolutions for previous years, these may or may not be valid these days as the downloads page has changed significantly:\nPREVIOUS YEARS SOLUTIONS, probably #2 is most helpful.\n***\nSolution #1\n:\nGo back to your terminal and enter:\nxcode-select --install\nYou'll then receive the following output:\nxcode-select: note: install requested for command line developer tools\nYou will then be prompted in a window to update Xcode Command Line tools. (which could take a while)\nOpen a new terminal window and your development tools should be returned.\nAddition:\n With any major or semi-major update you'll need to update the command line tools in order to get them functioning properly again. Check Xcode with any update. This goes beyond Mojave...\nAfter that restart your terminal\nAlternatively,\nIF that fails,\n and it might.... you'll get a pop-up box saying \"Software not found on server\", proceed to solution 2.\n***\nSolution #2\n: (Preferred method)\nIf you hit\nxcode-select --install\n and it doesn't find the software, log into Apple Developer, and install it via webpage.\nLog in or sign up here:\nhttps://developer.apple.com/download/more/\nLook for:\n\"Command Line Tools for Xcode 14.x\"\n in the list of downloads\nThen click the dmg and download. (See previous image above) either way, you will probably wind up at an apple downloads webpage."
  },
  {
    "question": "What is the difference between\ngit add [--all | -A]\n and\ngit add .\n?",
    "answer": "This answer only applies to\nGit version 1.x\n. For Git version 2.x, see other answers.\nSummary:\ngit add -A\n stages\nall changes\ngit add .\n stages new files and modifications,\nwithout deletions\n (on the current directory and its subdirectories).\ngit add -u\n stages modifications and deletions,\nwithout new files\nDetail:\ngit add -A\n is equivalent to\ngit add .; git add -u\n.\nThe important point about\ngit add .\n is that it looks at the working tree and adds all those paths to the staged changes if they are either changed or are new and not ignored, it does not stage any 'rm' actions.\ngit add -u\n looks at all the\nalready\n tracked files and stages the changes to those files if they are different or if they have been removed. It does not add any new files, it only stages changes to already tracked files.\ngit add -A\n is a handy shortcut for doing both of those.\nYou can test the differences out with something like this (note that for Git version 2.x your output for\ngit add .\ngit status\nwill\n be different):\ngit init\necho Change me > change-me\necho Delete me > delete-me\ngit add change-me delete-me\ngit commit -m initial\necho OK >> change-me\nrm delete-me\necho Add me > add-me\ngit status\n# Changed but not updated:\n#   modified:   change-me\n#   deleted:    delete-me\n# Untracked files:\n#   add-me\ngit add .\ngit status\n# Changes to be committed:\n#   new file:   add-me\n#   modified:   change-me\n# Changed but not updated:\n#   deleted:    delete-me\ngit reset\ngit add -u\ngit status\n# Changes to be committed:\n#   modified:   change-me\n#   deleted:    delete-me\n# Untracked files:\n#   add-me\ngit reset\ngit add -A\ngit status\n# Changes to be committed:\n#   new file:   add-me\n#   modified:   change-me\n#   deleted:    delete-me"
  },
  {
    "question": "How do I globally configure git to use a particular editor (e.g.\nvim\n) for commit messages?",
    "answer": "Setting the default editor for Git\nPick one:\nSet\ncore.editor\n in your Git config:\ngit config --global core.editor \"vim\"\nSet the\nGIT_EDITOR\n environment variable:\nexport GIT_EDITOR=vim\nSetting the default editor for all programs\nSet the standardized\nVISUAL\n and\nEDITOR\n environment variables*:\nexport VISUAL=vim\nexport EDITOR=\"$VISUAL\"\nNOTE:\n Setting both is not necessarily needed, but some programs may not use the more-correct\nVISUAL\n. See\nVISUAL\n vs.\nEDITOR\n.\nFixing compatibility issues\nSome editors require a\n--wait\n flag, or they will open a blank page. For example:\nSublime Text\n (if\ncorrectly set up\n; or use the full path to the executable in place of\nsubl\n):\nexport VISUAL=\"subl --wait\"\nVS Code\n (after adding the\nshell command\n):\nexport VISUAL=\"code --wait\""
  },
  {
    "question": "What does\ngit cherry-pick <commit>\n do?",
    "answer": "Cherry-picking in Git means choosing a commit from one branch and applying it to another.\nThis contrasts with other ways such as\nmerge\n and\nrebase\n which normally apply many commits to another branch.\nIt's also possible to\ncherry-pick multiple commits\n but\nmerge\n is the preferred way over cherry-picking.\nMake sure you are on the branch you want to apply the commit to.\ngit switch master\nExecute the following:\ngit cherry-pick <commit-hash>\nN.B.:\nIf you cherry-pick from a public branch, you should consider using\ngit cherry-pick -x <commit-hash>\nThis will generate a standardized commit message. This way, you (and your co-workers) can still keep track of the origin of the commit and may avoid merge conflicts in the future.\nIf you have notes attached to the commit they do not follow the cherry-pick. To bring them over as well, You have to use:\ngit notes copy <from> <to>\nAdditional links:\ngit official guide page\ngit cherry-pick guide"
  },
  {
    "question": "I have the following commit history:\nHEAD\nHEAD~\nHEAD~2\nHEAD~3\ngit commit --amend\n modifies the current\nHEAD\n commit. But how do I modify\nHEAD~3\n?",
    "answer": "Use\ngit rebase\n. For example, to modify commit\nbbc643cd\n, run:\ngit rebase --interactive bbc643cd~\nPlease note the tilde\n~\n at the end of the command, because you need to reapply commits on top of the previous commit of\nbbc643cd\n (i.e.\nbbc643cd~\n).\nIn the default editor, modify\npick\n to\nedit\n in the line mentioning\nbbc643cd\n.\nSave the file and exit. git will interpret and automatically execute the commands in the file. You will find yourself in the previous situation in which you just had created commit\nbbc643cd\n.\nAt this point,\nbbc643cd\n is your last commit and you can\neasily amend it\n. Make your changes and then commit them with the command:\ngit commit --all --amend --no-edit\nAfter that, return back to the previous HEAD commit using:\ngit rebase --continue\nWARNING\n: Note that this will change the SHA-1 of that commit\nas well as all children\n -- in other words, this rewrites the history from that point forward.\nYou can break repos doing this\n if you push using the command\ngit push --force\n."
  },
  {
    "question": "I want to change the author of one specific commit in the history. It's not the latest commit.\nRelated:\nHow do I change the author and committer name/email for multiple commits?",
    "answer": "Interactive rebase off of a point earlier in the history than the commit you need to modify (\ngit rebase -i <earliercommit>\n). In the list of commits being rebased, change the text from\npick\n to\nedit\n next to the hash of the one you want to modify. Then when git prompts you to change the commit, use this:\ngit commit --amend --author=\"Author Name <email@address.com>\" --no-edit\nFor example, if your commit history is\nA-B-C-D-E-F\n with\nF\n as\nHEAD\n, and you want to change the author of\nC\n and\nD\n, then you would...\nSpecify\ngit rebase -i B\n (\nhere is an example of what you will see after executing the\ngit rebase -i B\n command\n)\nif you need to edit\nA\n, use\ngit rebase -i --root\nChange the lines for both\nC\n and\nD\n from\npick\n to\nedit\nExit the editor (for vim, this would be pressing Esc and then typing\n:wq\n).\nOnce the rebase started, it would first pause at\nC\nYou would\ngit commit --amend --author=\"Author Name <email@address.com>\"\nThen\ngit rebase --continue\nIt would pause again at\nD\nThen you would\ngit commit --amend --author=\"Author Name <email@address.com>\"\n again\ngit rebase --continue\nThe rebase would complete.\nUse\ngit push -f\n to update your origin with the updated commits."
  },
  {
    "question": "Say I'm in a Git repository. I delete a file and commit that change. I continue working and make some more commits. Then, I discover that I need to restore that file after deleting it.\nI know I can checkout a file using\ngit checkout <commit> -- filename.txt\n, but I don't know when that file was deleted.\nHow do I find the commit that deleted a given filename?\nHow do I restore that file back into my working copy?",
    "answer": "Find the last commit that affected the given path. As the file isn't in the HEAD commit, that previous commit must have deleted it.\ngit rev-list -n 1 HEAD -- <file_path>\nThen checkout the version at the commit before, using the caret (\n^\n) symbol:\ngit checkout <deleting_commit>^ -- <file_path>\nOr in one command, if\n$file\n is the file in question.\ngit checkout $(git rev-list -n 1 HEAD -- \"$file\")^ -- \"$file\"\nIf you are using zsh and have the EXTENDED_GLOB option enabled, the caret symbol won't work. You can use\n~1\n instead.\ngit checkout $(git rev-list -n 1 HEAD -- \"$file\")~1 -- \"$file\""
  },
  {
    "question": "To combine\nstderr\n and\nstdout\n into the\nstdout\n stream, we append this to a command:\n2>&1\nFor example, the following command shows the first few errors from compiling\nmain.cpp\n:\ng++ main.cpp 2>&1 | head\nBut what does\n2>&1\n mean?",
    "answer": "File descriptor 1 is the standard output (\nstdout\n).\nFile descriptor 2 is the standard error (\nstderr\n).\nAt first,\n2>1\n may look like a good way to redirect\nstderr\n to\nstdout\n. However, it will actually be interpreted as \"redirect\nstderr\n to a file named\n1\n\".\n&\n indicates that what follows and precedes is a\nfile descriptor\n, and not a filename. Thus, we use\n2>&1\n. Consider\n>&\n to be a redirect merger operator."
  },
  {
    "question": "The remote repository contains various branches such as\norigin/daves_branch\n:\n$ git branch -r\norigin/HEAD -> origin/master\norigin/daves_branch\norigin/master\nHow do I switch to\ndaves_branch\n in the local repository so that it tracks\norigin/daves_branch\n?\nI tried:\n$ git fetch origin daves_branch\n$ git checkout daves_branch",
    "answer": "Update: Using Git Switch\nAll of the information written below was accurate, but a new command,\ngit switch\n has been added that simplifies the effort.\nIf\ndaves_branch\n exists on the remote repository, but not on your local branch, you can simply type:\ngit switch daves_branch\nSince you do not have the branch locally, this will automatically make\nswitch\n look on the remote repo.  It will then also automatically set up remote branch tracking.\nNote that if\ndaves_branch\n doesn't exist locally you'll need to\ngit fetch\n first before using\nswitch\n.\nOriginal Post\nYou need to create a local branch that tracks a remote branch. The following command will create a local branch named\ndaves_branch\n, tracking the remote branch\norigin/daves_branch\n. When you push your changes the remote branch will be updated.\nFor most recent versions of Git:\ngit checkout --track origin/daves_branch\n--track\n is shorthand for\ngit checkout -b [branch] [remotename]/[branch]\n where [remotename] is\norigin\n in this case and [branch] is twice the same,\ndaves_branch\n in this case.\nFor Git 1.5.6.5 you needed this:\ngit checkout --track -b daves_branch origin/daves_branch\nFor Git 1.7.2.3 and higher, this is enough (it might have started earlier, but this is the earliest confirmation I could find quickly):\ngit checkout daves_branch\nNote that with recent Git versions, this command will not create a local branch and will put you in a 'detached HEAD' state. If you want a local branch, use the\n--track\n option.\nFull details are here:\n3.5 Git Branching - Remote Branches, Tracking Branches"
  },
  {
    "question": "How would I validate that a program exists, in a way that will either return an error and exit, or continue with the script?\nIt seems like it should be easy, but it's been stumping me.",
    "answer": "Answer\nPOSIX compatible:\ncommand -v <the_command>\nExample use:\nif ! command -v <the_command> >/dev/null 2>&1\nthen\n    echo \"<the_command> could not be found\"\n    exit 1\nfi\nFor Bash specific environments:\nhash <the_command> # For regular commands. Or...\ntype <the_command> # To check built-ins and keywords\nExplanation\nAvoid\nwhich\n. Not only is it an external process you're launching for doing very little (meaning builtins like\nhash\n,\ntype\n or\ncommand\n are way cheaper), you can also rely on the builtins to actually do what you want, while the effects of external commands can easily vary from system to system.\nWhy care?\nMany operating systems have a\nwhich\n that\ndoesn't even set an exit status\n, meaning the\nif which foo\n won't even work there and will\nalways\n report that\nfoo\n exists, even if it doesn't (note that some POSIX shells appear to do this for\nhash\n too).\nMany operating systems make\nwhich\n do custom and evil stuff like change the output or even hook into the package manager.\nSo, don't use\nwhich\n. Instead use one of these:\ncommand -v foo >/dev/null 2>&1 || { echo >&2 \"I require foo but it's not installed.  Aborting.\"; exit 1; }\ntype foo >/dev/null 2>&1 || { echo >&2 \"I require foo but it's not installed.  Aborting.\"; exit 1; }\nhash foo 2>/dev/null || { echo >&2 \"I require foo but it's not installed.  Aborting.\"; exit 1; }\n(Minor side-note: some will suggest\n2>&-\n is the same\n2>/dev/null\n but shorter –\nthis is untrue\n.\n2>&-\n closes FD 2 which causes an\nerror\n in the program when it tries to write to stderr, which is very different from successfully writing to it and discarding the output (and dangerous!))\n(Additional minor side-note: some will suggest\n&>/dev/null\n, but this\nis not POSIX compliant\n)\nIf your hash bang is\n/bin/sh\n then you should care about what POSIX says.\ntype\n and\nhash\n's exit codes aren't terribly well defined by POSIX, and\nhash\n is seen to exit successfully when the command doesn't exist (haven't seen this with\ntype\n yet).\ncommand\n's exit status is well defined by POSIX, so that one is probably the safest to use.\nIf your script uses\nbash\n though, POSIX rules don't really matter anymore and both\ntype\n and\nhash\n become perfectly safe to use.\ntype\n now has a\n-P\n to search just the\nPATH\n and\nhash\n has the side-effect that the command's location will be hashed (for faster lookup next time you use it), which is usually a good thing since you probably check for its existence in order to actually use it.\nAs a simple example, here's a function that runs\ngdate\n if it exists, otherwise\ndate\n:\ngnudate() {\n    if hash gdate 2>/dev/null; then\n        gdate \"$@\"\n    else\n        date \"$@\"\n    fi\n}"
  },
  {
    "question": "How do I change the author for a range of commits?",
    "answer": "This answer uses\ngit-filter-branch\n, for which\nthe docs\n now give this warning:\ngit filter-branch has a plethora of pitfalls that can produce non-obvious manglings of the intended history rewrite (and can leave you with little time to investigate such problems since it has such abysmal performance). These safety and performance issues cannot be backward compatibly fixed and as such, its use is not recommended. Please use an alternative history filtering tool such as\ngit filter-repo\n. If you still need to use git filter-branch, please carefully read\nSAFETY\n (and\nPERFORMANCE\n) to learn about the land mines of filter-branch, and then vigilantly avoid as many of the hazards listed there as reasonably possible.\nChanging the author (or committer) would require rewriting all of the history.  If you're okay with that and think it's worth it then you should check out\ngit filter-branch\n.  The manual page includes several examples to get you started.  Also note that you can use environment variables to change the name of the author, committer, dates, etc. -- see the \"Environment Variables\" section of the\ngit manual page\n.\nSpecifically, you can fix all the wrong author names and emails\nfor all branches and tags\n with this command (source:\nGitHub help\n):\n#!/bin/sh\ngit filter-branch --env-filter '\nOLD_EMAIL=\"your-old-email@example.com\"\nCORRECT_NAME=\"Your Correct Name\"\nCORRECT_EMAIL=\"your-correct-email@example.com\"\nif [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ]\nthen\n    export GIT_COMMITTER_NAME=\"$CORRECT_NAME\"\n    export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\"\nfi\nif [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ]\nthen\n    export GIT_AUTHOR_NAME=\"$CORRECT_NAME\"\n    export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\"\nfi\n' --tag-name-filter cat -- --branches --tags\nFor using alternative history filtering tool\ngit filter-repo\n, you can first install it and construct a\ngit-mailmap\n according to the format of\ngitmailmap\n.\nProper Name <proper@email.xx> Commit Name <commit@email.xx>\nAnd then run filter-repo with the created mailmap:\ngit filter-repo --mailmap git-mailmap"
  },
  {
    "question": "The command\ngit clone git@github.com:whatever\n creates a directory named\nwhatever\n containing a Git repository:\n./\n    whatever/\n        .git\nI want the contents of the Git repository cloned into my current directory\n./\n instead:\n./\n    .git",
    "answer": "Option A:\ngit clone git@github.com:whatever folder-name\nErgo, for\nright here\n use:\ngit clone git@github.com:whatever .\nOption B:\nMove the\n.git\n folder, too. Note that the\n.git\n folder is hidden in most graphical file explorers, so be sure to show hidden files.\nmv /where/it/is/right/now/* /where/I/want/it/\nmv /where/it/is/right/now/.* /where/I/want/it/\nThe first line grabs all normal files, the second line grabs dot-files. It is also possibe to do it in one line by enabling dotglob (i.e.\nshopt -s dotglob\n) but that is probably a bad solution if you are asking the question this answer answers.\nBetter yet:\nKeep your working copy somewhere else, and create a symbolic link. Like this:\nln -s /where/it/is/right/now /the/path/I/want/to/use\nFor your case this would be something like:\nln -sfn /opt/projectA/prod/public /httpdocs/public\nWhich easily could be changed to test if you wanted it, i.e.:\nln -sfn /opt/projectA/test/public /httpdocs/public\nwithout moving files around. Added\n-fn\n in case someone is copying these lines (\n-f\n is force,\n-n\n avoid some often unwanted interactions with already and non-existing links).\nIf you just want it to work, use Option A, if someone else is going to look at what you have done, use Option C."
  },
  {
    "question": "I have this string stored in a variable:\nIN=\"bla@some.com;john@home.com\"\nNow I would like to split the strings by\n;\n delimiter so that I have:\nADDR1=\"bla@some.com\"\nADDR2=\"john@home.com\"\nI don't necessarily need the\nADDR1\n and\nADDR2\n variables. If they are elements of an array that's even better.\nAfter suggestions from the answers below, I ended up with the following which is what I was after:\n#!/usr/bin/env bash\nIN=\"bla@some.com;john@home.com\"\nmails=$(echo $IN | tr \";\" \"\\n\")\nfor addr in $mails\ndo\n    echo \"> [$addr]\"\ndone\nOutput:\n> [bla@some.com]\n> [john@home.com]\nThere was a solution involving setting\nInternal_field_separator\n (IFS) to\n;\n. I am not sure what happened with that answer, how do you reset\nIFS\n back to default?\nRE:\nIFS\n solution, I tried this and it works, I keep the old\nIFS\n and then restore it:\nIN=\"bla@some.com;john@home.com\"\nOIFS=$IFS\nIFS=';'\nmails2=$IN\nfor x in $mails2\ndo\n    echo \"> [$x]\"\ndone\nIFS=$OIFS\nBTW, when I tried\nmails2=($IN)\nI only got the first string when printing it in loop, without brackets around\n$IN\n it works.",
    "answer": "You can set the\ninternal field separator\n (IFS) variable, and then let it parse into an array. When this happens in a command, then the assignment to\nIFS\n only takes place to that single command's environment (to\nread\n ). It then parses the input according to the\nIFS\n variable value into an array, which we can then iterate over.\nThis example will parse one line of items separated by\n;\n, pushing it into an array:\nIFS=';' read -ra ADDR <<< \"$IN\"\nfor i in \"${ADDR[@]}\"; do\n  # process \"$i\"\ndone\nThis other example is for processing the whole content of\n$IN\n, each time one line of input separated by\n;\n:\nwhile IFS=';' read -ra ADDR; do\n  for i in \"${ADDR[@]}\"; do\n    # process \"$i\"\n  done\ndone <<< \"$IN\""
  },
  {
    "question": "I have a project in which I have to change the mode of files with\nchmod\n to 777 while developing, but which should not change in the main repo.\nGit picks up on\nchmod -R 777 .\n and marks all files as changed. Is there a way to make Git ignore mode changes that have been made to files?",
    "answer": "Try:\ngit config core.fileMode false\nFrom\ngit-config(1)\n:\ncore.fileMode\n    Tells Git if the executable bit of files in the working tree\n    is to be honored.\n    Some filesystems lose the executable bit when a file that is\n    marked as executable is checked out, or checks out a\n    non-executable file with executable bit on. git-clone(1)\n    or git-init(1) probe the filesystem to see if it handles the\n    executable bit correctly and this variable is automatically\n    set as necessary.\n    A repository, however, may be on a filesystem that handles\n    the filemode correctly, and this variable is set to true when\n    created, but later may be made accessible from another\n    environment that loses the filemode (e.g. exporting ext4\n    via CIFS mount, visiting a Cygwin created repository with Git\n    for Windows or Eclipse). In such a case it may be necessary\n    to set this variable to false. See git-update-index(1).\n    The default is true (when core.filemode is not specified\n    in the config file).\nThe\n-c\n flag can be used to set this option for one-off commands:\ngit -c core.fileMode=false diff\nTyping the\n-c core.fileMode=false\n can be bothersome and so you can set this flag for all git repos or just for one git repo:\n# this will set your the flag for your user for all git repos (modifies `$HOME/.gitconfig`)\n# WARNING: this will be override by local config, fileMode value is automatically selected with latest version of git.\n# This mean that if git detect your current filesystem is compatible it will set local core.fileMode to true when you clone or init a repository.\n# Tool like cygwin emulation will be detected as compatible and so your local setting WILL BE SET to true no matter what you set in global setting.\ngit config --global core.fileMode false\n# this will set the flag for one git repo (modifies `$current_git_repo/.git/config`)\ngit config core.fileMode false\nAdditionally,\ngit clone\n and\ngit init\n explicitly set\ncore.fileMode\n to\ntrue\n in the repo config as discussed in\nGit global core.fileMode false overridden locally on clone\nWarning\ncore.fileMode\n is not the best practice and should be used carefully. This setting only covers the executable bit of mode and never the read/write bits. In many cases you think you need this setting because you did something like\nchmod -R 777\n, making all your files executable. But in most projects\nmost files don't need and should not be executable for security reasons\n.\nThe proper way to solve this kind of situation is to handle folder and file permission separately, with something like:\nfind . -type d -exec chmod a+rwx {} \\; # Make folders traversable and read/write\nfind . -type f -exec chmod a+rw {} \\;  # Make files read/write\nIf you do that, you'll never need to use\ncore.fileMode\n, except in very rare environment."
  },
  {
    "question": "I want to get the filename (without extension) and the extension separately.\nThe best solution I found so far is:\nNAME=`echo \"$FILE\" | cut -d'.' -f1`\nEXTENSION=`echo \"$FILE\" | cut -d'.' -f2`\nThis is wrong because it doesn't work if the file name contains multiple\n.\n characters. If, let's say, I have\na.b.js\n, it will consider\na\n and\nb.js\n, instead of\na.b\n and\njs\n.\nIt can be easily done in Python with\nfile, ext = os.path.splitext(path)\nbut I'd prefer not to fire up a Python interpreter just for this, if possible.\nAny better ideas?",
    "answer": "First, get file name without the path:\nfilename=$(basename -- \"$fullfile\")\nextension=\"${filename##*.}\"\nfilename=\"${filename%.*}\"\nAlternatively, you can focus on the last '/' of the path instead of the '.' which should work even if you have unpredictable file extensions:\nfilename=\"${fullfile##*/}\"\nYou may want to check the documentation :\nOn the web at section \"\n3.5.3 Shell Parameter Expansion\n\"\nIn the bash manpage at section called \"Parameter Expansion\""
  },
  {
    "question": "I have an already initialized Git repository that I added a\n.gitignore\n file to. How can I refresh the file index so the files I want ignored get ignored?",
    "answer": "To untrack a\nsingle\n file that has already been added/initialized to your repository,\ni.e.\n, stop tracking the file but not delete it from your system use:\ngit rm --cached filename\nTo untrack\nevery\n file that is now in your\n.gitignore\n:\nFirst commit any outstanding code changes\n, and then, run this command:\ngit rm -r --cached .\nThis removes any changed files from the\nindex\n(staging area), then just run:\ngit add .\nCommit it:\ngit commit -m \".gitignore is now working\"\nTo undo\ngit rm --cached filename\n, use\ngit add filename\n.\nMake sure to commit all your important changes before running\ngit add .\nOtherwise, you will lose any changes to other files.\nPlease be careful, when you push this to a repository and pull from somewhere else into a state where those files are still tracked, the files will be DELETED\nTo remove all files that do not match the paths listed in some path spec file (something that has the same format as a .gitignore file):\ngit rm --cached --ignore-unmatch -r --pathspec-from-file .ignorelist\nNote:\n unlike\n.gitignore\n, which can have new lines,\n.ignorelist\n cannot have new lines because\ngit\n will complain about empty patterns not being valid path spec items.\nExplanation:\n-r\n: to allow recursive removal when directories are involved\n--pathspec-from-file\n: path to file containing the path specifications for files to be removed\n--ignore-unmatch\n: tell\ngit\n to ignore any path specifications that do not have a matching cache hit (otherwise it will abort with an error on that path spec)"
  },
  {
    "question": "How do I see what is inside a\nstash\n without actually applying it?",
    "answer": "From\nman git-stash\n (which can also be obtained via\ngit help stash\n):\nThe modifications stashed away by this command can be listed with\ngit stash list\n, inspected with\ngit stash show\n, and ...\nshow [<stash>]\n    Show the changes recorded in the stash as a diff between the stashed\n    state and its original parent. When no <stash> is given, shows the\n    latest one. By default, the command shows the diffstat, but it will\n    accept any format known to git diff (e.g., git stash show -p stash@{1}\n    to view the second most recent stash in patch form).\nNote: the\n-p\n option generates a\npatch\n, as per\ngit-diff\n documentation.\nList the stashes:\ngit stash list\nShow the\nfiles\n in the most recent stash:\ngit stash show\nShow the\nchanges\n of the most recent stash:\ngit stash show -p\nShow the\nchanges\n of the named stash:\ngit stash show -p stash@{1}\nOr in short:\ngit stash show -p 1\nIf you want to view changes of only the last stash:\ngit stash show -p 0"
  },
  {
    "question": "How do I get the hash of the current commit in Git?",
    "answer": "To turn any extended object reference into a hash, use\ngit-rev-parse\n:\ngit rev-parse HEAD\nor\ngit rev-parse --verify HEAD\nAs noted by Alexander's\nanswer\n, you can also retrieve the short hash:\ngit rev-parse --short HEAD\nTo turn\nreferences\n (e.g.\nbranches and tags\n) into hashes, use\ngit show-ref\n and\ngit for-each-ref\n."
  },
  {
    "question": "I want to use a push and pull automatically in\nGit Extensions\n,\nSourcetree\n or any other Git GUI without entering my username and password in a prompt, every time.\nSo how can I save my credentials in Git?",
    "answer": "Attention:\nThis method saves the credentials in\nplaintext\n on your PC's disk. Everyone on your computer can access it, e.g. malicious NPM modules.\nRun\n:\ngit config --global credential.helper store\nthen\n:\ngit pull\nprovide a username and password and those details will then be remembered later. The credentials are stored in a file on the disk, with the disk permissions of \"just user readable/writable\" but still in plaintext.\nIf you want to change the password later:\ngit pull\nWill fail, because the password is incorrect, git then removes the offending user+password from the\n~/.git-credentials\n file, so now re-run:\ngit pull\nto provide a new password so it works as earlier."
  },
  {
    "question": "How do I clone a git repository so that it also clones its submodules?\nRunning\ngit clone $REPO_URL\n merely creates empty submodule directories.",
    "answer": "With version 2.13 of Git and later,\n--recurse-submodules\n can be used instead of\n--recursive\n:\ngit clone --recurse-submodules -j8 git://github.com/foo/bar.git\ncd bar\nEditor’s note:\n-j8\n is an optional performance optimization that became available in version 2.8, and fetches up to 8 submodules at a time in parallel — see\nman git-clone\n.\nWith version 1.9 of Git up until version 2.12 (\n-j\n flag only available in version 2.8+):\ngit clone --recursive -j8 git://github.com/foo/bar.git\ncd bar\nWith version 1.6.5 of Git and later, you can use:\ngit clone --recursive git://github.com/foo/bar.git\ncd bar\nFor already cloned repos, or older Git versions, use:\ngit clone git://github.com/foo/bar.git\ncd bar\ngit submodule update --init --recursive"
  },
  {
    "question": "I have a bunch of commits in the repository. I want to see a list of files changed between two commits - from\nSHA1\n to\nSHA2\n.\nWhat command should I use?",
    "answer": "git diff --name-only SHA1 SHA2\nwhere you only need to include enough of the SHA hash to identify the commits. The order of the SHAs does not matter. The output (which includes the relative path, not just the file name) follows this format:\n dir 1/dir 2/filename.ext\n dir 3/dir 4/other filename.ext\nYou can also do, for example\ngit diff --name-only HEAD~10 HEAD~5\nto see the differences between the tenth latest commit and the fifth latest (or so)."
  },
  {
    "question": "We're using git submodules to manage a couple of large projects that have dependencies on many other libraries we've developed. Each library is a separate repo brought into the dependent project as a submodule. During development, we often want to just go grab the latest version of every dependent submodule.\nHow do I pull the latest changes for all git submodules?",
    "answer": "If it's\nthe first time\n you check-out a repo you need to use\n--init\n first:\ngit submodule update --init --recursive\nFor\ngit 1.8.2\n or above, the option\n--remote\n was added to support updating to latest tips of remote branches:\ngit submodule update --recursive --remote\nThis has the added benefit of respecting any \"non default\" branches specified in the\n.gitmodules\n or\n.git/config\n files (if you happen to have any, default is origin/master, in which case some of the other answers here would work as well).\nFor\ngit 1.7.3\n or above you can use (but the below gotchas around what update does still apply):\ngit submodule update --recursive\nor:\ngit pull --recurse-submodules\nif you want to pull your submodules to latest commits instead of the current commit the repo points to.\nSee\ngit-submodule(1)\n for details"
  },
  {
    "question": "How do I delete branches which have already been merged? Can I delete them all at once, instead of deleting each branch one-by-one?",
    "answer": "NOTE: You can add other branches to exclude like master and dev if your workflow has those as a possible ancestor. Usually I branch off of a \"sprint-start\" tag and\nmaster\n,\ndev\n and\nqa\n are not ancestors.\nFirst, list locally-tracking branches that were merged in remote (consider using\n-r\n flag to list all remote-tracking branches).\ngit branch --merged\nYou might see a few branches you don't want to remove. We can add arguments to skip important branches that we don't want to delete like master or a develop. The following command will skip the\nmaster\n/\nmain\n branch and anything that has 'dev' in it.\ngit branch --merged | grep -Ev \"(^\\*|^\\+|master|main|dev)\"\nThe first part (\n^\\*|^+\n) excludes the current branch and any branch checked out in another worktree.\nIf you want to skip a branch, you can add it to the grep command as below. The branch\nskip_branch_name\n will not be deleted.\ngit branch --merged | grep -Ev \"(^\\*|^\\+|master|main|dev|skip_branch_name)\"\nTo delete all local branches that are already merged into the currently checked out branch:\ngit branch --merged | grep -Ev \"(^\\*|^\\+|master|main|dev)\" | xargs --no-run-if-empty git branch -d\nYou can see that\nmaster\n and\ndev\n are excluded in case they are an ancestor.\nYou can delete a merged local branch with:\ngit branch -d branchname\nTo force deletion of an unmerged branch, use:\ngit branch -D branchname\nTo delete it from the remote use:\ngit push --delete origin branchname\ngit push origin :branchname    # for really old git\nOnce you delete the branch from the remote, you can prune to get rid of remote tracking branches with:\ngit remote prune origin\nor prune individual remote tracking branches, as the other answer suggests, with:\ngit branch -dr branchname"
  },
  {
    "question": "I understand that a\n.gitignore\n file cloaks specified files from Git's version control.\nHow do I tell\n.gitignore\n to ignore everything except the files I'm tracking with Git? Something like:\n# Ignore everything:\n*\n# Do not ignore these files:\nscript.pl\ntemplate.latex",
    "answer": "An optional prefix\n!\n which negates the pattern; any matching file excluded by\na previous pattern will become included again. If a negated pattern matches,\nthis will override lower precedence patterns sources.\n# Ignore everything\n*\n# But not these files...\n!.gitignore\n!script.pl\n!template.latex\n# etc...\n# ...even if they are in subdirectories\n!*/"
  },
  {
    "question": "I ran\ngit status\n which told me everything was up to date and there were no local changes.\nThen I made several consecutive changes and realized I wanted to throw everything away and get back to my original state. Will this command do it for me?\ngit reset --hard HEAD",
    "answer": "To revert changes made to your working copy, do this:\ngit checkout .\nOr equivalently, for git version >= 2.23:\ngit restore .\nTo revert changes made to the index (i.e., that you have added), do this.\nWarning this will reset all of your unpushed commits to master!\n:\ngit reset\nTo revert a change that you have committed:\ngit revert <commit 1> <commit 2>\nTo remove untracked files (e.g., new files, generated files):\ngit clean -f\nOr untracked directories (e.g., new or automatically generated directories):\ngit clean -fd"
  },
  {
    "question": "If I have an\nn\n number of commits, how can I create a branch from the\nn-3\n commit?",
    "answer": "Create the branch using a commit hash:\ngit branch branch_name <commit-hash>\nOr by using a symbolic reference:\ngit branch branch_name HEAD~3\nTo checkout the branch while creating it, use:\ngit checkout -b branch_name <commit-hash or HEAD~3>"
  },
  {
    "question": "A new branch from\nmaster\n is created, we call it\ntest\n.\nThere are several developers who either commit to\nmaster\n or create other branches and later merge into\nmaster\n.\nLet's say work on\ntest\n is taking several days and you want to continuously keep\ntest\n updated with commits inside\nmaster\n.\nI would do\ngit pull origin master\n from\ntest\n.\nQuestion 1:\n Is this the right approach?  Other developers could have easily worked on same files as I have worked btw.\nMy work on\ntest\n is done and I am ready to merge it back to\nmaster\n. Here are the two ways I can think of:\nA:\ngit checkout test\ngit pull origin master\ngit push origin test\ngit checkout master\ngit pull origin test\nB:\ngit checkout test\ngit pull origin master\ngit checkout master\ngit merge test\nI am not using\n--rebase\n because from my understanding, rebase will get the changes from\nmaster\n and stack mine on top of that hence it could overwrite changes other people made.\nQuestion 2:\n Which one of these two methods is right?  What is the difference there?\nThe goal in all of this is to keep my\ntest\n branch updated with the things happening in\nmaster\n and later I could merge them back into\nmaster\n hoping to keep the timeline as linear as possible.",
    "answer": "How I would do this\ngit checkout master\ngit pull origin master\ngit merge test\ngit push origin master\nIf I have a local branch from a remote one, I don't feel comfortable with merging other branches than this one with the remote. Also I would not push my changes, until I'm happy with what I want to push and also I wouldn't push things at all, that are only for me and my local repository. In your description it seems, that\ntest\n is only for you? So no reason to publish it.\ngit always tries to respect yours and others changes, and so will\n--rebase\n. I don't think I can explain it appropriately, so have a look at\nthe Git book - Rebasing\n or\ngit-ready: Intro into rebasing\n for a little description. It's a quite cool feature"
  },
  {
    "question": "What are the differences between\n.gitignore\n and\n.gitkeep\n? Are they the same thing with a different name, or do they both serve a different function?\nI don't seem to be able to find much documentation on\n.gitkeep\n.",
    "answer": ".gitkeep\n isn’t documented, because it’s not a feature of Git.\nGit\ncannot add a completely empty directory\n. People who want to track empty directories in Git have created the convention of putting files called\n.gitkeep\n in these directories. The file could be called anything; Git assigns no special significance to this name.\nThere is a competing convention of adding a\n.gitignore\n file to the empty directories to get them tracked, but some people see this as confusing since the goal is to keep the empty directories, not ignore them;\n.gitignore\n is also used to list files that should be ignored by Git when looking for untracked files."
  },
  {
    "question": "I staged a few changes to be committed. How do I see the diffs of all files which are staged for the next commit? Is there a handy one-liner for this?\ngit status\n only shows names of files which are staged, but I want to see the actual diffs.\nThe\ngit-diff(1)\n man page says:\ngit diff [--options] [--] […]\nThis form is to view the changes you made relative to the index (staging area for the next commit). In other words, the differences are what you\ncould\n tell git to further add to the index but you still haven't. You can stage these changes by using git-add(1).",
    "answer": "It should just be:\ngit diff --cached\n--cached\n means show the changes in the cache/index (i.e. staged changes) against the current\nHEAD\n.\n--staged\n is a synonym for\n--cached\n.\n--staged\n and\n--cached\n does not point to\nHEAD\n, just difference with respect to\nHEAD\n. If you cherry pick what to commit using\ngit add --patch\n (or\ngit add -p\n),\n--staged\n will return what is staged."
  },
  {
    "question": "I frequently use\ngit stash\n and\ngit stash pop\n to save and restore changes in my working tree. Yesterday, I had some changes in my working tree that I had stashed and popped, and then I made more changes to my working tree. I'd like to go back and review yesterday's stashed changes, but\ngit stash pop\n appears to remove all references to the associated commit.\nI know that if I use\ngit stash\n then\n.git/refs/stash contains\n the reference of the commit used to create the stash. And\n.git/logs/refs/stash contains\n the whole stash. But those references are gone after\ngit stash pop\n. I know that the commit is still in my repository somewhere, but I don't know what it was.\nIs there an easy way to recover yesterday's stash commit reference?",
    "answer": "Once you know the hash of the stash commit you dropped, you can apply it as a stash:\ngit stash apply $stash_hash\nOr, you can create a separate branch for it with\ngit branch recovered $stash_hash\nAfter that, you can do whatever you want with all the normal tools. When you’re done, just blow the branch away.\nFinding the hash\nIf you have only just popped it and the terminal is still open, you will\nstill have the hash value printed by\ngit stash pop\n on screen\n (thanks, Dolda).\nOtherwise, you can find this way in Linux, Unix or Git Bash for Windows:\ngit fsck --no-reflog | awk '/dangling commit/ {print $NF}'\n… or in PowerShell for Windows:\ngit fsck --no-reflog | select-string 'dangling commit' | foreach { $_.ToString().Split(\" \")[-1] }\nThis will show you all the commits at the tips of your commit graph which are no longer referenced from any branch or tag – every lost commit, including every stash commit you’ve ever created, will be somewhere in that graph.\nThe easiest way to find the stash commit you want is probably to pass that list straight to\ngitk\n:\ngitk --all $( git fsck --no-reflog | awk '/dangling commit/ {print $NF}' )\n… or in PowerShell for Windows:\ngitk --all $( git fsck --no-reflog | select-string 'dangling commit' | foreach { $_.ToString().Split(\" \")[-1] } )\nThis will launch a repository browser showing you\nevery single commit in the repository ever\n, regardless of whether it is reachable or not.\nYou can replace\ngitk\n there with something like\ngit log --graph --oneline --decorate\n if you prefer a nice graph on the console over a separate GUI app.\nTo spot stash commits, look for commit messages of this form:\n        WIP on\nsomebranch\n:\ncommithash Some old commit message\nNote\n: The commit message will only be in this form (starting with \"WIP on\") if you did not supply a message when you did\ngit stash\n."
  },
  {
    "question": "How can I delete\n\"file1.txt\"\n from my repository?",
    "answer": "Use\ngit rm\n.\nIf you want to remove the file from the Git repository\nand the filesystem\n, use:\ngit rm file1.txt\ngit commit -m \"remove file1.txt\"\nBut if you want to remove the file only from the Git repository and not remove it from the filesystem, use:\ngit rm --cached file1.txt\ngit commit -m \"remove file1.txt\"\nAnd to push changes to remote repo\ngit push origin branch_name"
  },
  {
    "question": "Say, I have a script that gets called with this line:\n./myscript -vfd ./foo/bar/someFile -o /fizz/someOtherFile\nor this one:\n./myscript -v -f -d -o /fizz/someOtherFile ./foo/bar/someFile\nWhat's the accepted way of parsing this such that in each case (or some combination of the two)\n$v\n,\n$f\n, and\n$d\n will all be set to\ntrue\n and\n$outFile\n will be equal to\n/fizz/someOtherFile\n?",
    "answer": "Bash Space-Separated (e.g.,\n--option argument\n)\ncat >/tmp/demo-space-separated.sh <<'EOF'\n#!/bin/bash\nPOSITIONAL_ARGS=()\nwhile [[ $# -gt 0 ]]; do\n  case $1 in\n    -e|--extension)\n      EXTENSION=\"$2\"\n      shift # past argument\n      shift # past value\n      ;;\n    -s|--searchpath)\n      SEARCHPATH=\"$2\"\n      shift # past argument\n      shift # past value\n      ;;\n    --default)\n      DEFAULT=YES\n      shift # past argument\n      ;;\n    -*|--*)\n      echo \"Unknown option $1\"\n      exit 1\n      ;;\n    *)\n      POSITIONAL_ARGS+=(\"$1\") # save positional arg\n      shift # past argument\n      ;;\n  esac\ndone\nset -- \"${POSITIONAL_ARGS[@]}\" # restore positional parameters\necho \"FILE EXTENSION  = ${EXTENSION}\"\necho \"SEARCH PATH     = ${SEARCHPATH}\"\necho \"DEFAULT         = ${DEFAULT}\"\necho \"Number files in SEARCH PATH with EXTENSION:\" $(ls -1 \"${SEARCHPATH}\"/*.\"${EXTENSION}\" | wc -l)\nif [[ -n $1 ]]; then\n    echo \"Last line of file specified as non-opt/last argument:\"\n    tail -1 \"$1\"\nfi\nEOF\nchmod +x /tmp/demo-space-separated.sh\n/tmp/demo-space-separated.sh -e conf -s /etc /etc/hosts\nOutput from copy-pasting the block above\nFILE EXTENSION  = conf\nSEARCH PATH     = /etc\nDEFAULT         =\nNumber files in SEARCH PATH with EXTENSION: 14\nLast line of file specified as non-opt/last argument:\n#93.184.216.34    example.com\nUsage\ndemo-space-separated.sh -e conf -s /etc /etc/hosts\nBash Equals-Separated (e.g.,\n--option=argument\n)\ncat >/tmp/demo-equals-separated.sh <<'EOF'\n#!/bin/bash\nfor i in \"$@\"; do\n  case $i in\n    -e=*|--extension=*)\n      EXTENSION=\"${i#*=}\"\n      shift # past argument=value\n      ;;\n    -s=*|--searchpath=*)\n      SEARCHPATH=\"${i#*=}\"\n      shift # past argument=value\n      ;;\n    --default)\n      DEFAULT=YES\n      shift # past argument with no value\n      ;;\n    -*|--*)\n      echo \"Unknown option $i\"\n      exit 1\n      ;;\n    *)\n      ;;\n  esac\ndone\necho \"FILE EXTENSION  = ${EXTENSION}\"\necho \"SEARCH PATH     = ${SEARCHPATH}\"\necho \"DEFAULT         = ${DEFAULT}\"\necho \"Number files in SEARCH PATH with EXTENSION:\" $(ls -1 \"${SEARCHPATH}\"/*.\"${EXTENSION}\" | wc -l)\nif [[ -n $1 ]]; then\n    echo \"Last line of file specified as non-opt/last argument:\"\n    tail -1 $1\nfi\nEOF\nchmod +x /tmp/demo-equals-separated.sh\n/tmp/demo-equals-separated.sh -e=conf -s=/etc /etc/hosts\nOutput from copy-pasting the block above\nFILE EXTENSION  = conf\nSEARCH PATH     = /etc\nDEFAULT         =\nNumber files in SEARCH PATH with EXTENSION: 14\nLast line of file specified as non-opt/last argument:\n#93.184.216.34    example.com\nUsage\ndemo-equals-separated.sh -e=conf -s=/etc /etc/hosts\nTo better understand\n${i#*=}\n search for \"Substring Removal\" in\nthis guide\n. It is functionally equivalent to\n`sed 's/[^=]*=//' <<< \"$i\"`\n which calls a needless subprocess or\n`echo \"$i\" | sed 's/[^=]*=//'`\n which calls\ntwo\n needless subprocesses.\nUsing bash with getopt[s]\ngetopt(1) limitations (older, relatively-recent\ngetopt\n versions):\ncan't handle arguments that are empty strings\ncan't handle arguments with embedded whitespace\nMore recent\ngetopt\n versions don't have these limitations. For more information, see these\ndocs\n.\nPOSIX getopts\nAdditionally, the POSIX shell and others offer\ngetopts\n which doen't have these limitations. I've included a simplistic\ngetopts\n example.\ncat >/tmp/demo-getopts.sh <<'EOF'\n#!/bin/sh\n# A POSIX variable\nOPTIND=1         # Reset in case getopts has been used previously in the shell.\n# Initialize our own variables:\noutput_file=\"\"\nverbose=0\nwhile getopts \"h?vf:\" opt; do\n  case \"$opt\" in\n    h|\\?)\n      show_help\n      exit 0\n      ;;\n    v)  verbose=1\n      ;;\n    f)  output_file=$OPTARG\n      ;;\n  esac\ndone\nshift $((OPTIND-1))\n[ \"${1:-}\" = \"--\" ] && shift\necho \"verbose=$verbose, output_file='$output_file', Leftovers: $@\"\nEOF\nchmod +x /tmp/demo-getopts.sh\n/tmp/demo-getopts.sh -vf /etc/hosts foo bar\nOutput from copy-pasting the block above\nverbose=1, output_file='/etc/hosts', Leftovers: foo bar\nUsage\ndemo-getopts.sh -vf /etc/hosts foo bar\nThe advantages of\ngetopts\n are:\nIt's more portable, and will work in other shells like\ndash\n.\nIt can handle multiple single options like\n-vf filename\n in the typical Unix way, automatically.\nThe disadvantage of\ngetopts\n is that it can only handle short options (\n-h\n, not\n--help\n) without additional code.\nThere is a\ngetopts tutorial\n which explains what all of the syntax and variables mean.  In bash, there is also\nhelp getopts\n, which might be informative."
  },
  {
    "question": "I've been wondering whether there is a good \"git export\" solution that creates a copy of a tree without the\n.git\n repository directory. There are at least three methods I know of:\ngit clone\n followed by removing the\n.git\n repository directory.\ngit checkout-index\n alludes to this functionality but starts with \"Just read the desired tree into the index...\" which I'm not entirely sure how to do.\ngit-export\n is a third-party script that essentially does a\ngit clone\n into a temporary location followed by\nrsync --exclude='.git'\n into the final destination.\nNone of these solutions really strike me as being satisfactory. The closest one to\nsvn export\n might be option 1, because both require the target directory to be empty first. But option 2 seems even better, assuming I can figure out what it means to read a tree into the index.",
    "answer": "Probably the simplest way to achieve this is with\ngit archive\n. If you really need just the expanded tree you can do something like this.\ngit archive master | tar -x -C /somewhere/else\nMost of the time that I need to 'export' something from git, I want a compressed archive in any case so I do something like this.\ngit archive master | bzip2 >source-tree.tar.bz2\nZIP archive:\ngit archive --format zip --output /full/path/to/zipfile.zip master\ngit help archive\n for more details, it's quite flexible.\nBe aware that even though the archive will not contain the .git directory, it will, however, contain other hidden git-specific files like .gitignore, .gitattributes, etc. If you don't want them in the archive, make sure you use the export-ignore attribute in a .gitattributes file and commit this before doing your archive.\nRead more...\nNote: If you are interested in exporting the index, the command is\ngit checkout-index -a -f --prefix=/destination/path/\n(See\nGreg's answer\n for more details)\nHere's a real-world example using libchrony on Linux:\nmkdir $HOME/dev\ncd $HOME/dev\npushd /tmp\ngit clone https://gitlab.com/chrony/libchrony.git\ncd libchrony\nBRANCH=$(git rev-parse --abbrev-ref HEAD)\ngit archive -o ../libchrony.zip --prefix=\"libchrony/\" $BRANCH\npopd\nunzip /tmp/libchrony.zip\nThose commands produce a zip file and extract it into\n$HOME/dev/libchrony\n. We can peek into the archive using:\n$ unzip -v /tmp/libchrony\nArchive:  /tmp/libchrony.zip\ne0a3807f770b56f6b0e9833254baa7c4fc13564b\n Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n--------  ------  ------- ---- ---------- ----- --------  ----\n       0  Stored        0   0% 2023-07-20 09:37 00000000  libchrony/\n      49  Defl:N       47   4% 2023-07-20 09:37 37c3f2e2  libchrony/.gitignore\n   26530  Defl:N     9350  65% 2023-07-20 09:37 5622583e  libchrony/COPYING\n     961  Defl:N      467  51% 2023-07-20 09:37 da9221e3  libchrony/Makefile\n     475  Defl:N      304  36% 2023-07-20 09:37 cae27f70  libchrony/README.adoc\n    3313  Defl:N     1119  66% 2023-07-20 09:37 37eb110f  libchrony/chrony.h\n    7673  Defl:N     2261  71% 2023-07-20 09:37 5d455a52  libchrony/client.c\n    6190  Defl:N     2093  66% 2023-07-20 09:37 7ea9d81b  libchrony/example-reports.c\n   16348  Defl:N     3855  76% 2023-07-20 09:37 e82f5fe3  libchrony/message.c\n    2946  Defl:N     1099  63% 2023-07-20 09:37 945ee82b  libchrony/message.h\n--------          -------  ---                            -------\n   64485            20595  68%                            10 files"
  },
  {
    "question": "How can I stash a specific file leaving the others currently modified out of the stash I am about to save?\nFor example, if git status gives me this:\nyounker % git status\n# On branch master\n# Your branch is ahead of 'origin/master' by 1 commit.\n#\n# Changes not staged for commit:\n#   (use \"git add <file>...\" to update what will be committed)\n#   (use \"git checkout -- <file>...\" to discard changes in working directory)\n#\n#   modified:   app/controllers/cart_controller.php\n#   modified:   app/views/cart/welcome.thtml\n#\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nand I only want to stash app/views/cart/welcome.thtml, how would I do that? Something like (but of course this does not work):\ngit stash save welcome_cart app/views/cart/welcome.thtml",
    "answer": "Since git 2.13, there is a command to save a specific path to the stash:\ngit stash push <path>\n. For example:\ngit stash push -m welcome_cart app/views/cart/welcome.thtml\nWith earlier versions:\nYou can do that using\ngit stash --patch\n (or\ngit stash -p\n) -- you'll enter interactive mode where you'll be presented with each hunk that was changed. Use\nn\n to skip the files that you don't want to stash,\ny\n when you encounter the one that you want to stash, and\nq\n to quit and leave the remaining hunks unstashed.\na\n will stash the shown hunk and the rest of the hunks in that file.\nNot the most user-friendly approach, but it gets the work done if you really need it."
  },
  {
    "question": "npm 5 was released today\n and one of the new features include deterministic installs with the creation of a\npackage-lock.json\n file.\nIs this file supposed to be kept in source control?\nI'm assuming it's similar to\nyarn.lock\n and\ncomposer.lock\n, both of which are supposed to be kept in source control.",
    "answer": "Yes,\npackage-lock.json\n is intended to be checked into source control. If you're using npm 5+, you may see this notice on the command line:\ncreated a lockfile as package-lock.json. You should commit this file.\n According to\nnpm help package-lock.json\n:\npackage-lock.json\n is automatically generated for any operations where npm\nmodifies either the\nnode_modules\n tree, or\npackage.json\n. It describes the\nexact tree that was generated, such that subsequent installs are able to\ngenerate identical trees, regardless of intermediate dependency updates.\nThis file is intended to be committed into source repositories\n, and serves\nvarious purposes:\nDescribe a single representation of a dependency tree such that teammates, deployments, and continuous integration are guaranteed to install exactly the same dependencies.\nProvide a facility for users to \"time-travel\" to previous states of\nnode_modules\n without having to commit the directory itself.\nTo facilitate greater visibility of tree changes through readable source control diffs.\nAnd optimize the installation process by allowing npm to skip repeated metadata resolutions for previously-installed packages.\nOne key detail about\npackage-lock.json\n is that it cannot be published, and it\nwill be ignored if found in any place other than the toplevel package. It shares\na format with npm-shrinkwrap.json, which is essentially the same file, but\nallows publication. This is not recommended unless deploying a CLI tool or\notherwise using the publication process for producing production packages.\nIf both\npackage-lock.json\n and\nnpm-shrinkwrap.json\n are present in the root of\na package,\npackage-lock.json\n will be completely ignored."
  },
  {
    "question": "I have a pretty simple script that is something like the following:\n#!/bin/bash\nVAR1=\"$1\"\nMOREF='sudo run command against $VAR1 | grep name | cut -c7-'\necho $MOREF\nWhen I run this script from the command line and pass it the arguments, I am not getting any output.  However, when I run the commands contained within the\n$MOREF\n variable, I am able to get output.\nHow can one take the results of a command that needs to be run within a script, save it to a variable, and then output that variable on the screen?",
    "answer": "In addition to backticks\n`command`\n,\ncommand substitution\n can be done with\n$(command)\n or\n\"$(command)\"\n, which I find easier to read, and allows for nesting.\nOUTPUT=\"$(ls -1)\"\necho \"${OUTPUT}\"\nMULTILINE=\"$(ls \\\n   -1)\"\necho \"${MULTILINE}\"\nQuoting (\n\"\n) does matter to preserve\nmulti-line variable values\n and it is safer to use with whitespace and special characters such as (\n*\n) and therefore advised; it is, however, optional on the right-hand side of an assignment when\nword splitting is not performed\n, so\nOUTPUT=$(ls -1)\n would work fine."
  },
  {
    "question": "How do I know if a variable is set in Bash?\nFor example, how do I check if the user gave the first parameter to a function?\nfunction a {\n    # if $1 is set ?\n}",
    "answer": "(Usually) The right way\nif [ -z ${var+x} ]; then echo \"var is unset\"; else echo \"var is set to '$var'\"; fi\nwhere\n${var+x}\n is a\nparameter expansion\n which evaluates to nothing if\nvar\n is unset, and substitutes the string\nx\n otherwise.\nQuotes Digression\nQuotes can be omitted (so we can say\n${var+x}\n instead of\n\"${var+x}\"\n) because this syntax & usage guarantees this will only expand to something that does not require quotes (since it either expands to\nx\n (which contains no word breaks so it needs no quotes), or to nothing (which results in\n[ -z  ]\n, which conveniently evaluates to the same value (true) that\n[ -z \"\" ]\n does as well)).\nHowever, while quotes can be safely omitted, and it was not immediately obvious to all (it wasn't even apparent to\nthe first author of this quotes explanation\n who is also a major Bash coder), it would sometimes be better to write the solution with quotes as\n[ -z \"${var+x}\" ]\n, at the very small possible cost of an O(1) speed penalty.  The first author also added this as a comment next to the code using this solution giving the URL to this answer, which now also includes the explanation for why the quotes can be safely omitted.\n(Often) The wrong way\nif [ -z \"$var\" ]; then echo \"var is blank\"; else echo \"var is set to '$var'\"; fi\nThis is often wrong because it doesn't distinguish between a variable that is unset and a variable that is set to the empty string. That is to say, if\nvar=''\n, then the above solution will output \"var is blank\".\nThe distinction between unset and \"set to the empty string\" is essential in situations where the user has to specify an extension, or additional list of properties, and that not specifying them defaults to a non-empty value, whereas specifying the empty string should make the script use an empty extension or list of additional properties.\nThe distinction may not be essential in every scenario though. In those cases\n[ -z \"$var\" ]\n will be just fine."
  },
  {
    "question": "I have changes to a file, plus a new file, and would like to use git stash to put them away while I switch to another task.  But git stash by itself stashes only the changes to the existing file; the new file remains in my working tree, cluttering up my future work.  How do I stash this untracked file?",
    "answer": "To stash your working directory including untracked files (especially those that are in the\n.gitignore\n) then you probably want to use this cmd:\ngit stash --include-untracked\nAlternatively, you can use the shorthand\n-u\n instead of\n--include-untracked\n, or simply\ngit stash --all\n (see warning below for this one) which stashes all files, including\nuntracked\n and\nignored\n files. This behaviour changed in 2018, so make sure your git is up to date.\nWarning: there seems to be (or have been) situations in which contents of ignored directories could be deleted permanently.\nSee this archived website for more information\n."
  },
  {
    "question": "Due to some bad cherry-picking, my local Git repository is currently five commits ahead of the origin, and not in a good state. I want to get rid of all these commits and start over again.\nObviously, deleting my working directory and re-cloning would do it, but downloading everything from GitHub again seems like overkill, and not a good use of my time.\nMaybe\ngit revert\n is what I need, but I don't want to end up\n10\n commits ahead of the origin (or even six), even if it does get the code itself back to the right state. I just want to pretend the last half-hour never happened.\nIs there a simple command that will do this? It seems like an obvious use case, but I'm not finding any examples of it.\nNote that this question is specifically about\ncommits\n,\nnot\n about:\nuntracked files\nunstaged changes\nstaged, but uncommitted changes",
    "answer": "If your excess commits are only visible to you, you can just do\ngit reset --hard origin/<branch_name>\nto move back to where the origin is. This will reset the state of the repository to the previous commit, and it will discard all local changes.\nDoing a\ngit revert\n makes\nnew\n commits to remove\nold\n commits in a way that keeps everyone's history sane."
  },
  {
    "question": "I cloned a Git repository containing many branches. However,\ngit branch\n only shows one:\n$ git branch\n* master\nHow would I pull all the branches locally so when I do\ngit branch\n, it shows the following?\n$ git branch\n* master\n* staging\n* etc...",
    "answer": "TL;DR answer\ngit branch -r \\\n  | grep -v '\\->' \\\n  | sed \"s,\\x1B\\[[0-9;]*[a-zA-Z],,g\" \\\n  | while read remote; do \\\n      git branch --track \"${remote#origin/}\" \"$remote\"; \\\n    done\ngit fetch --all\ngit pull --all\n(\ngrep -v\n matches the inverse of given string;\nsed\n removes control sequences:\n\\x1B\n matches\nesc\n)\n(It seems that pull fetches all branches from all remotes, but I always fetch first just to be sure.)\nRun the first command only if there are remote branches on the server that aren't tracked by your local branches.\nComplete answer\nYou can fetch all branches from all remotes like this:\ngit fetch --all\nIt's basically a\npower move\n.\nfetch\n updates local copies of remote branches so this is always safe for your local branches\nBUT\n:\nfetch\n will not\nupdate\n local branches (which\ntrack\n remote branches); if you want to update your local branches you still need to pull every branch.\nfetch\n will not\ncreate\n local branches (which\ntrack\n remote branches), you have to do this manually. If you want to list all remote branches:\ngit branch -a\nTo\nupdate\n local branches which track remote branches:\ngit pull --all\nHowever, this can be still insufficient. It will work only for your local branches which track remote branches. To track all remote branches execute this oneliner\nBEFORE\ngit pull --all\n:\ngit branch -r | grep -v '\\->' | sed \"s,\\x1B\\[[0-9;]*[a-zA-Z],,g\" | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\"; done\nP.S. AFAIK\ngit fetch --all\n and\ngit remote update\n are equivalent.\nKamil Szot's\ncomment\n, which folks have found useful.\nI had to use:\nfor remote in `git branch -r`; do git branch --track ${remote#origin/} $remote; done\nbecause your code created local branches named\norigin/branchname\n and\nI was getting \"refname 'origin/branchname' is ambiguous whenever I\nreferred to it."
  },
  {
    "question": "When I do\ngit diff COMMIT\n I see the changes between that commit and HEAD (as far as I know), but I would like to see the changes that were made by that single commit.\nI haven't found any obvious options on\ndiff\n /\nlog\n that will give me that output.",
    "answer": "To see the diff for a particular\nCOMMIT\n hash, where\nCOMMIT\n is the hash of the commit:\ngit diff COMMIT~ COMMIT\n will show you the difference between that\nCOMMIT\n's ancestor and the\nCOMMIT\n. See the man pages for\ngit diff\n for details about the command and\ngitrevisions\n about the\n~\n notation and its friends.\nAlternatively,\ngit show COMMIT\n will do something very similar. (The commit's data, including its diff - but not for merge commits.) See the\ngit show manpage\n.\n(also\ngit diff COMMIT\n will show you the difference between that\nCOMMIT\n and the head.)"
  },
  {
    "question": "I want to write a script that loops through 15 strings (array possibly?) Is that possible?\nSomething like:\nfor databaseName in listOfNames\nthen\n  # Do something\nend",
    "answer": "You can use it like this:\n## declare an array variable\ndeclare -a arr=(\"element1\" \"element2\" \"element3\")\n## now loop through the above array\nfor i in \"${arr[@]}\"\ndo\n   echo \"$i\"\n   # or do whatever with individual element of the array\ndone\n# You can access them using echo \"${arr[0]}\", \"${arr[1]}\" also\nAlso works for multi-line array declaration\ndeclare -a arr=(\"element1\"\n                \"element2\" \"element3\"\n                \"element4\"\n                )"
  },
  {
    "question": "I want to merge two branches that have been separated for a while and wanted to know which files have been modified.\nCame across this link:\nhttp://linux.yyz.us/git-howto.html\n (moved to web.archive.org) which was quite useful.\nThe tools to compare branches I've come across are:\ngit diff master..branch\ngit log master..branch\ngit shortlog master..branch\nWas wondering if there's something like \"git status master..branch\" to only see those files that are different between the two branches.\nWithout creating a new tool, I think this is the closest you can get to do that now (which of course will show repeats if a file was modified more than once):\ngit diff master..branch | grep \"^diff\"\nWas wondering if there's something I missed...",
    "answer": "To compare the current branch against\nmain\n branch:\n$ git diff --name-status main\nTo compare any two branches:\n$ git diff --name-status firstbranch..yourBranchName\nThere are more options to\ngit diff\n in the\nofficial documentation\n (and specifically the\n--name-status\n option)."
  },
  {
    "question": "How do I remove a file from the latest commit?",
    "answer": "I think other answers here are wrong, because this is a question of moving the mistakenly committed files back to the staging area from the previous commit, without cancelling the changes done to them. This can be done like Paritosh Singh suggested:\ngit reset --soft HEAD^\nor\ngit reset --soft HEAD~1\nThen reset the unwanted files in order to leave them out from the commit (the old way):\ngit reset HEAD path/to/unwanted_file\nNote, that since Git\n2.23.0\n one can (\nthe new way\n):\ngit restore --staged path/to/unwanted_file\nNow commit again, you can even re-use the same commit message:\ngit commit -c ORIG_HEAD\nEDIT\n: The easiest way to do this is to use e.g.\ngit gui\n. Just select\nCommit => Amend Last Commit\n and simply uncheck the desired file from the commit and click\nCommit\n."
  },
  {
    "question": "How can I view any local commits I've made, that haven't yet been pushed to the remote repository? Occasionally,\ngit status\n will print out that my branch is X commits ahead of\norigin/master\n, but not always.\nIs this a bug with my install of Git, or am I missing something?",
    "answer": "This gives a log of all commits between origin/master and HEAD:\ngit log origin/master..HEAD\nWhen HEAD is on the master branch, this gives a log of unpushed commits.\nSimilarly, to view the diff:\ngit diff origin/master..HEAD"
  },
  {
    "question": "Is there a simple way to delete all tracking branches whose remote equivalent no longer exists?\nExample:\nBranches (local and remote)\nmaster\norigin/master\norigin/bug-fix-a\norigin/bug-fix-b\norigin/bug-fix-c\nLocally, I only have a master branch. Now I need to work on\nbug-fix-a\n, so I check it out, work on it, and push changes to the remote. Next I do the same with\nbug-fix-b\n.\nBranches (local and remote)\nmaster\nbug-fix-a\nbug-fix-b\norigin/master\norigin/bug-fix-a\norigin/bug-fix-b\norigin/bug-fix-c\nNow I have local branches\nmaster\n,\nbug-fix-a\n,\nbug-fix-b\n. The Master branch maintainer will merge my changes into\nmaster\n and delete all branches he has already merged.\nSo the current state is now:\nBranches (local and remote)\nmaster\nbug-fix-a\nbug-fix-b\norigin/master\norigin/bug-fix-c\nNow I would like to call some command to delete branches (in this case\nbug-fix-a\n,\nbug-fix-b\n), which are no longer represented in the remote repository.\nIt would be something like the existing command\ngit remote prune origin\n, but more like\ngit local prune origin\n.",
    "answer": "git remote prune origin\n prunes tracking branches not on the remote.\ngit branch --merged\n lists branches that have been merged into the current branch.\nxargs git branch -d\n deletes branches listed on standard input.\nBe careful deleting branches listed by\ngit branch --merged\n. The list could include\nmaster\n or other branches you'd prefer not to delete.\nTo give yourself the opportunity to edit the list before deleting branches, you could do the following in one line:\ngit branch --merged >/tmp/merged-branches && \\\n  vi /tmp/merged-branches && xargs git branch -d </tmp/merged-branches"
  },
  {
    "question": "Consider the following scenario:\nI have developed a small experimental project A in its own Git repo. It has now matured, and I'd like A to be part of larger project B, which has its own big repository. I'd now like to add A as a subdirectory of B.\nHow do I merge A into B, without losing history on any side?",
    "answer": "A single branch of another repository can be easily placed under a subdirectory retaining its history. For example:\ngit subtree add --prefix=rails git://github.com/rails/rails.git master\nThis will appear as a single commit where all files of Rails master branch are added into \"rails\" directory.\nHowever the commit's title contains a reference to the old history tree:\nAdd 'rails/' from commit\n<rev>\nWhere\n<rev>\n is a SHA-1 commit hash. You can still see the history, blame some changes.\ngit log <rev>\ngit blame <rev> -- README.md\nNote that you can't see the directory prefix from here since this is an actual old branch left intact.\nYou should treat this like a usual file move commit: you will need an extra jump when reaching it.\n# finishes with all files added at once commit\ngit log rails/README.md\n# then continue from original tree\ngit log <rev> -- README.md\nThere are more complex solutions like doing this manually or rewriting the history as described in other answers.\nThe git-subtree command is a part of official git-contrib, some packet managers install it by default (OS X Homebrew).\nBut you might have to install it by yourself in addition to git."
  },
  {
    "question": "I have a script that works fine in one branch and is broken in another. I want to look at the two versions side-by-side and see what's different. Is there a way to do this?\nTo be clear\n I'm not looking for a compare tool (I use\nBeyond Compare\n). I'm looking for a Git diff command that will allow me to compare the master version to my current branch version to see what has changed. I'm not in the middle of a merge or anything. I just want to say something like\ngit diff mybranch/myfile.cs master/myfile.cs",
    "answer": "git diff\n can show you the difference between two commits:\ngit diff mybranch master -- myfile.cs\nOr, equivalently:\ngit diff mybranch..master -- myfile.cs\nNote you must specify the relative path to the file. So if the file were in the src directory, you'd say\nsrc/myfile.cs\n instead of\nmyfile.cs\n.\nUsing the latter syntax, if either side is\nHEAD\n it may be omitted (e.g.,\nmaster..\n compares\nmaster\n to\nHEAD\n).\nYou may also be interested in\nmybranch...master\n (from\ngit diff\n documentation\n):\nThis form is to view the changes on the branch containing and up to the second\n<commit>\n, starting at a common ancestor of both\n<commit>\n.\ngit diff A...B\n is equivalent to\ngit diff $(git-merge-base A B) B\n.\nIn other words, this will give a diff of changes in\nmaster\n since it diverged from\nmybranch\n (but without new changes since then in\nmybranch\n).\nIn all cases, the\n--\n separator before the file name indicates the end of command line flags (mind the space between the separator and the filename). This is optional unless Git will get confused if the argument refers to a commit or a file, but including it is not a bad habit to get into. See\nDietrich Epp's answer to\nMeaning of Git checkout double dashes\n for a few examples.\nThe same arguments can be passed to\ngit difftool\n if you have one configured."
  },
  {
    "question": "How do I iterate over a range of numbers in Bash when the range is given by a variable?\nI know I can do this (called \"sequence expression\" in the Bash\ndocumentation\n):\nfor i in {1..5}; do echo $i; done\nWhich gives:\n1\n2\n3\n4\n5\nYet, how can I replace either of the range endpoints with a variable? This doesn't work:\nEND=5\nfor i in {1..$END}; do echo $i; done\nWhich prints:\n{1..5}",
    "answer": "for i in $(seq 1 $END); do echo $i; done\nedit: I prefer\nseq\n over the other methods because I can actually remember it ;)"
  },
  {
    "question": "If I make changes to\n.bashrc\n, how do I reload it without logging out and back in?",
    "answer": "You can enter the long form command:\nsource ~/.bashrc\nor you can use the shorter version of the command:\n. ~/.bashrc"
  },
  {
    "question": "How do I recursively\ngrep\n all directories and subdirectories?\nfind . | xargs grep \"texthere\" *",
    "answer": "grep -r \"texthere\" .\nThe first parameter represents the regular expression to search for, while the second one represents the directory that should be searched. In this case,\n.\n means the current directory.\nNote: This works for GNU grep, and on some platforms like Solaris you must specifically use GNU grep as opposed to legacy implementation.  For Solaris this is the\nggrep\n command."
  },
  {
    "question": "How can I delete all of my\nGit\n stashes at once?\nSpecifically I mean, with typing in one command.",
    "answer": "The following command deletes all your stashes:\ngit stash clear\nFrom the\ngit documentation\n:\nclear\nRemove all the stashed states.\nIMPORTANT WARNING:\n Those states will then be subject to pruning, and may be impossible to recover (...)."
  },
  {
    "question": "In one of my development branches, I made some changes to my codebase. Before I was able to complete the features I was working on, I had to switch my current branch to master to demo some features. But just using a \"git checkout master\" preserved the changes I also made in my development branch, thus breaking some of the functionality in master. So what I did was commit the changes on my development branch with a commit message \"temporary commit\" and then checkout master for the demo.\nNow that I'm done with the demo and back to work on my development branch, I would like to remove the \"temporary commit\" that I made while still preserving the changes I made. Is that possible?",
    "answer": "It's as simple as this:\ngit reset HEAD^\nNote: some shells treat\n^\n as a special character (for example some Windows shells or\nZSH with globbing enabled\n), so you may have to quote\n\"HEAD^\"\n or use\nHEAD~1\n in those cases.\ngit reset\n without a\n--hard\n or\n--soft\n moves your\nHEAD\n to point to the specified commit, without changing any files.\nHEAD^\n refers to the (first) parent commit of your current commit, which in your case is the commit before the temporary one.\nNote that another option is to carry on as normal, and then at the next commit point instead run:\ngit commit --amend [-m … etc]\nwhich will instead\nedit\n the most recent commit, having the same effect as above.\nNote that this (as with nearly every git answer) can cause problems if you've already pushed the bad commit to a place where someone else may have pulled it from. Try to avoid that"
  },
  {
    "question": "I was doing some work in my repository and noticed a file had local changes. I didn't want them anymore so I deleted the file, thinking I can just checkout a fresh copy. I wanted to do the Git equivalent of\nsvn up .\nUsing\ngit pull\n didn't seem to work. Some random searching led me to a site where someone recommended doing\ngit checkout HEAD^ src/\n(\nsrc\n is the directory containing the deleted file).\nNow I find out I have a detached head. I have no idea what that is. How can I undo?",
    "answer": "Detached head means you are no longer on a branch, you have checked out a single commit in the history (in this case the commit previous to HEAD, i.e. HEAD^).\nIf you want to\nkeep\n your changes associated with the detached HEAD\nRun\ngit branch tmp\n - this will save your changes in a new branch called\ntmp\n.\nRun\ngit checkout master\nIf you would like to incorporate the changes you made into\nmaster\n, run\ngit merge tmp\n from the\nmaster\n branch. You should be on the\nmaster\n branch after running\ngit checkout master\n.\nIf you want to\ndelete\n your changes associated with the detached HEAD\nYou only need to checkout the branch you were on, e.g.\ngit checkout master\nNext time you have changed a file and want to restore it to the state it is in the index, don't delete the file first, just do\ngit checkout -- path/to/foo\nThis will restore the file foo to the state it is in the index."
  },
  {
    "question": "How do I iterate through each line of a text file with\nBash\n?\nWith this script:\necho \"Start!\"\nfor p in (peptides.txt)\ndo\n    echo \"${p}\"\ndone\nI get this output on the screen:\nStart!\n./runPep.sh: line 3: syntax error near unexpected token `('\n./runPep.sh: line 3: `for p in (peptides.txt)'\n(Later I want to do something more complicated with\n$p\n than just output to the screen.)\nThe environment variable\nSHELL\n is (from env):\nSHELL=/bin/bash\n/bin/bash --version\n output:\nGNU bash, version 3.1.17(1)-release (x86_64-suse-linux-gnu)\nCopyright (C) 2005 Free Software Foundation, Inc.\ncat /proc/version\n output:\nLinux version 2.6.18.2-34-default (geeko@buildhost) (gcc version 4.1.2 20061115 (prerelease) (SUSE Linux)) #1 SMP Mon Nov 27 11:46:27 UTC 2006\nThe file peptides.txt contains:\nRKEKNVQ\nIPKKLLQK\nQYFHQLEKMNVK\nIPKKLLQK\nGDLSTALEVAIDCYEK\nQYFHQLEKMNVKIPENIYR\nRKEKNVQ\nVLAKHGKLQDAIN\nILGFMK\nLEDVALQILL",
    "answer": "One way to do it is:\nwhile read p; do\n  echo \"$p\"\ndone <peptides.txt\nAs pointed out in the comments, this has the side effects of trimming leading whitespace, interpreting backslash sequences, and skipping the last line if it's missing a terminating linefeed. If these are concerns, you can do:\nwhile IFS=\"\" read -r p || [ -n \"$p\" ]\ndo\n  printf '%s\\n' \"$p\"\ndone < peptides.txt\nExceptionally, if the\nloop body may read from standard input\n, you can open the file using a different file descriptor:\nwhile read -u 10 p; do\n  ...\ndone 10<peptides.txt\nHere, 10 is just an arbitrary number (different from 0, 1, 2)."
  },
  {
    "question": "I have two branches in my Git repository:\nmaster\nseotweaks\n (created originally from\nmaster\n)\nI created\nseotweaks\n with the intention of quickly merging it back into\nmaster\n. However, that was three months ago and the code in this branch is 13 versions ahead of\nmaster\n.\nIt has effectively become our working master branch as all the code in\nmaster\n is more or less obsolete now.\nVery bad practice I know, lesson learned.\nDo you know how I can replace all of the contents of the\nmaster\n branch with those in\nseotweaks\n?\nI could just delete everything in\nmaster\n and merge, but this does not feel like best practice.",
    "answer": "You should be able to use the “ours” merge strategy to overwrite master with seotweaks like this:\ngit checkout master\ngit pull\ngit checkout seotweaks\ngit merge -s ours master\ngit checkout master\ngit merge seotweaks\nThe first two steps are a useful precaution to ensure your local copy of master is up-to-date. The result should be that your master is now essentially seotweaks.\n(\n-s ours\n is short for\n--strategy=ours\n)\nFrom\nthe docs\n about the 'ours' strategy:\nThis resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the recursive merge strategy.\nUpdate from comments: If you get fatal:\nrefusing to merge unrelated histories\n, then change the fourth line to this:\ngit merge --allow-unrelated-histories -s ours master"
  },
  {
    "question": "If I have a file or directory that is a symbolic link and I commit it to a Git repository, what happens to it?\nI would assume that it leaves it as a symbolic link until the file is deleted and then if you pull the file back from an old version it just creates a normal file.\nWhat does it do when I delete the file it references? Does it just commit the dangling link?",
    "answer": "From\nlinux symlink manual\n (assuming you are in Linux):\nA symbolic link is a special type of file whose contents are a string that is the pathname of another file, the file to which the link refers.  (The contents of a symbolic link can be read using readlink(2).)\nSo a symbolic link is just another file, no different than a\nREADME.md\n or a\nMakefile\n. Git just stores the contents of the link (i.e. the aforementioned path of the file system object that it links to) in a 'blob' just like it would for any other file. It then stores the name, mode and type (including the fact that it is a symlink) in the tree object that represents its containing directory.\nWhen you checkout a tree containing the link, it restores the object as a symlink regardless of whether the target file system object exists or not.\nIf you delete the file that the symlink references it doesn't affect the Git-controlled symlink in any way. You will have a dangling reference. It is up to the user to either remove or change the link to point to something valid if needed."
  },
  {
    "question": "I'm trying to figure out how I can download a particular tag of a Git repository - it's one version behind the current version.\nI saw there was a tag for the previous version on the git web page, with object name of something long hex number.\nBut the version name is \"\nTagged release 1.1.5\n\" according the site.\nI tried a command like this (with names changed):\ngit clone http://git.abc.net/git/abc.git my_abc\nAnd I did get something - a directory, a bunch of subdirectories, etc.\nIf it's the whole repository, how do I get at the version I'm seeking? If not, how do I download that particular version?",
    "answer": "$ git clone\nwill give you the whole repository.\nAfter the clone, you can list the tags with\n$ git tag -l\n and then checkout a specific tag:\n$ git checkout tags/<tag_name>\nEven better, checkout and create a branch (otherwise you will be on a branch named after the revision number of tag):\n$ git checkout tags/<tag_name> -b <branch_name>"
  },
  {
    "question": "I have my Git repository which, at the root, has two subdirectories:\n/finisht\n/static\nWhen this was in\nSVN\n,\n/finisht\n was checked out in one place, while\n/static\n was checked out elsewhere, like so:\nsvn co svn+ssh://admin@domain.example/home/admin/repos/finisht/static static\nIs there a way to do this with Git?",
    "answer": "As of Git 2.19, this is finally possible, as can be seen in\nthis answer\n.\nConsider upvoting that answer.\nNote: in Git 2.19, only client-side support is implemented, server-side support is still missing, so it only works when cloning local repositories. Also note that large Git hosters, e.g. GitHub, don't actually use the Git server, they use their own implementation, so even if support shows up in the Git server, it does not automatically mean that it works on Git hosters. (On the other hand, since they don't use the Git server, they could implement it faster in their own implementations before it shows up in Git server.)\nNo, that's not possible in Git.\nImplementing something like this in Git would be a substantial effort and it would mean that the integrity of the client-side repository could no longer be guaranteed. If you are interested, search for discussions on \"sparse clone\" and \"sparse fetch\" on the Git mailing list.\nIn general, the consensus in the Git community is that if you have several directories that are always checked out independently, then these are really two different projects and should live in two different repositories. You can glue them back together using\nGit Submodules\n."
  },
  {
    "question": "I recently switched to synchronizing my repositories to https:// on GitHub (due to firewall issues), and it asks for a password every time.\nIs there a way to cache the credentials, instead of authenticating every time that\ngit push\n?",
    "answer": "Since Git 1.7.9 (released 2012), there is a neat mechanism in Git to avoid having to type your password all the time for HTTP / HTTPS, called\ncredential helpers\n.\nYou can just use one of the following credential helpers:\ngit config --global credential.helper cache\nThe\ncredential.helper cache value\n tells Git to keep your password cached in memory for a particular amount of\nminutes\n. The default is 15 minutes, you can set a longer timeout with:\n# Cache for 1 hour\ngit config --global credential.helper \"cache --timeout=3600\"\n# Cache for 1 day\ngit config --global credential.helper \"cache --timeout=86400\"\n# Cache for 1 week\ngit config --global credential.helper \"cache --timeout=604800\"\nYou can also store your credentials permanently if so desired, see the other answers below.\nGitHub's help\nalso suggests\n that if you're on Mac OS X and used\nHomebrew\n to install Git, you can use the native Mac OS X keystore with:\ngit config --global credential.helper osxkeychain\nFor Windows\n, there is a helper called\nGit Credential Manager for Windows\n or\nwincred in msysgit\n.\ngit config --global credential.helper wincred # obsolete\nWith\nGit for Windows 2.7.3+\n (March 2016):\ngit config --global credential.helper manager\nFor Linux\n, you would use (in 2011)\ngnome-keyring\n(or other keyring implementation such as KWallet).\nNowadays (2020), that would be (on Linux)\nFedora\nsudo dnf install git-credential-libsecret\ngit config --global credential.helper /usr/libexec/git-core/git-credential-libsecret\nUbuntu\nsudo apt-get install libsecret-1-0 libsecret-1-dev\ncd /usr/share/doc/git/contrib/credential/libsecret\nsudo make\ngit config --global credential.helper /usr/share/doc/git/contrib/credential/libsecret/git-credential-libsecret"
  },
  {
    "question": "I have a\nmain\n branch with a file called\napp.js\n. I made changes to this file on an\nexperiment\n branch.\nI want to apply only the changes made to\napp.js\n from\nexperiment\n onto the\nmain\n branch.",
    "answer": "git checkout main                 # first get back to main\ngit checkout experiment -- app.js # then copy the version of app.js\n                                  # from branch \"experiment\"\nSee also\nUndo working copy modifications of one file in Git\n.\nUpdate August 2019, Git 2.23\nWith the new\ngit switch\n and\ngit restore\n commands, that would be:\ngit switch main\ngit restore --source experiment -- app.js\nBy default, only the working tree is restored.\nIf you want to update the index as well (meaning restore the file content,\nand\n add it to the index in one command):\ngit restore --source experiment --staged --worktree -- app.js\n# shorter:\ngit restore -s experiment -SW -- app.js\nAs\nJakub Narębski\n mentions in the comments:\ngit show experiment:path/to/app.js > path/to/app.js\nworks too, except that, as detailed in the SO question \"\nHow to retrieve a single file from specific revision in Git?\n\", you need to use the full path from the root directory of the repo.\nHence the path/to/app.js used by Jakub in his example.\nAs\nFrosty\n mentions in the comment:\nyou will only get the most recent state of app.js\nBut, for\ngit checkout\n or\ngit show\n, you can actually reference any revision you want, as illustrated in the SO question \"\ngit checkout revision of a file in git gui\n\":\n$ git show $REVISION:$FILENAME\n$ git checkout $REVISION -- $FILENAME\nwould be the same is $FILENAME is a\nfull path\n of a versioned file.\n$REVISION\n can be as shown in\ngit rev-parse\n:\nexperiment@{yesterday}:app.js # app.js as it was yesterday\nexperiment^:app.js            # app.js on the first commit parent\nexperiment@{2}:app.js         # app.js two commits ago\nand so on.\nschmijos\n adds\nin the comments\n:\nyou also can do this from a stash:\ngit checkout stash -- app.js\nThis is very useful if you're working on two branches and don't want to commit."
  },
  {
    "question": "How do I resolve a git merge conflict in favor of pulled changes?\nI want to remove all conflicting changes from a working tree without having to go through all of the conflicts with\ngit mergetool\n, while keeping all conflict-free changes. Preferably, I want to do this while pulling, not afterwards.",
    "answer": "If you're already in conflicted state, and do not want to checkout path one by one. You may try\ngit merge --abort\ngit pull -X theirs"
  },
  {
    "question": "I have a repository in Git. I made a branch, then did some changes both to the master and to the branch.\nThen, tens of commits later, I realized the branch is in much better state than the master, so I want the branch to \"become\" the master and disregard the changes on master.\nI cannot merge it, because I don't want to keep the changes on master. What should I do?\nExtra\n: In this case, the 'old' master has already been\npush\n-ed to another repository such as GitHub. How does this change things?",
    "answer": "The problem with the other two answers is that the new master doesn't have the old master as an ancestor, so when you push it, everyone else will get messed up. This is what you want to do:\ngit checkout better_branch          # This is the branch whose commits you want to keep\ngit merge --strategy=ours master    # keep the content of this branch, but record a merge\ngit checkout master                 # You want to **lose** all changes on this branch\ngit merge better_branch             # fast-forward master up to the merge\nIn older versions of\ngit\n, if you want your history to be a little clearer, I'd recommend adding some information to the merge commit message to make it clear what you've done. Change the second line to:\ngit merge --strategy=ours --no-commit master\ngit commit          # add information to the template merge message\nIn newer versions of git,\ngit\n will automatically open the git message editor for you. (Or you can use\ngit mere --strategy=ours master -m \"Keeping better_branch\"\n)"
  },
  {
    "question": "After the last commit, I modified a bunch of files in my working copy, but I want to undo the changes to one of those files, as in reset it to the same state as the most recent commit.\nHowever, I only want to undo the working copy changes of just that one file alone, nothing else with it.\nHow do I do that?",
    "answer": "You can use\ngit checkout -- file\nYou can do it without the\n--\n (as suggested by nimrodm), but if the filename looks like a branch or tag (or other revision identifier), it may get confused, so using\n--\n is best.\nYou can also check out a particular version of a file:\ngit checkout v1.2.3 -- file         # tag v1.2.3\ngit checkout stable -- file         # stable branch\ngit checkout origin/master -- file  # upstream master\ngit checkout HEAD -- file           # the version from the most recent commit\ngit checkout HEAD^ -- file          # the version before the most recent commit\nMore details included based on comments\nFirst check the the commits of the file\ngit log -- <filename>\nThen you can run this\ngit checkout <sha-reference> -- filename\nwhere the sha-reference is a reference to the sha of a commit, in any form (branch, tag, parent, etc."
  },
  {
    "question": "I have cloned a project that includes some\n.csproj\n files. I don't need/like my local\ncsproj\n files being tracked by Git (or being brought up when creating a patch), but clearly they are needed in the project.\nI have added\n*.csproj\n to my LOCAL\n.gitignore\n, but the files are already in the repo.\nWhen I type git status, it shows my changes to\ncsproj\n which I am not interested in keeping track of or submitting for patches.\nHow do I remove the \"tracking of\" these files from my personal repo (but keep them in the source so I can use them) so that I don't see the changes when I do a status (or create a patch)?\nIs there a correct/canonical way to handle this situation?",
    "answer": "Just calling\ngit rm --cached\n on each of the files you want to remove from revision control should be fine. As long as your local ignore patterns are correct you won't see these files included in the output of git status.\nNote that this solution removes the files from the repository, so all developers would need to maintain their own local (non-revision controlled) copies of the file\nTo prevent git from detecting changes in these files you should also use this command:\ngit update-index --assume-unchanged [path]\nWhat you probably want to do:\n (from below\n@Ryan Taylor answer\n)\nThis is to tell git you want your own independent version of the file or folder. For instance, you don't want to overwrite (or delete)\n  production/staging config files.\ngit update-index --skip-worktree <path-name>\nThe full answer is here in this URL:\nhttp://source.kohlerville.com/2009/02/untrack-files-in-git/"
  },
  {
    "question": "We've got a PHP application and want to count all the lines of code under a specific directory and its subdirectories.\nWe don't need to ignore comments, as we're just trying to get a rough idea.\nwc -l *.php\nThat command works great for a given directory, but it ignores subdirectories. I was thinking the following comment might work, but it is returning 74, which is definitely not the case...\nfind . -name '*.php' | wc -l\nWhat's the correct syntax to feed in all the files from a directory resursively?",
    "answer": "Try:\nfind . -name '*.php' | xargs wc -l\nor (when file names include special characters such as spaces)\nfind . -name '*.php' | sed 's/.*/\"&\"/' | xargs  wc -l\nThe SLOCCount tool\n may help as well.\nIt will give an accurate source lines of code count for whatever\nhierarchy you point it at, as well as some additional stats.\nSorted output:\nfind . -name '*.php' | xargs wc -l | sort -nr"
  },
  {
    "question": "I want to get a list of all the branches in a Git repository with the \"freshest\" branches at the top, where the \"freshest\" branch is the one that's been committed to most recently (and is, therefore, more likely to be one I want to pay attention to).\nIs there a way I can use Git to either (a) sort the list of branches by latest commit, or (b) get a list of branches together with each one's last-commit date, in some kind of machine-readable format?\nWorst case, I could always run\ngit branch\n to get a list of all the branches, parse its output, and then\ngit log -n 1 branchname --format=format:%ci\n for each one, to get each branch's commit date. But this will run on a Windows box, where spinning up a new process is relatively expensive, so launching the Git executable once per branch could get slow if there are a lot of branches. Is there a way to do all this with a single command?",
    "answer": "Use the\n--sort=-committerdate\n option of\ngit for-each-ref\n;\nAlso available\nsince Git 2.7.0\n for\ngit branch\n:\nBasic Usage:\ngit for-each-ref --sort=-committerdate refs/heads/\n# Or using git branch (since version 2.7.0)\ngit branch --sort=-committerdate  # DESC\ngit branch --sort=committerdate  # ASC\nResult:\nAdvanced Usage:\ngit for-each-ref --sort=committerdate refs/heads/ --format='%(HEAD) %(align:35)%(color:yellow)%(refname:short)%(color:reset)%(end) - %(color:red)%(objectname:short)%(color:reset) - %(align:40)%(contents:subject)%(end) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))'\nResult:\nPro Usage (Unix):\nYou can put the following snippet in your\n~/.gitconfig\n. The recentb alias accepts two arguments:\nrefbranch\n: which branch the\nahead\n and\nbehind\n columns are calculated against. Default\nmaster\ncount\n: how many recent branches to show. Default\n20\n[alias]\n    # ATTENTION: All aliases prefixed with ! run in /bin/sh make sure you use sh syntax, not bash/zsh or whatever\n    recentb = \"!r() { refbranch=$1 count=$2; git for-each-ref --sort=-committerdate refs/heads --format='%(refname:short)|%(HEAD)%(color:yellow)%(refname:short)|%(color:bold green)%(committerdate:relative)|%(color:blue)%(subject)|%(color:magenta)%(authorname)%(color:reset)' --color=always --count=${count:-20} | while read line; do branch=$(echo \\\"$line\\\" | awk 'BEGIN { FS = \\\"|\\\" }; { print $1 }' | tr -d '*'); ahead=$(git rev-list --count \\\"${refbranch:-origin/master}..${branch}\\\"); behind=$(git rev-list --count \\\"${branch}..${refbranch:-origin/master}\\\"); colorline=$(echo \\\"$line\\\" | sed 's/^[^|]*|//'); echo \\\"$ahead|$behind|$colorline\\\" | awk -F'|' -vOFS='|' '{$5=substr($5,1,70)}1' ; done | ( echo \\\"ahead|behind|branch|lastcommit|message|author\\n\\\" && cat) | column -ts'|';}; r\"\nResult:"
  },
  {
    "question": "To redirect\nstandard output\n to a truncated file in Bash, I know to use:\ncmd > file.txt\nTo redirect standard output in Bash, appending to a file, I know to use:\ncmd >> file.txt\nTo redirect both standard output and\nstandard error\n to a truncated file, I know to use:\ncmd &> file.txt\nHow do I redirect both standard output and standard error appending to a file?\ncmd &>> file.txt\n did not work for me.",
    "answer": "cmd >>file.txt 2>&1\nBash executes the redirects from left to right as follows:\n>>file.txt\n: Open\nfile.txt\n in append mode and redirect\nstdout\n there.\n2>&1\n: Redirect\nstderr\n to\n\"where\nstdout\n is currently going\"\n. In this case, that is a file opened in append mode. In other words, the\n&1\n reuses the file descriptor which\nstdout\n currently uses."
  },
  {
    "question": "I create a new branch in Git:\ngit branch my_branch\nPush it:\ngit push origin my_branch\nNow say someone made some changes on the server and I want to pull from\norigin/my_branch\n. I do:\ngit pull\nBut I get:\nYou asked me to pull without telling me which branch you\nwant to merge with, and 'branch.my_branch.merge' in\nyour configuration file does not tell me, either. Please\nspecify which branch you want to use on the command line and\ntry again (e.g. 'git pull <repository> <refspec>').\nSee git-pull(1) for details.\nIf you often merge with the same branch, you may want to\nuse something like the following in your configuration file:\n    [branch \"my_branch\"]\n    remote = <nickname>\n    merge = <remote-ref>\n    [remote \"<nickname>\"]\n    url = <url>\n    fetch = <refspec>\nSee git-config(1) for details.\nI learned that I can make it work with:\ngit branch --set-upstream my_branch origin/my_branch\nBut why do I need to do this for every branch I create? Isn't it obvious that if I push\nmy_branch\n into\norigin/my_branch\n, then I would want to pull\norigin/my_branch\n into\nmy_branch\n? How can I make this the default behavior?",
    "answer": "Git v2.37.1 and above\nIf you are using the mentioned version or above you can use this new config entry to automatically setup remote tracking:\ngit config --global push.autoSetupRemote true\nAfter that, when you do\ngit push\n tracking is setup automatically. No need for\ngit push -u origin my_branch\nA shortcut, which doesn't depend on remembering the syntax for\ngit branch --set-upstream\n1\n is to do:\ngit push -u origin my_branch\n... the first time that you push that branch. Or, to push to the current branch from a branch of the same name (handy for an alias):\ngit push -u origin HEAD\nYou only need to use\n-u\n once, and that sets up the association between your branch and the one at\norigin\n in the same way as\ngit branch --set-upstream\n does.\nPersonally, I think it's a good thing to have to set up that association between your branch and one on the remote explicitly.  It's just a shame that the rules are\ndifferent for\ngit push\n and\ngit pull\n.\n1\n It may sound silly, but I very frequently forget to specify the current branch, assuming that's the default - it's not, and the results are most confusing.\nUpdate 2012-10-11\n: Apparently I'm not the only person who found it easy to get wrong! Thanks to\nVonC\n for pointing out that git 1.8.0 introduces the more obvious\ngit branch --set-upstream-to\n, which can be used as follows, if you're on the branch\nmy_branch\n:\ngit branch --set-upstream-to origin/my_branch\n... or with the short option:\ngit branch -u origin/my_branch\nThis change, and its reasoning, is described in\nthe release notes for git 1.8.0, release candidate 1\n:\nIt was tempting to say\ngit branch --set-upstream origin/master\n, but that tells Git to arrange the local branch\norigin/master\n to integrate with the currently checked out branch, which is highly unlikely to be what the user meant. The option is deprecated; use the new\n--set-upstream-to\n (with a short-and-sweet\n-u\n) option instead."
  },
  {
    "question": "How do I undo this command?\ngit reset HEAD~",
    "answer": "Short answer:\ngit reset 'HEAD@{1}'\nLong answer:\nGit keeps a log of all ref updates (e.g., checkout, reset, commit, merge). You can view it by typing:\ngit reflog\nSomewhere in this list is the commit that you lost. Let's say you just typed\ngit reset HEAD~\n and want to undo it. My reflog looks like this:\n$ git reflog\n3f6db14 HEAD@{0}: HEAD~: updating HEAD\nd27924e HEAD@{1}: checkout: moving from d27924e0fe16776f0d0f1ee2933a0334a4787b4c\n[...]\nThe first line says that\nHEAD\n 0 positions ago (in other words, the current position) is 3f6db14; it was obtained by resetting to\nHEAD~\n. The second line says that\nHEAD\n 1 position ago (in other words, the state before the reset) is d27924e. It was obtained by checking out a particular commit (though that's not important right now). So, to undo the reset, run\ngit reset HEAD@{1}\n (or\ngit reset d27924e\n).\nIf, on the other hand, you've run some other commands since then that update HEAD, the commit you want won't be at the top of the list, and you'll need to search through the\nreflog\n.\nOne final note: It may be easier to look at the\nreflog\n for the specific branch you want to un-reset, say master, rather than\nHEAD\n:\n$ git reflog show master\nc24138b master@{0}: merge origin/master: Fast-forward\n90a2bf9 master@{1}: merge origin/master: Fast-forward\n[...]\nThis should have less noise it in than the general\nHEAD reflog\n."
  },
  {
    "question": "I need to check the existence of an input argument. I have the following script\nif [ \"$1\" -gt \"-1\" ]\n  then echo hi\nfi\nI get\n[: : integer expression expected\nHow do I check the input argument1 first to see if it exists?",
    "answer": "It is:\nif [ $# -eq 0 ]\n  then\n    echo \"No arguments supplied\"\nfi\nThe\n$#\n variable will tell you the number of input arguments the script was passed.\nOr you can check if an argument is an empty string or not like:\nif [ -z \"$1\" ]\n  then\n    echo \"No argument supplied\"\nfi\nThe\n-z\n switch will test if the expansion of\n\"$1\"\n is a null string or not. If it is a null string then the body is executed."
  },
  {
    "question": "I accidentally amended my previous commit. The commit should have been separate to keep history of the changes I made to a particular file.\nIs there a way to undo that last commit? If I do something like\ngit reset --hard HEAD^\n, the first commit also is undone.\n(I have not yet pushed to any remote directories)",
    "answer": "What you need to do is to create a new commit with the same details as the current\nHEAD\n commit, but with the parent as the previous version of\nHEAD\n.\ngit reset --soft\n will move the branch pointer so that the next commit happens on top of a different commit from where the current branch head is now.\n# Move the current head so that it's pointing at the old commit\n# Leave the index intact for redoing the commit.\n# HEAD@{1} gives you \"the commit that HEAD pointed at before\n# it was moved to where it currently points at\". Note that this is\n# different from HEAD~1, which gives you \"the commit that is the\n# parent node of the commit that HEAD is currently pointing to.\"\ngit reset --soft HEAD@{1}\n# commit the current tree using the commit details of the previous\n# HEAD commit. (Note that HEAD@{1} is pointing somewhere different from the\n# previous command. It's now pointing at the erroneously amended commit.)\n# The -C option takes the given commit and reuses the log message and\n# authorship information.\ngit commit -C HEAD@{1}"
  },
  {
    "question": "I have a Git repository which contains a number of subdirectories. Now I have found that one of the subdirectories is unrelated to the other and should be detached to a separate repository.\nHow can I do this while keeping the history of the files within the subdirectory?\nI guess I could make a clone and remove the unwanted parts of each clone, but I suppose this would give me the complete tree when checking out an older revision etc. This might be acceptable, but I would prefer to be able to pretend that the two repositories doesn't have a shared history.\nJust to make it clear, I have the following structure:\nXYZ/\n    .git/\n    XY1/\n    ABC/\n    XY2/\nBut I would like this instead:\nXYZ/\n    .git/\n    XY1/\n    XY2/\nABC/\n    .git/\n    ABC/",
    "answer": "Update\n: This process is so common, that the git team made it much simpler with a new tool,\ngit subtree\n. See here:\nDetach (move) subdirectory into separate Git repository\nYou want to clone your repository and then use\ngit filter-branch\n to mark everything but the subdirectory you want in your new repo to be garbage-collected.\nTo clone your local repository:\ngit clone /XYZ /ABC\n(Note: the repository will be cloned using hard-links, but that is not a problem since the hard-linked files will not be modified in themselves - new ones will be created.)\nNow, let us preserve the interesting branches which we want to rewrite as well, and then remove the origin to avoid pushing there and to make sure that old commits will not be referenced by the origin:\ncd /ABC\nfor i in branch1 br2 br3; do git branch -t $i origin/$i; done\ngit remote rm origin\nor for all remote branches:\ncd /ABC\nfor i in $(git branch -r | sed \"s/.*origin\\///\"); do git branch -t $i origin/$i; done\ngit remote rm origin\nNow you might want to also remove tags which have no relation with the subproject; you can also do that later, but you might need to prune your repo again. I did not do so and got a\nWARNING: Ref 'refs/tags/v0.1' is unchanged\n for all tags (since they were all unrelated to the subproject); additionally, after removing such tags more space will be reclaimed. Apparently\ngit filter-branch\n should be able to rewrite other tags, but I could not verify this. If you want to remove all tags, use\ngit tag -l | xargs git tag -d\n.\nThen use filter-branch and reset to exclude the other files, so they can be pruned. Let's also add\n--tag-name-filter cat --prune-empty\n to remove empty commits and to rewrite tags (note that this will have to strip their signature):\ngit filter-branch --tag-name-filter cat --prune-empty --subdirectory-filter ABC -- --all\nor alternatively, to only rewrite the HEAD branch and ignore tags and other branches:\ngit filter-branch --tag-name-filter cat --prune-empty --subdirectory-filter ABC HEAD\nThen delete the backup reflogs so the space can be truly reclaimed (although now the operation is destructive)\ngit reset --hard\ngit for-each-ref --format=\"%(refname)\" refs/original/ | xargs -n 1 git update-ref -d\ngit reflog expire --expire=now --all\ngit gc --aggressive --prune=now\nand now you have a local git repository of the ABC sub-directory with all its history preserved.\nNote: For most uses,\ngit filter-branch\n should indeed have the added parameter\n-- --all\n. Yes that's really\n-\n-\nspace\n-\n-\nall\n.  This needs to be the last parameters for the command. As Matli discovered, this keeps the project branches and tags included in the new repo.\nEdit: various suggestions from comments below were incorporated to make sure, for instance, that the repository is actually shrunk (which was not always the case before)."
  },
  {
    "question": "Once upon a time, there was a file in my project that I would now like to be able to get.\nThe problem is: I have no idea of when have I deleted it and on which path it was.\nHow can I locate the commits of this file when it existed?",
    "answer": "If you do not know the exact path you may use\ngit log --all --full-history -- \"**/thefile.*\"\nIf you know the path the file was at, you can do this:\ngit log --all --full-history -- <path-to-file>\nThis should show a list of commits in all branches which touched that file. Then, you can find the version of the file you want, and display it with...\ngit show <SHA> -- <path-to-file>\nOr restore it into your working copy with:\ngit checkout <SHA>^ -- <path-to-file>\nNote the caret symbol (\n^\n), which gets the checkout\nprior\n to the one identified, because at the moment of\n<SHA>\n commit the file is deleted, we need to look at the previous commit to get the deleted file's contents"
  },
  {
    "question": "I have deleted a file or some code in a file sometime in the past. Can I search through the content (not just the commit messages)?\nA very poor solution is to grep the log:\ngit log -p | grep <pattern>\nHowever, this doesn't return the commit hash straight away. I played around with\ngit grep\n to no avail.",
    "answer": "You should use the\npickaxe (\n-S\n)\n option of\ngit log\n.\nTo search for\nFoo\n:\ngit log -SFoo -- path_containing_change\ngit log -SFoo --since=2009.1.1 --until=2010.1.1 -- path_containing_change\nSee\nGit history - find lost line by keyword\n for more.\n-S\n (named\npickaxe\n) comes originally from a\ngit diff\n option\n (Git v0.99, May 2005).\nThen\n-S\n (\npickaxe\n) was\nported to\ngit log\n in May 2006 with Git 1.4.0-rc1.\nAs\nJakub Narębski\n commented:\nthis\nlooks for differences that introduce or remove an instance of\n<string>\n.\nIt usually means \"revisions where you added or removed line with 'Foo'\".\nthe\n--pickaxe-regex\n option allows you to use extended POSIX regex instead of searching for a string.\nExample (from\ngit log\n):\ngit log -S\"frotz\\(nitfol\" --pickaxe-regex\nAs\nRob\n commented, this search is case-sensitive - he opened a\nfollow-up question\n on how to search case-insensitive.\nHi Angel\n notes in\nthe comments\n:\nExecuting a\ngit log -G<regexp> --branches --all\n (the\n-G\n is same as\n-S\n but for regexes) does same thing as the\naccepted one\n (\ngit grep <regexp> $(git rev-list --all)\n), but it soooo much faster!\nThe accepted answer was still searching for text after ≈10 minutes of me running it, whereas this one gives results after ≈4 seconds 🤷‍♂️.\nThe output here is more useful as well"
  },
  {
    "question": "I have a remote Git server, here is the scenario which I want to perform:\nFor each bug/feature I create a different Git branch\nI keep on committing my code in that Git branch with un-official Git messages\nIn top repository we have to do one commit for one bug with official Git message\nSo how can I merge my branch to remote branch so that they get just one commit for all my check-ins (I even want to provide commit message for this)?",
    "answer": "Say your bug fix branch is called\nbugfix\n and you want to merge it into\nmaster\n:\ngit checkout master\ngit merge --squash bugfix\ngit commit\nThis will take all the commits from the\nbugfix\n branch, squash them into 1 commit, and merge it with your\nmaster\n branch.\nExplanation\n:\ngit checkout master\nSwitches to your\nmaster\n branch.\ngit merge --squash bugfix\nTakes all commits from the\nbugfix\n branch and groups it for a 1 commit with your current branch.\n(no merge commit appears; you could resolve conflicts manually before following commit)\ngit commit\nCreates a single commit from the merged changes.\nOmitting the\n-m\n parameter lets you modify a draft commit message containing every message from your squashed commits before finalizing your commit."
  },
  {
    "question": "How can I see the changes un-stashing will make to the current working tree? I would like to know what changes will be made before applying them!",
    "answer": "See the most recent stash:\ngit stash show -p\nSee an arbitrary stash:\ngit stash show -p stash@{1}\nFrom the\ngit stash\n manpages:\nBy default, the command shows the diffstat, but it will accept any\n  format known to git diff (e.g., git stash show -p stash@{1} to view\n  the second most recent stash in patch form)."
  },
  {
    "question": "I cloned a Git repository from my GitHub account to my PC.\nI want to work with both my PC and laptop, but with one GitHub account.\nWhen I try to push to or pull from GitHub using my PC, it requires a username and password, but not when I'm using the laptop!\nI don't want to type my username and password every time I interact with\norigin\n. What am I missing here?",
    "answer": "A common cause is cloning using the default (HTTPS) instead of SSH. You can correct this by going to your repository, clicking \"Clone or download\", then clicking the \"Use SSH\" button above the URL field and updating the URL of your origin remote like this:\ngit remote set-url origin git@github.com:username/repo.git\nYou can check if you have added the remote as HTTPS or SSH using:\ngit remote -v\nThis is documented at GitHub:\nSwitching remote URLs from HTTPS to SSH\n."
  },
  {
    "question": "I've set up a remote non-bare \"main\" repo and cloned it to my computer. I made some local changes, updated my local repository, and pushed the changes back to my remote repo. Things were fine up to that point.\nNow, I had to change something in the remote repo. Then I changed something in my local repo. I realized that the change to the remote repo was not needed. So I tried to\ngit push\n from my local repo to my remote repo, but I got an error like:\nTo prevent you from losing history, non-fast-forward updates were\n  rejected Merge the remote changes before pushing again.  See the 'Note\n  about fast-forwards' section of\ngit push --help\n for details.\nI thought that probably a\ngit push --force\nwould force my local copy to push changes to the remote one and make it the same.\nIt does force the update\n, but when I go back to the remote repo and make a commit, I notice that the files contain outdated changes (ones that the main remote repo previously had).\nAs I mentioned in the\ncomments to one of the answers\n:\n[I] tried forcing, but when going back to master server to save the changes, i get outdated staging. Thus, when i commit the repositories are not the same. And when i try to use git push again, i get the same error.\nHow can I fix this issue?",
    "answer": "Just do:\ngit push origin <your_branch_name> --force\nor if you have a specific repo:\ngit push https://git.... --force\nThis will delete your previous commit(s) and push your current one.\nIt may not be proper, but if anyone stumbles upon this page, thought they might want a simple solution...\nShort flag\nAlso note that\n-f\n is short for\n--force\n, so\ngit push origin <your_branch_name> -f\nwill also work."
  },
  {
    "question": "I want to pause input in a shell script, and prompt the user for choices.\nThe standard\nYes\n,\nNo\n, or\nCancel\n type question.\nHow do I accomplish this in a typical bash prompt?",
    "answer": "A widely available method to get user input at a shell prompt is the\nread\n command. Here is a demonstration:\nwhile true; do\n    read -p \"Do you wish to install this program? \" yn\n    case $yn in\n        [Yy]* ) make install; break;;\n        [Nn]* ) exit;;\n        * ) echo \"Please answer yes or no.\";;\n    esac\ndone\nAnother method,\npointed out\n by\nSteven Huwig\n, is Bash's\nselect\n command. Here is the same example using\nselect\n:\necho \"Do you wish to install this program?\"\nselect yn in \"Yes\" \"No\"; do\n    case $yn in\n        Yes ) make install; break;;\n        No ) exit;;\n    esac\ndone\nWith\nselect\n you don't need to sanitize the input – it displays the available choices, and you type a number corresponding to your choice. It also loops automatically, so there's no need for a\nwhile true\n loop to retry if they give invalid input. If you want to allow more flexible input (accepting the words of the options, rather than\njust their number\n), you can alter it like this:\necho \"Do you wish to install this program?\"\nselect strictreply in \"Yes\" \"No\"; do\n    relaxedreply=${strictreply:-$REPLY}\n    case $relaxedreply in\n        Yes | yes | y ) make install; break;;\n        No  | no  | n ) exit;;\n    esac\ndone\nAlso,\nLéa Gris\n demonstrated a way to make the request language agnostic in\nher answer\n. Adapting my first example to better serve multiple languages might look like this:\nset -- $(locale LC_MESSAGES)\nyesexpr=\"$1\"; noexpr=\"$2\"; yesword=\"$3\"; noword=\"$4\"\nwhile true; do\n    read -p \"Install (${yesword} / ${noword})? \" yn\n    if [[ \"$yn\" =~ $yesexpr ]]; then make install; exit; fi\n    if [[ \"$yn\" =~ $noexpr ]]; then exit; fi\n    echo \"Answer ${yesword} / ${noword}.\"\ndone\nObviously other communication strings remain untranslated here (Install, Answer) which would need to be addressed in a more fully completed translation, but even a partial translation would be helpful in many cases.\nFinally, please check out the\nexcellent answer\n by\nF. Hauri\n."
  },
  {
    "question": "Can I ignore files locally without polluting the global git config for everyone else? I have untracked files that are spam in my git status but I don't want to commit git config changes for every single little random untracked file I have in my local branches.",
    "answer": "From\nthe relevant Git documentation\n:\nPatterns which are specific to a particular repository but which do not need to be shared with other related repositories (e.g., auxiliary files that live inside the repository but are specific to one user's workflow) should go into the\n$GIT_DIR/info/exclude\n file.\nThe\n.git/info/exclude\n file has the same format as any\n.gitignore\n file. Another option is to set\ncore.excludesFile\n to the name of a file containing global patterns.\nNote, if you already have unstaged changes you must run the following after editing your ignore-patterns:\ngit update-index --assume-unchanged <file-list>\nNote on\n$GIT_DIR\n: This is a notation used\nall over\n the git manual simply to indicate the path to the git repository. If the environment variable is set, then it will override the location of whichever repo you're in, which probably isn't what you want.\nEdit\n: Another way is to use:\ngit update-index --skip-worktree <file-list>\nReverse it by:\ngit update-index --no-skip-worktree <file-list>"
  },
  {
    "question": "I have a local branch\nmaster\n that points to a remote branch\norigin/regacy\n (oops, typo!).\nHow do I rename the remote branch to\norigin/legacy\n or\norigin/master\n?\nI tried:\ngit remote rename regacy legacy\nBut this gave an error:\nerror : Could not rename config section 'remote.regacy' to 'remote.legacy'",
    "answer": "There are a few ways to accomplish that:\nChange your local branch and then push your changes\nPush the branch to remote with the new name while keeping the original name locally\nRenaming local and remote\n# Names of things - allows you to copy/paste commands\nold_name=feature/old\nnew_name=feature/new\nremote=origin\n# Rename the local branch to the new name\ngit branch -m $old_name $new_name\n# Delete the old branch on remote\ngit push $remote --delete $old_name\n# Or shorter way to delete remote branch [:]\ngit push $remote :$old_name\n# Prevent git from using the old name when pushing in the next step.\n# Otherwise, git will use the old upstream name instead of $new_name.\ngit branch --unset-upstream $new_name\n# Push the new branch to remote\ngit push $remote $new_name\n# Reset the upstream branch for the new_name local branch\ngit push $remote -u $new_name\nRenaming Only remote branch\nCredit:\nptim\n# In this option, we will push the branch to the remote with the new name\n# While keeping the local name as is\ngit push $remote $remote/$old_name:refs/heads/$new_name :$old_name\nImportant note:\nWhen you use the\ngit branch -m\n (move), Git is also\nupdating\n your tracking branch with the new name.\ngit remote rename legacy legacy\ngit remote rename\n is trying to update your remote section in your configuration file. It will rename the remote with the given name to the new name, but in your case, it did not find any, so the renaming failed.\nBut\n it will not do what you think; it will rename your\nlocal\n configuration remote name and\nnot\n the remote branch.\nNote\nGit servers might allow you to rename Git branches using the web interface or external programs (like Sourcetree, etc.), but you have to keep in mind that in Git all the work is done locally, so it's recommended to use the above commands to the work."
  },
  {
    "question": "Without creating a branch and doing a bunch of funky work on a new branch, is it possible to break a single commit into a few different commits after it's been committed to the local repository?",
    "answer": "git rebase -i\n will do it.\nFirst, start with a clean working directory:\ngit status\n should show no pending modifications, deletions, or additions.\nNow, you have to decide which commit(s) you want to split.\nA) Splitting the most recent commit\nTo split apart your most recent commit, first:\n$ git reset HEAD~\nNow commit the pieces individually in the usual way, producing as many commits as you need.\nB) Splitting a commit farther back\nThis requires\nrebasing\n, that is, rewriting history. To specify the correct commit, you have several choices:\nIf it is three commits back, then\n  $ git rebase -i HEAD~3\nwhere\n3\n is how many commits back it is.\nIf it is farther back in the tree than you want to count, then\n  $ git rebase -i 123abcd~\nwhere\n123abcd\n is the SHA1 of the commit you want to split up.\nIf you want to rebase the entire current branch simply do:\n  $ git rebase -i\nIf you are on a different branch (e.g., a feature branch) that you want to merge into\nmaster\n:\n  $ git rebase -i master\nWhen you get the rebase edit screen, find the commit you want to break apart.  At the beginning of that line, replace\npick\n with\nedit\n (\ne\n for short).  Save the buffer and exit.  Rebase will now stop just after the commit you want to edit.  Then:\n$ git reset HEAD~\nCommit the pieces individually in the usual way, producing as many commits as you need.\nFinally\n$ git rebase --continue\nIf you want to preserve authorship\nIf you want to preserve the authorship of commits, and possibly the date as well, see\ncopy author and date from other commit, but _not_ the message"
  },
  {
    "question": "A rather unusual situation perhaps, but I want to specify a private SSH-key to use when executing a shell (\ngit\n) command from the local computer.\nBasically like this:\ngit clone git@github.com:TheUser/TheProject.git -key \"/home/christoffer/ssh_keys/theuser\"\nOr even better (in Ruby):\nwith_key(\"/home/christoffer/ssh_keys/theuser\") do\n  sh(\"git clone git@github.com:TheUser/TheProject.git\")\nend\nI have seen examples of connecting to a remote server with\nNet::SSH\n that uses a specified private key, but this is a local command. Is it possible?",
    "answer": "Something like this should work (suggested by orip):\nssh-agent bash -c 'ssh-add /somewhere/yourkey; git clone git@github.com:user/project.git'\nif you prefer subshells, you could try the following (though it is more fragile):\nssh-agent $(ssh-add /somewhere/yourkey; git clone git@github.com:user/project.git)\nGit will invoke SSH which will find its agent by environment variable; this will, in turn, have the key loaded.\nAlternatively, setting\nHOME\n may also do the trick, provided you are willing to setup a directory that contains only a\n.ssh\n directory as\nHOME\n; this may either contain an identity.pub, or a\nconfig file\n setting IdentityFile."
  },
  {
    "question": "I used to use CShell (\ncsh\n), which lets you make an alias that takes a parameter. The notation was something like\nalias junk=\"mv \\\\!* ~/.Trash\"\nIn Bash, this does not seem to work. Given that Bash has a multitude of useful features, I would assume that this one has been implemented but I am wondering how.",
    "answer": "Bash alias does not directly accept parameters. You will have to create a function.\nalias\n does not accept parameters but a function can be called just like an alias. For example:\nmyfunction() {\n    #do things with parameters like $1 such as\n    mv \"$1\" \"$1.bak\"\n    cp \"$2\" \"$1\"\n}\nmyfunction old.conf new.conf #calls `myfunction`\nBy the way, Bash functions defined in your\n.bashrc\n and other files are available as commands within your shell. So for instance you can call the earlier function like this\n$ myfunction original.conf my.conf"
  },
  {
    "question": "How do I discard the changes to a single file and overwrite it with a fresh HEAD copy? I want to do\ngit reset --hard\n to only a single file.",
    "answer": "To reset both the working copy of\nmy-file.txt\n and its state in the Git index to that of HEAD:\ngit checkout HEAD -- my-file.txt\n--\n means\n\"treat every argument after this point as a filename\"\n. More details in\nthis answer\n. Thanks to\nVonC\n for pointing this out."
  },
  {
    "question": "Is there a way in\nbash\n to convert a string into a lower case string?\nFor example, if I have:\na=\"Hi all\"\nI want to convert it to:\n\"hi all\"",
    "answer": "There are various ways:\nPOSIX standard\ntr\n$ echo \"$a\" | tr '[:upper:]' '[:lower:]'\nhi all\nAWK\n$ echo \"$a\" | awk '{print tolower($0)}'\nhi all\nNon-POSIX\nYou may run into portability issues with the following examples:\nBash 4.0\n$ echo \"${a,,}\"\nhi all\nsed\n$ echo \"$a\" | sed -e 's/\\(.*\\)/\\L\\1/'\nhi all\n# this also works:\n$ sed -e 's/\\(.*\\)/\\L\\1/' <<< \"$a\"\nhi all\nPerl\n$ echo \"$a\" | perl -ne 'print lc'\nhi all\nBash\nlc(){\n    case \"$1\" in\n        [A-Z])\n        n=$(printf \"%d\" \"'$1\")\n        n=$((n+32))\n        printf \\\\$(printf \"%o\" \"$n\")\n        ;;\n        *)\n        printf \"%s\" \"$1\"\n        ;;\n    esac\n}\nword=\"I Love Bash\"\nfor((i=0;i<${#word};i++))\ndo\n    ch=\"${word:$i:1}\"\n    lc \"$ch\"\ndone\nNote: YMMV on this one. Doesn't work for me (GNU bash version 4.2.46 and 4.0.33 (and same behaviour 2.05b.0 but\nnocasematch\n  is not implemented)) even with using\nshopt -u nocasematch;\n. Unsetting that\nnocasematch\n causes\n[[ \"fooBaR\" == \"FOObar\" ]]\n to match OK BUT inside case weirdly\n[b-z]\n are incorrectly matched by\n[A-Z]\n. Bash is confused by the double-negative (\"unsetting nocasematch\")! :-)"
  },
  {
    "question": "git revert <commit_hash>\n alone won't work. Apparently,\n-m\n must be specified.",
    "answer": "In\ngit revert -m\n, the\n-m\n option specifies the\nparent number\n. This is needed because a merge commit has more than one parent, and Git does not know automatically which parent was the mainline, and which parent was the branch you want to un-merge.\nWhen you view a merge commit in the output of\ngit log\n, you will see its parents listed on the line that begins with\nMerge:\n (the second line in this case):\ncommit 8f937c683929b08379097828c8a04350b9b8e183\nMerge: 8989ee0 7c6b236\nAuthor: Ben James <ben@example.com>\nDate:   Wed Aug 17 22:49:41 2011 +0100\nMerge branch 'gh-pages'\nConflicts:\n    README\nIn this situation,\ngit revert 8f937c6 -m 1\n will get you the tree as it was in\n8989ee0\n, and\ngit revert -m 2\n will reinstate the tree as it was in\n7c6b236\n.\nTo better understand what you're about to revert do\ngit diff <parent_commit> <commit_to_revert>\n, in this case:\ngit diff 8989ee0 8f937c6\nand\ngit diff 7c6b236 8f937c6\nHowever, it's\nvery important\n you realize that in doing so\n\"...declares that you will never want the tree changes brought in by the merge. As a result, later merges will only bring in tree changes introduced by commits that are not ancestors of the previously reverted merge. This may or may not be what you want. See the\nrevert-a-faulty-merge How-To\n for more details.\" (\ngit-merge man page\n)."
  },
  {
    "question": "git init\ngit add .\nGives the following warnings for many files:\nThe file will have its original line endings in your working directory.\nwarning: LF will be replaced by CRLF in <filename>.\nWhat's the difference between LF and CRLF? What should I do about the warnings?",
    "answer": "In Unix systems the end of a line is represented with a line feed (LF). In windows a line is represented with a carriage return (CR) and a line feed (LF) thus (CRLF). when you get code from git that was uploaded from a unix system they will only have an LF.\nIf you are a single developer working on a windows machine, and you don't care that git automatically replaces LFs to CRLFs, you can turn this warning off by typing the following in the git command line\ngit config core.autocrlf true\nIf you want to make an intelligent decision how git should handle this,\nread the documentation\nHere is a snippet\nFormatting and Whitespace\nFormatting and whitespace issues are some of the more frustrating and\n  subtle problems that many developers encounter when collaborating,\n  especially cross-platform. It’s very easy for patches or other\n  collaborated work to introduce subtle whitespace changes because\n  editors silently introduce them, and if your files ever touch a\n  Windows system, their line endings might be replaced. Git has a few\n  configuration options to help with these issues.\ncore.autocrlf\nIf you’re programming on Windows and working with people who are not\n  (or vice-versa), you’ll probably run into line-ending issues at some\n  point. This is because Windows uses both a carriage-return character\n  and a linefeed character for newlines in its files, whereas Mac and\n  Linux systems use only the linefeed character. This is a subtle but\n  incredibly annoying fact of cross-platform work; many editors on\n  Windows silently replace existing LF-style line endings with CRLF, or\n  insert both line-ending characters when the user hits the enter key.\nGit can handle this by auto-converting CRLF line endings into LF when\n  you add a file to the index, and vice versa when it checks out code\n  onto your filesystem. You can turn on this functionality with the\n  core.autocrlf setting. If you’re on a Windows machine, set it to true\n  – this converts LF endings into CRLF when you check out code:\n$ git config --global core.autocrlf true\nIf you’re on a Linux or Mac system that uses LF line endings, then you\n  don’t want Git to automatically convert them when you check out files;\n  however, if a file with CRLF endings accidentally gets introduced,\n  then you may want Git to fix it. You can tell Git to convert CRLF to\n  LF on commit but not the other way around by setting core.autocrlf to\n  input:\n$ git config --global core.autocrlf input\nThis setup should leave you with CRLF endings in Windows checkouts,\n  but LF endings on Mac and Linux systems and in the repository.\nIf you’re a Windows programmer doing a Windows-only project, then you\n  can turn off this functionality, recording the carriage returns in the\n  repository by setting the config value to false:\n$ git config --global core.autocrlf false"
  },
  {
    "question": "I'm using Git on a new project that has two parallel -- but currently experimental -- development branches:\nmaster\n: import of existing codebase plus a few modifications that I'm generally sure of\nexp1\n: experimental branch #1\nexp2\n: experimental branch #2\nexp1\n and\nexp2\n represent two very different architectural approaches. Until I get further along I have no way of knowing which one (if either) will work. As I make progress in one branch I sometimes have edits that would be useful in the other branch and would like to merge just those.\nWhat is the best way to merge selective changes from one development branch to another while leaving behind everything else?\nApproaches I've considered:\ngit merge --no-commit\n followed by manual unstaging of a large number of edits that I don't want to make common between the branches.\nManual copying of common files into a temporary directory followed by\ngit checkout\n to move to the other branch and then more manual copying out of the temporary directory into the working tree.\nA variation on the above. Abandon the\nexp\n branches for now and use two additional local repositories for experimentation.  This makes the manual copying of files much more straightforward.\nAll three of these approaches seem tedious and error-prone.  I'm hoping there is a better approach; something akin to a filter path parameter that would make\ngit-merge\n more selective.",
    "answer": "You use the\ncherry-pick\n command to get individual commits from one branch.\nIf the change(s) you want are not in individual commits, then use the method shown here to\nsplit the commit into individual commits\n. Roughly speaking, you use\ngit rebase -i\n to get the original commit to edit, then\ngit reset HEAD^\n to selectively revert changes, then\ngit commit\n to commit that bit as a new commit in the history.\nThere is another nice method here\n in Red Hat Magazine, where they use\ngit add --patch\n or possibly\ngit add --interactive\n which allows you to add just parts of a hunk, if you want to split different changes to an individual file (search in that page for \"split\").\nHaving split the changes, you can now cherry-pick just the ones you want."
  },
  {
    "question": "How can I remove those annoying Mac OS X\n.DS_Store\n files from a Git repository?",
    "answer": "Remove existing\n.DS_Store\n files from the repository:\nfind . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch\nAdd this line:\n.DS_Store\nto the file\n.gitignore\n, which can be found at the top level of your repository (or create the file if it isn't there already). You can do this easily with this command in the top directory:\necho .DS_Store >> .gitignore\nThen commit the file to the repo:\ngit add .gitignore\ngit commit -m '.DS_Store banished!'"
  },
  {
    "question": "I'd like to show all configured Git sections.\nI only found\ngit config --get core.editor\n, and I'd like to output everything that's configured globally, not only the configured default editor.",
    "answer": "You can use:\ngit config --list\nor look at your\n~/.gitconfig\n file. The local configuration will be in your repository's\n.git/config\n file.\nUse:\ngit config --list --show-origin\nto see where that setting is defined (global, user, repo, etc...)"
  },
  {
    "question": "I made a branch called 'f' and did a checkout to master. When I tried the\ngit pull\n command I got this message:\nYou have not concluded your merge (MERGE_HEAD exists).\nPlease, commit your changes before you can merge.\nWhen I try the\ngit status\n, it gave me the following:\nOn branch master\n# Your branch and 'origin/master' have diverged,\n# and have 1 and 13 different commit(s) each, respectively.\n#\n# Changes to be committed:\n#\n#   modified:   app/assets/images/backward.png\n#   modified:   app/assets/images/forward.png\n#   new file:   app/assets/images/index_background.jpg\n#   new file:   app/assets/images/loading.gif\n#   modified:   app/assets/images/pause.png\n#   modified:   app/assets/images/play.png\n#   new file:   app/assets/javascripts/jquery-ui-bootstrap.js\n#   new file:   app/assets/stylesheets/jquery-ui-bootstrap.css\n#   modified:   app/controllers/friends_controller.rb\n#   modified:   app/controllers/plays_controller.rb\n#   modified:   app/mailers/invite_friends_mailer.rb\n#   modified:   app/mailers/send_plays_mailer.rb\n#   modified:   app/mailers/shot_chart_mailer.rb\n#   modified:   app/views/friends/show_plays.html.erb\n#   modified:   app/views/layouts/application.html.erb\n#   modified:   app/views/plays/_inbox_table.html.erb\n#   modified:   app/views/plays/show.html.erb\n#   modified:   app/views/welcome/contact_form.html.erb\n#   modified:   app/views/welcome/index.html.erb\n#   modified:   log/development.log\n#   modified:   log/restclient.log\n#   new file:   tmp/cache/assets/C1A/C00/sprockets%2Fb7901e0813446f810e560158a1a97066\n#   modified:   tmp/cache/assets/C64/930/sprockets%2F65aa1510292214f4fd1342280d521e4c\n#   new file:   tmp/cache/assets/C73/C40/sprockets%2F96912377b93498914dd04bc69fa98585\n#   new file:   tmp/cache/assets/CA9/090/sprockets%2Fa71992733a432421e67e03ff1bd441d8\n#   new file:   tmp/cache/assets/CCD/7E0/sprockets%2F47125c2ebd0e8b29b6511b7b961152a1\n#   modified:   tmp/cache/assets/CD5/DD0/sprockets%2F59d317902de6e0f68689899259caff26\n#   modified:   tmp/cache/assets/CE3/080/sprockets%2F5c3b516e854760f14eda2395c4ff2581\n#   new file:   tmp/cache/assets/CED/B20/sprockets%2F423772fde44ab6f6f861639ee71444c4\n#   new file:   tmp/cache/assets/D0C/E10/sprockets%2F8d1f4b30c6be13017565fe1b697156ce\n#   new file:   tmp/cache/assets/D12/290/sprockets%2F93ae21f3cdd5e24444ae4651913fd875\n#   new file:   tmp/cache/assets/D13/FC0/sprockets%2F57aad34b9d3c9e225205237dac9b1999\n#   new file:   tmp/cache/assets/D1D/DE0/sprockets%2F5840ff4283f6545f472be8e10ce67bb8\n#   new file:   tmp/cache/assets/D23/BD0/sprockets%2F439d5dedcc8c54560881edb9f0456819\n#   new file:   tmp/cache/assets/D24/570/sprockets%2Fb449db428fc674796e18b7a419924afe\n#   new file:   tmp/cache/assets/D28/480/sprockets%2F9aeec798a04544e478806ffe57e66a51\n#   new file:   tmp/cache/assets/D3A/ED0/sprockets%2Fcd959cbf710b366c145747eb3c062bb4\n#   new file:   tmp/cache/assets/D3C/060/sprockets%2F363ac7c9208d3bb5d7047f11c159d7ce\n#   new file:   tmp/cache/assets/D48/D00/sprockets%2Fe23c97b8996e7b5567a3080c285aaccb\n#   new file:   tmp/cache/assets/D6A/900/sprockets%2Fa5cece9476b21aa4d5f46911ca96c450\n#   new file:   tmp/cache/assets/D6C/510/sprockets%2Fb086a020de3c258cb1c67dfc9c67d546\n#   new file:   tmp/cache/assets/D70/F30/sprockets%2Facf9a6348722adf1ee7abbb695603078\n#   new file:   tmp/cache/assets/DA3/4A0/sprockets%2F69c26d0a9ca8ce383e20897cefe05aa4\n#   new file:   tmp/cache/assets/DA7/2F0/sprockets%2F61da396fb86c5ecd844a2d83ac759b4b\n#   new file:   tmp/cache/assets/DB9/C80/sprockets%2F876fbfb9685b2b8ea476fa3c67ae498b\n#   new file:   tmp/cache/assets/DBD/7A0/sprockets%2F3640ea84a1dfaf6f91a01d1d6fbe223d\n#   new file:   tmp/cache/assets/DC1/8D0/sprockets%2Fe5ee1f1cfba2144ec00b1dcd6773e691\n#   new file:   tmp/cache/assets/DCC/E60/sprockets%2Fd6a95f601456c93ff9a1bb70dea3dfc0\n#   new file:   tmp/cache/assets/DF1/130/sprockets%2Fcda4825bb42c91e2d1f1ea7b2b958bda\n#   new file:   tmp/cache/assets/E23/DE0/sprockets%2Fb1acc25c28cd1fabafbec99d169163d3\n#   new file:   tmp/cache/assets/E23/FD0/sprockets%2Fea3dbcd1f341008ef8be67b1ccc5a9c5\n#   modified:   tmp/cache/assets/E4E/AD0/sprockets%2Fb930f45cfe7c6a8d0efcada3013cc4bc\n#   new file:   tmp/cache/assets/E63/7D0/sprockets%2F77de495a665c3ebcb47befecd07baae6\n#   modified:   tmp/pids/server.pid\n#\n# Untracked files:\n#   (use \"git add <file>...\" to include in what will be committed)\n#\n#   Coachbase/\n#   log/development.log.orig\n#   log/restclient.log.orig\nWhat should I do?",
    "answer": "The problem is your previous pull failed to merge automatically and went to conflict state. And the conflict wasn't resolved properly before the next pull.\nUndo the merge and pull again.\nTo undo a merge:\ngit merge --abort\n  [Since git version 1.7.4]\ngit reset --merge\n  [prior git versions]\nResolve the conflict.\nDon't forget to add and commit the merge.\ngit pull\n now should work fine."
  },
  {
    "question": "My\n.gitignore\n file seems to be being ignored by Git - could the\n.gitignore\n file be corrupt? Which file format, locale or culture does Git expect?\nMy\n.gitignore\n:\n# This is a comment\ndebug.log\nnbproject/\nOutput from\ngit status\n:\n# On branch master\n# Your branch is ahead of 'origin/master' by 1 commit.\n#\n# Untracked files:\n#   (use \"git add <file>...\" to include in what will be committed)\n#\n#       debug.log\n#       nbproject/\nnothing added to commit but untracked files present (use \"git add\" to track)\nI would like\ndebug.log\n and\nnbproject/\n not to appear in the untracked files list.\nWhere should I start looking to fix this?",
    "answer": "Fixed. OK, I created the .gitignore file in Notepad on Windows and it wasn't working. When I viewed the .gitignore file on Linux it looked like organised gibberish - perhaps Notepad had written out Unicode rather than ASCII or whatever 8-bit is.\nSo I rewrote the file on my Linux box, and when I pulled it back into Windows it works fine! Hurrah!"
  },
  {
    "question": "I'm new at the branching complexities of Git. I always work on a single branch and commit changes and then periodically push to my remote origin.\nSomewhere recently, I did a reset of some files to get them out of commit staging, and later did a\nrebase -i\n to get rid of a couple recent local commits. Now I'm in a state I don't quite understand.\nIn my working area,\ngit log\n shows exactly what I'd expect-- I'm on the right train with the commits I didn't want gone, and new ones there, etc.\nBut I just pushed to the remote repository, and what's there is different-- a couple of the commits I'd killed in the rebase got pushed, and the new ones committed locally aren't there.\nI think \"master/origin\" is detached from HEAD, but I'm not 100% clear on what that means, how to visualize it with the command line tools, and how to fix it.",
    "answer": "First, let’s clarify\nwhat HEAD is\n and what it means when it is detached.\nHEAD is the symbolic name for the currently checked out commit. When HEAD is not detached (the “normal”\n1\n situation: you have a branch checked out), HEAD actually points to a branch’s “ref” and the branch points to the commit. HEAD is thus “attached” to a branch. When you make a new commit, the branch that HEAD points to is updated to point to the new commit. HEAD follows automatically since it just points to the branch.\ngit symbolic-ref HEAD\n yields\nrefs/heads/master\nThe branch named “master” is checked out.\ngit rev-parse refs/heads/master\n yield\n17a02998078923f2d62811326d130de991d1a95a\nThat commit is the current tip or “head” of the master branch.\ngit rev-parse HEAD\n also yields\n17a02998078923f2d62811326d130de991d1a95a\nThis is what it means to be a “symbolic ref”. It points to an object through some other reference.\n(Symbolic refs were originally implemented as symbolic links, but later changed to plain files with extra interpretation so that they could be used on platforms that do not have symlinks.)\nWe have\nHEAD\n →\nrefs/heads/master\n →\n17a02998078923f2d62811326d130de991d1a95a\nWhen HEAD is detached, it points directly to a commit—instead of indirectly pointing to one through a branch. You can think of a detached HEAD as being on an unnamed branch.\ngit symbolic-ref HEAD\n fails with\nfatal: ref HEAD is not a symbolic ref\ngit rev-parse HEAD\n yields\n17a02998078923f2d62811326d130de991d1a95a\nSince it is not a symbolic ref, it must point directly to the commit itself.\nWe have\nHEAD\n →\n17a02998078923f2d62811326d130de991d1a95a\nThe important thing to remember with a detached HEAD is that if the commit it points to is otherwise unreferenced (no other ref can reach it), then it will become “dangling” when you checkout some other commit. Eventually, such dangling commits will be pruned through the garbage collection process (by default, they are kept for at least 2 weeks and may be kept longer by being referenced by HEAD’s reflog).\n1\nIt is perfectly fine to do “normal” work with a detached HEAD, you just have to keep track of what you are doing to avoid having to fish dropped history out of the reflog.\nThe intermediate steps of an interactive rebase are done with a detached HEAD (partially to avoid polluting the active branch’s reflog). If you finish the full rebase operation, it will update your original branch with the cumulative result of the rebase operation and reattach HEAD to the original branch. My guess is that you never fully completed the rebase process; this will leave you with a detached HEAD pointing to the commit that was most recently processed by the rebase operation.\nTo recover from your situation, you should create a branch that points to the commit currently pointed to by your detached HEAD:\ngit branch temp\ngit checkout temp\n(these two commands can be abbreviated as\ngit checkout -b temp\n)\nThis will reattach your HEAD to the new\ntemp\n branch.\nNext, you should compare the current commit (and its history) with the normal branch on which you expected to be working:\ngit log --graph --decorate --pretty=oneline --abbrev-commit master origin/master temp\ngit diff master temp\ngit diff origin/master temp\n(You will probably want to experiment with the log options: add\n-p\n, leave off\n--pretty=…\n to see the whole log message, etc.)\nIf your new\ntemp\n branch looks good, you may want to update (e.g.)\nmaster\n to point to it:\ngit branch -f master temp\ngit checkout master\n(these two commands can be abbreviated as\ngit checkout -B master temp\n)\nYou can then delete the temporary branch:\ngit branch -d temp\nFinally, you will probably want to push the reestablished history:\ngit push origin master\nYou may need to add\n--force\n to the end of this command to push if the remote branch can not be “fast-forwarded” to the new commit (i.e. you dropped, or rewrote some existing commit, or otherwise rewrote some bit of history).\nIf you were in the middle of a rebase operation you should probably clean it up. You can check whether a rebase was in process by looking for the directory\n.git/rebase-merge/\n. You can manually clean up the in-progress rebase by just deleting that directory (e.g. if you no longer remember the purpose and context of the active rebase operation). Usually you would use\ngit rebase --abort\n, but that does some extra resetting that you probably want to avoid (it moves HEAD back to the original branch and resets it back to the original commit, which will undo some of the work we did above)."
  },
  {
    "question": "I have two branches:\nmaster\n and\ndev\nI want to create a \"feature branch\" from the\ndev\n branch.\nCurrently on the branch\ndev\n, I do:\ngit checkout -b myfeature dev\n... (some work)\ngit commit -am \"blablabla\"\ngit push origin myfeature\nBut, after visualizing my branches, I got:\n--**master**\n------0-----0-----0-----0-----0\n------------------------**dev**----**myfeature**\nI mean that the branch seems\nfast-forward\n merged, and I don't understand why...\nWhat am I doing wrong?\nHow can you branch off from another branch and push back to the remote repository for the feature branch?\nAll that in a branching model like\nthe one described here\n.",
    "answer": "If you like the method in the link you've posted, have a look at\nGit Flow\n.\nIt's a set of scripts he created for that workflow.\nBut to answer your question:\ngit checkout -b myFeature dev\nCreates the\nmyFeature\n branch off\ndev\n. Do your work and then\ngit commit -am \"Your message\"\nNow merge your changes to\ndev\n without a fast-forward\ngit checkout dev\ngit merge --no-ff myFeature\nNow push the changes to the server\ngit push origin dev\ngit push origin myFeature\nAnd you'll see it how you want it."
  },
  {
    "question": "I have a Git repository that looks like this:\nA <- B <- C <- D <- HEAD\nI want the head of the branch to point to A, i.e., I want B, C, D, and HEAD to disappear and I want head to be synonymous with A.\nIt sounds like I can either try to rebase (doesn't apply, since I've pushed changes in between), or revert. But how do I revert multiple commits? Do I revert one at a time? Is the order important?",
    "answer": "Expanding what I wrote in a comment\nThe general rule is that you should not rewrite (change) history that you have published, because somebody might have based their work on it.  If you rewrite (change) history, you would make problems with merging their changes and with updating for them.\nSo the solution is to create a\nnew commit\n which\nreverts changes\n that you want to get rid of.  You can do this using\ngit revert\n command.\nYou have the following situation:\nA <-- B  <-- C <-- D                                  <-- master <-- HEAD\n(arrows here refers to the direction of the pointer: the \"parent\" reference in the case of commits, the top commit in the case of branch head (branch ref), and the name of branch in the case of HEAD reference).\nWhat you need to create is the following:\nA <-- B  <-- C <-- D <-- [(BCD)\n-1\n]                   <-- master <-- HEAD\nwhere\n[(BCD)^-1]\n means the commit that reverts changes in commits B, C, D.  Mathematics tells us that (BCD)\n-1\n = D\n-1\n C\n-1\n B\n-1\n, so you can get the required situation using the following commands:\n$ git revert --no-commit D\n$ git revert --no-commit C\n$ git revert --no-commit B\n$ git commit -m \"the commit message for all of them\"\nWorks for everything except merge commits.\nAlternate solution would be to\ncheckout\ncontents\n of commit A, and commit this state.  Also works with merge commits.  Added files will not be deleted, however.  If you have any local changes\ngit stash\n them first:\n$ git checkout -f A -- . # checkout that revision over the top of local files\n$ git commit -a\nThen you would have the following situation:\nA <-- B  <-- C <-- D <-- A'                       <-- master <-- HEAD\nThe commit A' has the same contents as commit A, but is a different commit (commit message, parents, commit date).\nAlternate\nsolution by Jeff Ferland, modified by Charles Bailey\n builds upon the same idea, but uses\ngit reset\n.  Here it is slightly modified, this way WORKS FOR EVERYTHING:\n$ git reset --hard A\n$ git reset --soft D # (or ORIG_HEAD or @{1} [previous location of HEAD]), all of which are D\n$ git commit"
  },
  {
    "question": "I have made a git commit and subsequent push. I would like to change the commit message. If I understand correctly, this is not advisable because someone might have pulled from the remote repository before I make such changes. What if I know that no one has pulled?\nIs there a way to do this?",
    "answer": "Changing history\nIf it is the most recent commit, you can simply do this:\ngit commit --amend\nThis brings up the editor with the last commit message and lets you edit the message.  (You can use\n-m\n if you want to wipe out the old message and use a new one.)\nPushing\nAnd then when you push, do this:\ngit push --force-with-lease <repository> <branch>\nOr you can use \"+\":\ngit push <repository> +<branch>\nOr you can use\n--force\n:\ngit push --force <repository> <branch>\nBe careful when using these commands.\nIf someone else pushed changes to the same branch, you probably want to avoid destroying those changes.  The\n--force-with-lease\n option is the safest, because it will abort if there are any upstream changes (\nIf you don't specify the branch explicitly, Git will use the default push settings.  If your default push setting is \"matching\", then you may destroy changes on several branches at the same time.\nPulling / fetching afterwards\nAnyone who already pulled will now get an error message, and they will need to update (assuming they aren't making any changes themselves) by doing something like this:\ngit fetch origin\ngit reset --hard origin/master # Loses local commits\nBe careful when using\nreset --hard\n.  If you have changes to the branch, those changes will be destroyed.\nA note about modifying history\nThe destroyed data is really just the old commit message, but\n--force\n doesn't know that, and will happily delete other data too.  So think of\n--force\n as \"I want to destroy data, and I know for sure what data is being destroyed.\"  But when the destroyed data is committed, you can often recover old commits from the reflog—the data is actually\norphaned\n instead of destroyed (although orphaned commits are periodically deleted).\nIf you don't think you're destroying data, then stay away from\n--force\n...\nbad things might happen\n.\nThis is why\n--force-with-lease\n is somewhat safer."
  },
  {
    "question": "How can I delete a single directory containing files from a Git repository?",
    "answer": "Remove directory from Git and local\nCheckout 'master' with both directories:\ngit rm -r one-of-the-directories // This deletes from filesystem\ngit commit . -m \"Remove duplicated directory\"\ngit push origin <your-git-branch> (typically 'master', but not always)\nRemove directory from Git but NOT local\nTo remove this directory from Git, but not delete it entirely from the filesystem (local):\ngit rm -r --cached myFolder"
  },
  {
    "question": "When using\ngit log\n, how can I filter by user so that I see only commits from that user?",
    "answer": "This works for both\ngit log\n and\ngitk\n - the 2 most common ways of viewing history.\nYou don't need to use the whole name:\ngit log --author=\"Jon\"\nwill match a commit made by \"Jonathan Smith\"\ngit log --author=Jon\nand\ngit log --author=Smith\nwould also work. The quotes are optional if you don't need any spaces.\nAdd\n--all\n if you intend to search all branches and not just the current commit's ancestors in your repo.\nYou can also easily match on multiple authors as regex is the underlying mechanism for this filter. So to list commits by Jonathan or Adam, you can do this:\ngit log --author=\"\\(Adam\\)\\|\\(Jon\\)\"\nIn order to exclude commits by a particular author or set of authors using regular expressions as noted\nin this question\n, you can use a\nnegative lookahead\n in combination with the\n--perl-regexp\n switch:\ngit log --author='^(?!Adam|Jon).*$' --perl-regexp\nAlternatively, you can exclude commits authored by Adam by using\nbash\n and piping:\ngit log --format='%H %an' |\n  grep -v Adam |\n  cut -d ' ' -f1 |\n  xargs -n1 git log -1\nIf you want to exclude commits commited (but not necessarily authored) by Adam, replace\n%an\n with\n%cn\n. More details about this are in my blog post here:\nhttp://dymitruk.com/blog/2012/07/18/filtering-by-author-name/"
  },
  {
    "question": "Is it possible to undo the changes caused by the following command? If so, how?\ngit reset --hard HEAD~1",
    "answer": "Pat Notz is correct.  You can get the commit back so long as it's been within a few days.  git only garbage collects after about a month or so unless you explicitly tell it to remove newer blobs.\n$ git init\nInitialized empty Git repository in .git/\n$ echo \"testing reset\" > file1\n$ git add file1\n$ git commit -m 'added file1'\nCreated initial commit 1a75c1d: added file1\n 1 files changed, 1 insertions(+), 0 deletions(-)\n create mode 100644 file1\n$ echo \"added new file\" > file2\n$ git add file2\n$ git commit -m 'added file2'\nCreated commit f6e5064: added file2\n 1 files changed, 1 insertions(+), 0 deletions(-)\n create mode 100644 file2\n$ git reset --hard HEAD^\nHEAD is now at 1a75c1d... added file1\n$ cat file2\ncat: file2: No such file or directory\n$ git reflog\n1a75c1d... HEAD@{0}: reset --hard HEAD^: updating HEAD\nf6e5064... HEAD@{1}: commit: added file2\n$ git reset --hard f6e5064\nHEAD is now at f6e5064... added file2\n$ cat file2\nadded new file\nYou can see in the example that the file2 was removed as a result of the hard reset, but was put back in place when I reset via the reflog."
  },
  {
    "question": "I have a Git repository with n commits.\nI have a file that I need, and that used to be in the repository, and that I suddenly look for and think \"Oh! Where'd that file go?\"\nIs there a (series of) Git command(s) that will tell me that \"file really_needed.txt was deleted at commit n-13\"?\nIn other words, without looking at every individual commit, and knowing that my Git repo has every change of every file, can I quickly find the last commit that HAS that file, so I can get it back?",
    "answer": "To show the commits that changed a file, even if the file was deleted, run this command:\ngit log --all -- [file path]\nIf you want to see only the last commit, which deleted the file, use\n-1\n in addition to the command above:\ngit log --all -1 -- [file path]\nNOTE:\ngit log --full-history -- [file path]\n does\nNOT\n work in git version 2.42.0)\nSee also my article:\nWhich commit deleted a file\n."
  },
  {
    "question": "I created a Git repository with\ngit init\n. I'd like to delete it entirely and initialise a new one.",
    "answer": "Git keeps all of its files in the\n.git\n directory. Just remove that one and initialise again.\nIf you can't find it, it's because it is hidden.\nIn\nWindows 7\n, you need to go to your folder, click on\nOrganize\n on the top left, then click on\nFolder and search options\n, then click on the\nView\n tab and click on the\nShow hidden files, folders and drives\n radio button.\nOn a Mac OS X:\nOpen a\nTerminal\n instance (via\nSpotlight\n: press\nCMD\n +\nSPACE\n, type\nterminal\n and press\nEnter\n) and run:\n  defaults write com.apple.finder AppleShowAllFiles 1 && killall Finder\nNote: The keyboard shortcut to show hidden files in\nFinder\n is\nCMD\n +\nSHIFT\n +\n.\n, so it isn't necessary any longer to modify the Finder configuration this way\nYou could also type\ncd\n (the space is important), drag and drop your Git repository folder from Finder to the terminal window, press\nreturn\n, type\nrm -fr .git\n, and then\nreturn\n again.\nOn\nUbuntu\n (\nLinux\n), use shortcut\nCtrl\n +\nH\n."
  }
]